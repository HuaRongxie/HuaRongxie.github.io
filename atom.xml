<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HuaRongxie&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-03-10T05:16:12.653Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>HuaRongxie</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JVM内存模型、垃圾回收、类加载</title>
    <link href="http://yoursite.com/2019/01/13/zhuan-java66/"/>
    <id>http://yoursite.com/2019/01/13/zhuan-java66/</id>
    <published>2019-01-13T05:14:01.000Z</published>
    <updated>2019-03-10T05:16:12.653Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM内存模型、垃圾回收、类加载"><a href="#JVM内存模型、垃圾回收、类加载" class="headerlink" title="JVM内存模型、垃圾回收、类加载"></a>JVM内存模型、垃圾回收、类加载</h1><h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><p>JVM 中有的区域是线程私有，有的区域是线程共享的。如程序计数器、Java虚拟机栈、本地方法栈均为线程私有；堆、方法区、直接内存均为线程共享。</p><p><strong>程序计数器</strong>:记录正在执行的字节码指令地址。若执行本地方法，则为 undefined。该区域是 JVM 中唯一不会发生 OutOfMemoryError 的区域。</p><p><strong>Java 虚拟机栈</strong>:每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用到执行完成的过程对应一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</p><p>这个区域可能发生两种异常:</p><ul><li>当线程请求的栈深度超过最大值，会抛出 Stack OverflowError 异常。</li><li>栈进行动态扩展时，无法申请足够内存，会抛出 OutOfMemoryError 异常。</li></ul><p><strong>本地方法栈</strong>:本地方法栈与 Java 虚拟机栈相似，它们之间的区别主要是本地方法栈为本地方法服务。</p><p><strong>堆</strong>:几乎所有的对象都在堆中分配。是垃圾回收的主要区域。现代的垃圾收集器基本都是采用分代收集算法，其主要思想是针对不同类型的对象采用不同的垃圾回收算法。可以将堆分成两块新生代和老年代。堆不需要的连续的内存，并且可以动态扩展内存。扩展失败则抛出 OutOfMemoryError 异常。虚拟机参数: -Xms :堆的初始大小; -Xmx :堆的最大值。</p><p>Java 对象的分配过程是编译器先通过逃逸分析，确定对象是在栈上分配还是堆上分配。(逃逸分析:是一种可以有效减少 Java 程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。通过逃逸分析，HotSpot 编译器能够分析出一个新的对象的引用的使用范围从而决定是否将这个对象分配到堆上)</p><p><strong>在堆中为对象分配内存主要有两种方式</strong>:</p><ul><li><p>指针碰撞法</p><p>假设 Java 堆中内存是完整的，已分配的内存和空闲内存分别在不同的一侧，通过一个指针作为分界点，需要分配内存时，仅仅需要把指针往空闲的一端移动与对象大小相等的距离。</p></li><li><p>空闲列表法</p><p>事实上，Java 堆的内存并不是完整的，已分配的内存和空闲内存相互交错， JVM 通过维护一个列表，记录可用的内存块信息，当分配操作发生时，从列表中找到一个足够大的内存块分配给对象实例，并更新列表上的记录。</p></li></ul><p>对象创建是一个非常频繁的行为，进行堆内存分配时还需要考虑多线程并发问题，可能出现正在给对象 A 分配内存，指针或记录还未更新，对象 B 又同时分配到原来的内存，解决这个问题有两种方案：</p><ol><li>采用 CAS 保证数据更新操作的原子性；</li><li>把内存分配的行为按照线程进行划分，在不同的空间中进行，每个线程在 Java 堆中预先分配一个内存块，称为本地线程分配缓冲（Thread Local Allocation Buffer, TLAB）;</li></ol><p><strong>方法区</strong>:用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。和堆一样不需要连续的内存，并且可以动态扩展，扩展失败则抛出 OutOfMemoryError 异常。对这块区域进行垃圾回收的主要目的是对常量池的回收和类的卸载，但一般很难实现。 HotSpot 虚拟机是把它当成永久代来进行垃圾回收的。但很难确定永久代的大小。因为它受很多因素影响，并且每次 FullGC 之后，永久代的大小都会改变，所以容易出现 OutOfMemoryError 异常。为了更容易管理方法区。从 JDK 1.8开始，移除永久代，并把方法区移至元空间。它位于本地内存中，而不是虚拟机内存中。</p><p><strong>运行时常量池</strong>:运行时常量池是方法区的一部分。 Class 文件中的常量池(编译期生成的各种字面量和符号引用)会在类加载后被放入这个区域。除了在编译期生成的常量，还允许动态生成。例如 String 类的 intern() 方法。</p><p><strong>直接内存</strong>:在 JDK 1.4时新增加入 NIO 类，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆内的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样可以在一些场景中提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。</p><h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><p><strong>标记-清除</strong></p><p>标记要回收的对象，然后清除。</p><p>不足:1.标记与清除效率不高。2.会产生大量内存碎片，可能导致无法给大对象分配内存。</p><p><strong>标记-整理</strong></p><p>让所有存活的对象移动到一端，然后清理掉端边界以外的内存。</p><p><strong>复制</strong></p><p>把内存划分为大小相等的两块，每次只使用其中一块，当这块内存使用完了就将还存活的对象复制到另外一块上，然后再把使用过的内存清理一遍。</p><p>不足:只使用了一半内存。</p><p><em>拓展</em> :现代的商业虚拟机都采用复制算法来回收新生代，但不是把新生代划分为大小相等的两块，而是分为一块较大的 Eden 区和两块较小的 Survivor 区。每次只使用 Eden 区和其中一块 Survivor 区，在回收的时候，将 Eden 区和 Survivor 区中还存活的对象一次性复制到另一块 Survivor 区中，最后清理 Eden 和那块使用过的Survivor 区。在 HotSpot 虚拟机中 Eden 和 Survivor 区域大小默认比例为8:1，内存使用率为百分之90.如果每次回收存活的对象大于10%,此时需要依赖老年代进行分配担保，也就是借用老年代的空间存储放不下的对象。</p><p><strong>分代算法</strong></p><p>现在的商用虚拟机采用分代算法算法。一般将堆分成新生代和老年代。新生代使用复制算法，老年代使用标记-清除算法或者是标记-整理算法。</p><h2 id="如何判断一个对象是否可回收"><a href="#如何判断一个对象是否可回收" class="headerlink" title="如何判断一个对象是否可回收"></a>如何判断一个对象是否可回收</h2><p><strong>引用计数算法</strong></p><p>给对象添加一个引用计数器。当对象增加一个引用时，计数器加1，引用失效时，计数器减1。引用计数为0的对象可以被回收。两个对象出现循环可用的情况下，引用计数器永不为0，导致无法对它们进行回收。正因为循环引用的存在，Java虚拟机不使用引用计数算法。</p><p><strong>可达性分析算法</strong></p><p>通过 GC Roots 作为起始点进行搜索，能够到达的对象都是存活的，不可达的对象可以被回收。</p><p>GC Roots:</p><ol><li>虚拟机栈中局部变量表中引用的对象</li><li>本地方法栈中 JNI 中引用的对象</li><li>方法区中静态属性引用的对象</li><li>方法区中常量引用的对象</li></ol><p><strong>方法区的回收</strong></p><p>方法区的回收主要是对常量池的回收和对类的卸载。</p><h2 id="类的加载机制"><a href="#类的加载机制" class="headerlink" title="类的加载机制"></a>类的加载机制</h2><p>类从加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括:加载-验证-准备-解析-初始化-使用-卸载。其中验证-准备-解析称为链接( Linking )。加载、验证、准备、初始化、卸载这五个阶段顺序是确定的，解析在某些情况下会在初始化后进行。</p><p><strong>加载( Loading )</strong></p><p>在加载阶段，虚拟机需要完成下面3件事:</p><ol><li>通过一个类的全限定名获取定义此类的二进制字节流，实现这个动作的代码就是”类加载器”，获取的途径不仅仅是 Class 文件，也可能来源网络、数据库等。</li><li>将这个字节流所表示的静态存储结构转化为方法区运行时数据结构。</li><li>在内存中生成一个代表这个类的 class 对象，作为方法区的各种数据的访问入口。</li></ol><p>加载阶段和链接阶段的部分内容是交叉进行的(如部分字节码格式验证)。加载阶段还没结束，链接阶段可能已经开始了，夹杂在加载阶段操作依然属于链接阶段，并且加载阶段和链接阶段的开始时间是仍然保持固定的先后顺序的。加载阶段可以是用户参与的阶段，开发人员可以自定义类加载器，去实现自己的类加载过程。</p><p><em>拓展</em>:</p><h6 id="JVM-是按需加载类的"><a href="#JVM-是按需加载类的" class="headerlink" title="JVM 是按需加载类的"></a>JVM 是按需加载类的</h6><p>JVM 如果加载一个jar包，只会在加载那些明确使用到的类到内存中。要查看JVM到底加载哪些类可以在启动参数上加<code>-verbose:class</code></p><h6 id="JDK-内建的类加载器"><a href="#JDK-内建的类加载器" class="headerlink" title="JDK 内建的类加载器"></a><strong>JDK 内建的类加载器</strong></h6><ul><li>启动类加载器( Bootstrap Class-Loader )，负责加载 jre/lib 下面的 jar 文件。</li><li>扩展类加载器( Extension or Ext Class-Loader )，负责加载 jre/lib/ext 下面的 jar 文件。</li><li>应用类加载器( Application or App Class-Loade r)，加载 classpath 的的内容。</li></ul><h6 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a><strong>ClassLoader</strong></h6><p>ClassLoader 主要有三个作用:加载 Class 到 JVM 中；审查每个类该由谁加载，它是一种父优先的加载机制；将 Class 字节码重新解析成 JVM 统一要求的对象格式。</p><p><strong>验证( Verification )</strong></p><p>验证的目的是为了确保 class 文件的字节流中包含的信息符合当前虚拟机的要求，且不会危害虚拟机自身的安全。验证阶段大致会完成下面4个阶段的验证动作:</p><ol><li>文件格式验证:验证字节流是否符合class文件的规范，如是否以魔数0xCAFEBABE开头。</li><li>元数据验证:对字节码描述的信息进行语义分析。以保证其描述的信息符合 Java 语言规范。</li><li>字节码验证:字节码验证将对类的方法进行校验分析，保证被校验的方法在运行时不会做出危害虚拟机的事，一个类方法体的字节码没有通过字节码验证，那一定有问题，但若一个方法通过了验证，也不能说明它一定安全。</li><li>符号引用验证:确保解析动作能够正确执行。</li></ol><p>验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用 -Xverifynone 参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p><p><strong>准备( Preparation )</strong></p><p>准备阶段是正式为类的静态变量分配内存并设置变量的初始值的阶段，这些变量所使用的内存都将在方法区中分配。</p><p>如 <code>public static int a=123;</code>准备阶段后 a 的值为 0，而不是 123，要在初始化之后才变为 123，但若被 final 修饰，<code>public static final int a=123;</code>在准备阶段后就变为了 123。</p><p><strong>解析( Resolution )</strong></p><p>解析阶段是虚拟机将常量池中的符号引用变为直接引用的过程。</p><p>符号引用（Symbolic Reference）：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。</p><p>直接引用（Direct Reference）：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机实现的内存布局相关的，如果有了直接引用，那么引用的目标必定已经在内存中存在。</p><p><strong>初始化(Initialization)</strong></p><p>类初始化是类加载过程的最后一步，前面的类加载过程，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的 Java 程序代码。</p><p>初始化阶段是执行类构造器<code>&lt;clinit&gt;()</code>方法的过程。<code>&lt;clinit&gt;()</code>方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块(static{}块中的语句)合并产生的。</p><p>虚拟机会保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程环境中被正确的加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<code>&lt;clinit&gt;()</code>方法，其他线程都需要阻塞等待，直到活动线程执行<code>&lt;clinit&gt;()</code>方法完毕。如果在一个类的<code>&lt;clinit&gt;()</code>方法中有耗时很长的操作，就可能造成多个线程阻塞，在实际应用中这种阻塞往往是隐藏的。</p><p>在遇到下列情况时，若没有初始化，则需要触发其初始化（加载-验证-准备自然需 要在此之前）：</p><ol><li>A.使用 new 关键字实例化对象 B.读取或设置一个类的静态字段 C.调用一个类的静态方法。</li><li>使用 java.lang.reflect 包的方法对类进行反射调用时，若类没有进行初始化，则需要触发其初始化</li><li>当初始化一个类时，若发现其父类还没有进行初始化，则要先触发其父类的初始化。</li><li>当虚拟机启动时，用户需要制定一个要执行的主类（有 main 方法的那个类），虚拟机会先初始化这个类。</li><li>当使用JDK1.7动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果 REF_getstatic, REF_putstatic, REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行初始化，则需要先出触发其初始化。</li></ol><p><strong>类的卸载</strong></p><p>类的卸载条件必须满足以下条件，并且满足了也不一定会卸载。</p><ol><li>该类的所有实例被回收</li><li>加载该类的 Class Loader 已经被回收</li><li>该类对应的 Class 对象没有被引用</li></ol><p>需要注意的是，JVM 所创建的三个默认类加载器 Bootstrap ClassLoader、ExtClassLoader 和 AppClassLoader 都不可能满足这些条件，因此，任何系统类(例如 java.lang.String )或者通过应用程序类加载器加载的任何应用程序类都不能在运行时释放。</p><p><strong>类加载机制的三个基本特征</strong></p><ol><li>双亲委派模型。但不是所有类加载器都遵守这个模型。有时候，启动类加载器所加载的类型，可能是要加载用户代码的，比如JDK内部的ServiceProvider/ServiceLoader 机制，用户可以在标准API框架上，提供自己的实现，JDK也需要提供些默认的参考实现。例如， Java中 JNDI、 JDBC、文件系统、 Cipher 等很多方面，都是利用的这种机制，这种情况就不会用双亲委派模型去加载，而是利用所谓的上下文加载器。</li><li>可见性，子类加载器可以访问父加载器加载的类型，但是反过来是不允许的，不然因为缺少必要的隔离，我们就没有办法利用类加载器去实现容器的逻辑。</li><li>单一性，由于父加载器的类型对于子加载器是可见的，所以父加载器中加载过的类型，就不会再子加载器中重复加载。但是，在类加载器”邻居”之间，同一类型仍然可以被加载多次，因为互相之间并不可见。</li></ol><h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><p>双亲委派模型，就是当类加载器试图加载某个类型的时候，除非父加载器找不到相应类型，否则尽量将这个任务代理给当前加载器的父加载器去做。使用双亲委派模型的目的是避免重复加载Java类型。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JVM内存模型、垃圾回收、类加载&quot;&gt;&lt;a href=&quot;#JVM内存模型、垃圾回收、类加载&quot; class=&quot;headerlink&quot; title=&quot;JVM内存模型、垃圾回收、类加载&quot;&gt;&lt;/a&gt;JVM内存模型、垃圾回收、类加载&lt;/h1&gt;&lt;h2 id=&quot;运行时数据区域&quot;&gt;
      
    
    </summary>
    
      <category term="JVM" scheme="http://yoursite.com/categories/JVM/"/>
    
    
      <category term="JVM内存模型、垃圾回收、类加载" scheme="http://yoursite.com/tags/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E3%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>表达式与运算符</title>
    <link href="http://yoursite.com/2018/12/01/expression-operate/"/>
    <id>http://yoursite.com/2018/12/01/expression-operate/</id>
    <published>2018-12-01T11:57:07.000Z</published>
    <updated>2019-03-10T05:42:15.378Z</updated>
    
    <content type="html"><![CDATA[<h1 id="表达式与运算符-附表"><a href="#表达式与运算符-附表" class="headerlink" title="表达式与运算符(附表)"></a>表达式与运算符(附表)</h1><p>表达式由一个或多个运算对象组成，对表达式求值将得到一个结果。</p><p><strong>字面值</strong>和<strong>变量</strong>是最简单的表达式，其结果就是它们的值。</p><p>把一个运算符和一个或多个运算对象组合起来可以生成较复杂的表达式。</p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>c++定义了一元运算符和二元运算符，作用于一个运算对象的运算符是一元比如说取地址符(&amp;)和解引用符(*)。</p><p>作用于两个对象的是二元比如乘法运算符(*)。</p><p>此外还有作用于三个运算对象的三元运算符。</p><p>函数调用也是一种特殊的运算符，它对运算对象的数量没有限制。</p><h4 id="组合运算符和运算对象"><a href="#组合运算符和运算对象" class="headerlink" title="组合运算符和运算对象"></a>组合运算符和运算对象</h4><p><strong>对于含有多个运算符和运算对象的复杂表达式来说，得先理解运算符的优先级、结合律以及求值顺序</strong>。</p><h4 id="运算对象转换"><a href="#运算对象转换" class="headerlink" title="运算对象转换"></a>运算对象转换</h4><p>在表达时求值中，运算对象常常由一种类型转换成另一种类型。例如：</p><p>整数和浮点数能互相转换，而通常小整数(bool、char、short等)会被提升成较大的整数类型，主要是int。更多了解——<strong><a href="../type-conversion.md">类型转换</a></strong></p><h4 id="重载运算符"><a href="#重载运算符" class="headerlink" title="重载运算符"></a>重载运算符</h4><p>当运算符作用于类类型的对象时用户可以自行定义其含义。称之为重载运算符，比如IO库的&gt;&gt;和&lt;&lt;运算符以及string、vector对象和迭代器使用的运算符都是。</p><p>重载运算符时，其包括运算对象的类型和返回值的类型，都是由该运算符定义的；<strong>但是运算对象的个数、运算符的优先级和结合律都是无法改变的</strong>。</p><h4 id="求值顺序"><a href="#求值顺序" class="headerlink" title="求值顺序"></a>求值顺序</h4><p>优先级规定了运算对象的组合方式，但是没有说明运算对象按照什么顺序求值。在大多数情况下不会明确求值顺序。对于如下表达式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = f1() * f2();</span><br></pre></td></tr></table></figure><p>我们不知道f1()和f2()哪个先调用。</p><p>对于那些没有指定执行顺序的运算符来说，如果表达式指向了同一个对象，将会引发错误并产生未定义的行为。例如&lt;&lt;:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; i &lt;&lt; “ ”&lt;&lt; ++i &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>我们不知道是先++i还是先输出i再++。编译器可能先求++i的值那么结果是1 1，也可能先输出i那么结果是0 1。因为此表达式的行为不可预知，因此编译器生成什么样的代码程序都是错误的。</p><p><strong>但是有四种运算符明确规定了运算对象的求值顺序。 逻辑与(&amp;&amp;)、逻辑或(||)、条件(?:)、逗号(,)。</strong></p><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p><img src="/2018/12/01/expression-operate/arithmetic.png" alt=""></p><p>按照运算符的优先级分组，一元运算符最高。上面所有运算符都满足左结合律。</p><p>取余：如果m和n是整数且n非0，则表达式(m/n)*n+m%n的求值结果与m相等:</p><p>m%(-n) 就是 m%n、 -m%n 就是-(m%n)。</p><h4 id="逻辑-和-关系运算符"><a href="#逻辑-和-关系运算符" class="headerlink" title="逻辑 和 关系运算符"></a>逻辑 和 关系运算符</h4><p><img src="/2018/12/01/expression-operate/logic.png" alt=""></p><p>逻辑与(&amp;&amp;)：当且仅当两个运算对象都为真适才为真；逻辑或(||)：只要有一个为真结果就为真。</p><p>逻辑与和逻辑或都是先算左边运算对象值，如果无法确定表达式结果才算右侧运算对象的值。—称为短路求值</p><ul><li>对于逻辑与(&amp;&amp;)运算符来说，当且仅当左侧运算对象为真时才对右侧对象求值</li><li>对于逻辑或(||)运算符来说，当且仅当左侧运算对象为假时才对右侧对象求值</li></ul><h4 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h4><p><strong>赋值运算符的左侧对象必须是一个可修改的左值(更多了解——<a href="">左值与右值</a>)。</strong></p><p>下面的赋值语句都是非法的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>,k=<span class="number">0</span>; <span class="comment">//初始化非赋值</span></span><br><span class="line"><span class="number">1024</span> = k;<span class="comment">//错误：字面值是右值</span></span><br><span class="line">(<span class="keyword">const</span>类型)ci = k;   <span class="comment">//错误：ci是常量不可修改的左值</span></span><br></pre></td></tr></table></figure><p>也允许用花括号括起来的初始值列表来赋值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">k=&#123;<span class="number">3.14</span>&#125;<span class="comment">//错误：窄化转换</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line">vi = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;<span class="comment">//vi现在有10个元素了</span></span><br></pre></td></tr></table></figure><p><strong>赋值运算满足右结合律:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line">a = b = <span class="number">0</span>;<span class="comment">//正确：都被赋值为0</span></span><br></pre></td></tr></table></figure><p>对于多重赋值运算，必须是可以由右边对象的类型转换得到：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ival, *pval;</span><br><span class="line">ival = pval = <span class="number">0</span>; <span class="comment">//错误：不能把指针的值赋给int</span></span><br></pre></td></tr></table></figure><h4 id="递增和递减运算符-–"><a href="#递增和递减运算符-–" class="headerlink" title="递增和递减运算符(++/–)"></a>递增和递减运算符(++/–)</h4><p>递增和递减运算符有两种形式：前置版本和后置版本。</p><p>这两种运算符必须作用于左值运算对象。</p><p>前置版本将运算对象加减1然后将<strong>改变后的运算对象</strong>作为求值结果(左值)，而后置版本则返回运算对象<strong>改变之前的值</strong>的副本(右值)。</p><p><strong><u>建议</u></strong>：使用前置版本可以避免了拷贝对象的额外开销。</p><p>例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span>&lt;&lt;*iter++&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>由于递增运算符高于解引用运算符，所以上述代码等于*(iter++)。先将iter的值加1但是返回的是iter原来的值。等同于：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span>&lt;&lt;*iter&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">++iter;</span><br></pre></td></tr></table></figure><p>如果使用的是++iter 那么是先将iter+1再参与运算。</p><p><strong>运算对象可按任意顺序求值：</strong></p><p>一般情况没影响。然而如果一条子表达式改变了某个运算对象的值，另一条子表达式又要用该值的话，那就要提防在复合表达式中错用这两个运算符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it = s.begin();it!=s.end()&amp;&amp;!<span class="built_in">isspace</span>(*it);++it)&#123;</span><br><span class="line">*it = <span class="built_in">toupper</span>(*it);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果将上述代码改为下面这条，则会有问题：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(it!=s.end()&amp;&amp;!<span class="built_in">isspace</span>(*it))&#123;</span><br><span class="line">*it = <span class="built_in">toupper</span>(*it++);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这将产生未定义的行为，问题在于：赋值运算左右两端的运算对象都用到了it，并且右侧运算对象还改变了it的值，编译器可能按照任意一种思路处理该表达式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*it = <span class="built_in">toupper</span>(*it);<span class="comment">//如果先求左侧的值</span></span><br><span class="line">*(it+<span class="number">1</span>) = <span class="built_in">toupper</span>(*it);<span class="comment">//如果先求右侧的值</span></span><br></pre></td></tr></table></figure><h4 id="成员访问运算符"><a href="#成员访问运算符" class="headerlink" title="成员访问运算符"></a><strong>成员访问运算符</strong></h4><p>点运算符(.) 和 箭头运算符(-&gt;)都可以用于访问成员，其中点运算符是获取类对象的一个成员；箭头运算符和点运算符有关  :  <strong>prt-&gt;mem</strong> 等价于 <strong>(*ptr).mem</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s1 = “a <span class="built_in">string</span>”, *p=&amp;s1;</span><br><span class="line"><span class="keyword">auto</span> n = s1.size();</span><br><span class="line">n = (*p).size();<span class="comment">//运行p所指对象的size成员</span></span><br><span class="line">n = p-&gt;size();<span class="comment">//等价于(*p).size()</span></span><br></pre></td></tr></table></figure><p>点运算符优先于解引用运算符，所以当*p.size()需要括号 (*p).size。</p><p>箭头运算符作用于一个指针类型的运算对象，结果是一个左值。</p><p>点运算符分情况：如果成员所属的对象是左值，那么结果是左值；反之，结果是右值。</p><h4 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符(?:)"></a>条件运算符(?:)</h4><p>条件运算符允许我们把简单的if-else逻辑嵌入到单个表达式中，条件运算符按照如下形式使用：</p><p>cond? expr1 : expr2;</p><p>cond是判断条件的表达式，而expr1和expr2是两个类型相同或可能转换为某个公共类型的表达式。当这两个表达式都是左值或者能转换成同一种左值类型时，运算的结果是左值；否则运算的结果是右值。</p><p>例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> finalgrade = (grade&lt;<span class="number">60</span>) ?<span class="string">"fail"</span> : <span class="string">"pass"</span>;</span><br></pre></td></tr></table></figure><p>条件运算符的优先级很低，比cout还低，所以最好加括号。</p><h4 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h4><p><img src="/2018/12/01/expression-operate/bit.png" alt=""></p><p><strong>移位运算符(&lt;&lt; 、&gt;&gt;)：</strong></p><p>一般来说，运算对象是小整型会被提升成大整型，左移运算符在右侧插入值为0的二进制位。右移行为依赖左侧运算对象的类型:如果对象是无符号类型，在左侧插入0；如果带符号，在左侧插入符号位的副本或值为0的二进制位。</p><p>移位超出的直接被舍弃。</p><p><strong>位与、位或、异或：</strong></p><p>位与运算符(&amp;): 两个对象都为1则结果为1，否则为0</p><p>位或运算符(|): 其中有一个对象为1则结果就为1，否则为0</p><p>异或运算符(^): 有且只有一个对象为1，这结果为1，否则为0</p><p>例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">quizl |= <span class="number">1U</span>L &lt;&lt; <span class="number">27</span>；<span class="comment">//第27个人的值赋为1</span></span><br><span class="line">quizl &amp;= `(<span class="number">1U</span>L&lt;&lt;<span class="number">27</span>);<span class="comment">//除了27别的值都不变</span></span><br><span class="line"><span class="keyword">bool</span> status = quizl&amp;(<span class="number">1U</span>L&lt;&lt;<span class="number">27</span>);  <span class="comment">//然后返回的值是0或者1，那么可以用bool接收</span></span><br></pre></td></tr></table></figure><h4 id="sizeof运算符"><a href="#sizeof运算符" class="headerlink" title="sizeof运算符"></a>sizeof运算符</h4><p>sizeof运算符返回一条表达式或一个类型名字所占的字节数。满足右结合律，返回size_t类型的常量表达式。运算符的运算对象有两种表达形式：</p><p>sizeof (type)</p><p>sizeof expr            </p><p>第二种形式中，返回表达式结果 类型的大小。sizeof并不实际计算其运算对象的值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Sales_data data, *p;</span><br><span class="line"><span class="keyword">sizeof</span>(Sales_data);<span class="comment">//Sales_data类型的对象所占空间的大小</span></span><br><span class="line"><span class="keyword">sizeof</span> data;<span class="comment">//同上</span></span><br><span class="line"><span class="keyword">sizeof</span> p;<span class="comment">//指针所占空间的大小</span></span><br><span class="line"><span class="keyword">sizeof</span> *p;<span class="comment">//p所指类型空间大小，也就是Sales_data</span></span><br></pre></td></tr></table></figure><p>sizeof运算符的结果部分的依赖于其作用的类型：</p><ul><li>对char或者类型为char的表达式执行sizeof运算，结果得1</li><li>对引用类型执行sizeof运算得到被引用对象所占空间的大小</li><li>对指针执行sizeof运算得到指针指向的对象所占空间的大小</li><li>对解引用指针执行sizeof运算得到指针指向的对象所占空间大小，指针不需有效</li><li>对数组执行sizeof运算得到整个数组所占空间的大小。</li><li>对string或vector执行sizeof运算只会得到固定类型的大小，不会计算元素所占空间大小。</li></ul><h4 id="逗号运算符"><a href="#逗号运算符" class="headerlink" title="逗号运算符"></a>逗号运算符</h4><p>含有两个运算对象，求值左侧表达式然后将结果丢掉，真正结果是右侧表达式，如果值是左值那结果也是左值。</p><h3 id="运算符优先级表"><a href="#运算符优先级表" class="headerlink" title="运算符优先级表"></a>运算符优先级表</h3><table><thead><tr><th>结合律</th><th>运算符</th><th>功能</th><th>用法</th></tr></thead><tbody><tr><td>左</td><td>::</td><td>全局作用域</td><td>::name</td></tr><tr><td>左</td><td>::</td><td>类作用域</td><td>class::name</td></tr><tr><td>左</td><td>::</td><td>命名空间作用域</td><td>namespace::name</td></tr><tr><td>左</td><td>.</td><td>成员选择</td><td>object.member</td></tr><tr><td>左</td><td>-&gt;</td><td>成员选择</td><td>point-&gt;member</td></tr><tr><td>左</td><td>[]</td><td>下标</td><td>expr[expr]</td></tr><tr><td>左</td><td>()</td><td>函数调用</td><td>name(expr_list)</td></tr><tr><td>左</td><td>()</td><td>类型构造</td><td>type(expr_list)</td></tr><tr><td>右</td><td>++</td><td>后置递增运算</td><td>lvalue++</td></tr><tr><td>右</td><td>–</td><td>后置递减运算</td><td>lvalue–</td></tr><tr><td>右</td><td>typeid</td><td>类型ID</td><td>typeid(type)</td></tr><tr><td>右</td><td>typeid</td><td>运行时类型ID</td><td>typeid(expr)</td></tr><tr><td>右</td><td>explicit cast</td><td>类型转换</td><td>cast_name&lt; type&gt;(expr)</td></tr><tr><td>右</td><td>++</td><td>前置递增运算</td><td>++lvalue</td></tr><tr><td>右</td><td>–</td><td>前置递减运算</td><td>–lvalue</td></tr><tr><td>右</td><td>~</td><td>位求反</td><td>~expr</td></tr><tr><td>右</td><td>!</td><td>逻辑非</td><td>!expr</td></tr><tr><td>右</td><td>-</td><td>一元负号</td><td>-expr</td></tr><tr><td>右</td><td>+</td><td>一元正号</td><td>+expr</td></tr><tr><td>右</td><td>*</td><td>解引用</td><td>*expr</td></tr><tr><td>右</td><td>&amp;</td><td>取地址</td><td>&amp;expr</td></tr><tr><td>右</td><td>()</td><td>类型转换</td><td>(type)expr</td></tr><tr><td>右</td><td>sizeof</td><td>对象大小</td><td>sizeof expr</td></tr><tr><td>右</td><td>sizeof</td><td>类型的大小</td><td>sizeof（type)</td></tr><tr><td>右</td><td>Sizeof…</td><td>参数包的大小</td><td>sizeof…(name)</td></tr><tr><td>右</td><td>new</td><td>创建对象</td><td>new type</td></tr><tr><td>右</td><td>new[]</td><td>创建数组</td><td>new type[size]</td></tr><tr><td>右</td><td>delete</td><td>释放对象</td><td>delete expr</td></tr><tr><td>右</td><td>delete[]</td><td>释放数组</td><td>delete[] expr</td></tr><tr><td>右</td><td>noexcept</td><td>能否抛出异常</td><td>noexcept (expr)</td></tr><tr><td>左</td><td>-&gt;*</td><td>指向成员选择的指针</td><td>ptr-&gt;*ptr_to_member</td></tr><tr><td>左</td><td>.*</td><td>指向成员选择的指针</td><td>obj.*ptr_to_member</td></tr><tr><td>左</td><td>*</td><td>乘法</td><td>expr*expr</td></tr><tr><td>左</td><td>/</td><td>除法</td><td>expr/expr</td></tr><tr><td>左</td><td>%</td><td>取模(取余)</td><td>expr%expr</td></tr><tr><td>左</td><td>+</td><td>加法</td><td>expr+expr</td></tr><tr><td>左</td><td>-</td><td>减法</td><td>expr-expr</td></tr><tr><td>左</td><td>&lt;&lt;</td><td>向左移位</td><td>expr&lt;&lt;expr</td></tr><tr><td>左</td><td>&gt;&gt;</td><td>向右移位</td><td>expr&gt;&gt;expr</td></tr><tr><td>左</td><td>&lt;</td><td>小于</td><td>expr&lt;expr</td></tr><tr><td>左</td><td>&lt;=</td><td>小于等于</td><td>expr&lt;=expr</td></tr><tr><td>左</td><td>&gt;</td><td>大于</td><td>expr&gt;expr</td></tr><tr><td>左</td><td>&gt;=</td><td>大于等于</td><td>expr&gt;=expr</td></tr><tr><td>左</td><td>==</td><td>相等</td><td>expr==expr</td></tr><tr><td>左</td><td>!=</td><td>不相等</td><td>expr!=expr</td></tr><tr><td>左</td><td>&amp;</td><td>位与</td><td>expr&amp;expr</td></tr><tr><td>左</td><td>^</td><td>位异或</td><td>expr^expr</td></tr><tr><td>左</td><td>丨</td><td>位或</td><td>expr丨expr</td></tr><tr><td>左</td><td>&amp;&amp;</td><td>逻辑与</td><td>expr&amp;&amp;expr</td></tr><tr><td>左</td><td>丨丨</td><td>逻辑或</td><td>expr丨丨expr</td></tr><tr><td>左</td><td>?:</td><td>条件</td><td>expr ? expr : expr</td></tr><tr><td>右</td><td>=</td><td>赋值</td><td>lvalue=expr</td></tr><tr><td>右</td><td>*=, /=, %=</td><td>复合赋值</td><td>lvalue += expr等</td></tr><tr><td>右</td><td>+=, -=</td><td></td><td></td></tr><tr><td>右</td><td>&lt;&lt;=, &gt;&gt;=</td><td></td><td></td></tr><tr><td>右</td><td>&amp;=,丨 =, ^=</td><td></td><td></td></tr><tr><td>右</td><td>throw</td><td>抛出异常</td><td>throw</td></tr><tr><td>右</td><td>,</td><td>逗号</td><td>expr , expr</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;表达式与运算符-附表&quot;&gt;&lt;a href=&quot;#表达式与运算符-附表&quot; class=&quot;headerlink&quot; title=&quot;表达式与运算符(附表)&quot;&gt;&lt;/a&gt;表达式与运算符(附表)&lt;/h1&gt;&lt;p&gt;表达式由一个或多个运算对象组成，对表达式求值将得到一个结果。&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="C++Primer笔记" scheme="http://yoursite.com/categories/C-Primer%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="表达式" scheme="http://yoursite.com/tags/%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
      <category term="运算符" scheme="http://yoursite.com/tags/%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    
  </entry>
  
  <entry>
    <title>数组</title>
    <link href="http://yoursite.com/2018/11/23/array/"/>
    <id>http://yoursite.com/2018/11/23/array/</id>
    <published>2018-11-23T13:15:12.000Z</published>
    <updated>2019-03-10T05:42:24.305Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>数组是一种类似于标准库类型vector的数据结构。</p><ul><li>与vector相似的是，数组也是存放类型相同的对象的容器，这些对象本身没有名字，需要通过位置访问。</li><li>与vector不同的是，数组的大小确定不变，不能随意向数组中增加元素。<ul><li>改变长度只能创建一个新数组，我们也不能像vector一样用size函数直接获取长度，char数组用strlen 而别的数组只能sizeof(array)/sizeof(array[0])</li></ul></li></ul><h3 id="定义和初始化数组"><a href="#定义和初始化数组" class="headerlink" title="定义和初始化数组"></a>定义和初始化数组</h3><h4 id="数组的定义："><a href="#数组的定义：" class="headerlink" title="数组的定义："></a>数组的定义：</h4><p>数组是一种复合类型。数组的声明形如a[d]，其中a是数组名字，d是数组的维度。</p><ol><li>维度就是个数，因此必须大于0。</li><li>数组中元素的个数属于数组类型的一部分，编译时是已知的。因此维度必须是一个常量表达式。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> cnt = <span class="number">42</span>;<span class="comment">//不是常量表达式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">unsigned</span> sz = <span class="number">42</span>; <span class="comment">//是常量表达式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>];<span class="comment">//含有10个整数的数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *parr[sz];<span class="comment">//含有42个整型指针的数组</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> bad[cnt];<span class="comment">//错误，cnt不是常量表达式</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> strs[get_size()];<span class="comment">//当get_size()是constexpr时正确</span></span><br></pre></td></tr></table></figure><p>和内置类型的变量一样，如果在函数内部定义了某种内置类型的数组，那么默认初始化会令数组含有未定义的值。</p><p>必须指定数组的类型(不允许用auto由初始化列表推断)。</p><p>和vector一样，数组的元素应为对象，因此不存在引用的数组。</p><h4 id="显式初始化数组元素："><a href="#显式初始化数组元素：" class="headerlink" title="显式初始化数组元素："></a>显式初始化数组元素：</h4><p><strong>可以对数组的元素进行列表初始化，此时忽略数组维度</strong>。</p><ul><li>如果在声明时没有指明维度，编译器会根据初始值的数量计算出来</li><li>如果定义了维度并且比列表大，那么剩下的元素会被初始化为默认值。</li><li>如果定义了维度并且比列表小，那么编译错误</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> sz = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ial[sz] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;; <span class="comment">//含有3个元素，012</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a2[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;; <span class="comment">//同上</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a3[<span class="number">5</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;; <span class="comment">//等价于a3[] = &#123;0,1,2,0,0&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> a4[<span class="number">3</span>] = &#123;“hi”, “bye”&#125;;<span class="comment">//等价于a4[] = &#123;“hi”, “bye”, “”&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a5[<span class="number">2</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;; <span class="comment">//错误，维度比初始值小</span></span><br></pre></td></tr></table></figure><h4 id="字符数组-的特殊性："><a href="#字符数组-的特殊性：" class="headerlink" title="字符数组 的特殊性："></a>字符数组 的特殊性：</h4><p>字符数组可以用<strong>字符串字面值</strong>进行初始化。当使用这种方式一定要注意字符串字面值<strong>结尾处还有一个空字符</strong>，要预留一个空间。如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a1[] = &#123;‘c’, ‘+’, ‘+’&#125;;<span class="comment">//列表初始化，没有空字符</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> a2[]=&#123;‘c’, ‘+’, ‘+’, ‘\<span class="number">0</span>’&#125;;<span class="comment">//显式的空字符</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> a3[] = “c++”;<span class="comment">//自动添加表示字符串结束的空字符</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> a4[<span class="number">6</span>] = “Daniel”;<span class="comment">//错误，没有空间放空字符</span></span><br></pre></td></tr></table></figure><h4 id="数组不允许拷贝和赋值："><a href="#数组不允许拷贝和赋值：" class="headerlink" title="数组不允许拷贝和赋值："></a>数组不允许拷贝和赋值：</h4><p>不能将数组的内容拷贝给其他数组作为其初始值，也不能用数组为其他数组赋值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a1[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a2[] = a1; <span class="comment">//错误：不允许使用一个数组初始化另一个数组</span></span><br><span class="line"></span><br><span class="line">a2 = a ;<span class="comment">//错误，不能把一个数组直接赋值给另一个数组</span></span><br></pre></td></tr></table></figure><p>(某些<strong>编译器扩展</strong>可以支持数组赋值，不过最好避免)</p><h4 id="复杂的数组声明-数组-指针、引用等-："><a href="#复杂的数组声明-数组-指针、引用等-：" class="headerlink" title="复杂的数组声明(数组+指针、引用等)："></a>复杂的数组声明(数组+指针、引用等)：</h4><p>数组可以存放对象，就可以定义指针对象。而数组本身是一个对象，那么可以有引用和指针，如下(可从内向外再从右向左阅读)：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *ptrs[<span class="number">10</span>];<span class="comment">//ptrs是有10个整型指针的数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> &amp;refs[<span class="number">10</span>]; <span class="comment">//错误，数组不能放引用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> (*Parray)[<span class="number">10</span>] = &amp;arr<span class="comment">//Parray是一个指针，指向一个整型数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> (&amp;arrRef)[<span class="number">10</span>] = arr;<span class="comment">//arrRef是一个引用，引用一个整型数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *(&amp;arrRef)[<span class="number">10</span>] = ptrs;<span class="comment">//arrRef 是一个引用，指向一个含有10个int类型指针的数组</span></span><br></pre></td></tr></table></figure><h3 id="访问数组元素"><a href="#访问数组元素" class="headerlink" title="访问数组元素"></a>访问数组元素</h3><p>数组的访问跟vector基本类似。也可以用范围for语句或下标运算符来访问。</p><p>在使用下标的时候通常将其定义为<strong>size_t</strong>类型。</p><p>size_t 是一种机器相关的无符号类型。它的定义在<strong>cstddef</strong>头文件中。</p><h3 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a>指针和数组</h3><p>通常情况下，使用取地址符来获取指向某个对象的指针。数组的元素也是对象，因此对数组的元素使用取地址符就能得到指向该元素的指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> nums[] = &#123;“one”, “two”, “three”&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> *p = &amp;nums[<span class="number">0</span>]; <span class="comment">//p指向nums的第一个元素</span></span><br></pre></td></tr></table></figure><p><strong>然而数组有个特性：在很多用到数组名字的地方，编译器会自动的将其转换为一个指向数组首元素的指针。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> *p2 = nums;<span class="comment">//等价于p2 = &amp;nums[0]</span></span><br></pre></td></tr></table></figure><h4 id="对数组使用auto和decltype的不同点："><a href="#对数组使用auto和decltype的不同点：" class="headerlink" title="对数组使用auto和decltype的不同点："></a>对数组使用auto和decltype的不同点：</h4><p>由上可知，在一些情况下数组的操作实际上是指针的操作：</p><ol><li>当使用一个数组作为一个auto变量的初始值时，推断出的类型是指针而非数组</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ia2</span><span class="params">(ia)</span></span>;<span class="comment">//ia2是一个整型指针，指向ia的第一个元素，同 ia2(&amp;ia[0])</span></span><br></pre></td></tr></table></figure><ol start="2"><li>然而当使用decltype(ia)返回的是一个数组。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(ia) ia3 = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">ia3[<span class="number">4</span>] = i;<span class="comment">//给ia3的第三个元素赋值</span></span><br></pre></td></tr></table></figure><h4 id="指针也是迭代器："><a href="#指针也是迭代器：" class="headerlink" title="指针也是迭代器："></a>指针也是迭代器：</h4><p>迭代器可用的运算 指针都能用。也可以使用指针遍历数组。</p><p>同时c++给了两个标准库函数取尾后指针，<strong>begin 和 end</strong>，定义在iterator头文件中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *pbeg = begin(arr);<span class="comment">//指向arr的首元素</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *pend = end(arr);<span class="comment">//指向尾后元素</span></span><br></pre></td></tr></table></figure><h4 id="解引用与指针运算交互："><a href="#解引用与指针运算交互：" class="headerlink" title="解引用与指针运算交互："></a>解引用与指针运算交互：</h4><p>迭代器有的运算操作指针都有，两个指针相减的结果类型是ptrdiff_t， 与size_t一样。</p><p>如果两个指针分别指向不相关的对象，则不能比较它们。</p><p>空指针也可以相减，值为0。</p><p><strong>下标和指针：</strong></p><p>当对数组使用下标运算符时，编译器会自动转换成指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[] = &#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> last = *(ia + <span class="number">4</span>);<span class="comment">//正确：等同于 ia[4]</span></span><br></pre></td></tr></table></figure><p>从上可知，对数组下标运算其实是对指向数组元素的指针执行下标运算：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = &amp;ia[<span class="number">2</span>];<span class="comment">//p指向索引为2的元素</span></span><br><span class="line"><span class="keyword">int</span> j = p[<span class="number">1</span>]; <span class="comment">//p[1]等价于*(p + 1),就是ia[3]表示的那个元素</span></span><br><span class="line"><span class="keyword">int</span> k = p[<span class="number">-2</span>]; <span class="comment">//p[-2]等价于*(p - 2),就是ia[0]表示的那个元素</span></span><br></pre></td></tr></table></figure><p>数组的下标运算与 标准库类型限定使用的下标运算有所不同。<strong>标准库类型的下标必须是无符号类型，而内置的下标则无此要求。</strong></p><h3 id="C风格字符串"><a href="#C风格字符串" class="headerlink" title="C风格字符串"></a>C风格字符串</h3><p>尽管c++支持c风格字符串，但还是不要使用它们。因为用起来不太方便，而且极易引发程序漏洞。</p><p><strong>字符串字面值</strong>是一种通用结构的实例，即是由c继承而来的c风格字符串。</p><p>c通常把字符串存放在字符数组中并以空字符结束(‘\0’)。一般用指针来操作这些字符串。</p><h4 id="C标准库string函数"><a href="#C标准库string函数" class="headerlink" title="C标准库string函数"></a>C标准库string函数</h4><p>下表函数定义在cstring头文件中。</p><table><thead><tr><th>strlen(p)</th><th style="text-align:left">返回p的长度，空字符不计算在内</th></tr></thead><tbody><tr><td>strcmp(p1, p2)</td><td style="text-align:left">比较p1和p2的相等性。如果p1==p2，返回0；如果p1&gt;p2,返回一个正值；返回0；如果p1&lt;p2,返回一个负值</td></tr><tr><td>strcat(p1, p2)</td><td style="text-align:left">和炮</td></tr><tr><td>strcpy(p1, p2)</td><td style="text-align:left">将p2拷贝给p1， 返回p1</td></tr></tbody></table><p><strong>上表所列的函数不负责验证字符串参数。</strong></p><p>传入此类函数的指针必须指向以空字符作为结束的数组：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ca[] = &#123;‘c’, ‘+’, ‘+’&#125;;<span class="comment">//不以空字符结束</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; <span class="built_in">strlen</span>(ca) &lt;&lt;<span class="built_in">endl</span>;<span class="comment">//严重错误：ca没有以空字符结束</span></span><br></pre></td></tr></table></figure><p>上面代码不是以空字符结束，它可能沿着ca在内存中的位置不断向前直到遇到空字符。</p><h4 id="比较字符串："><a href="#比较字符串：" class="headerlink" title="比较字符串："></a>比较字符串：</h4><p>比较两个c风格字符串的方法与标准库string对象的方法大相径庭。</p><p>标准库string对象的比较用的是普通关系运算符和相等性运算符，如 &lt;、==；</p><p>而c风格字符串，实际比较的是两个指针而不是字符串本身：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> ca1[] = “A <span class="built_in">string</span> example”;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> ca2[] = “A different <span class="built_in">string</span>”;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( ca1 &lt; ca2)&#123;&#125;;<span class="comment">//未定义的：试图比较两个无关地址，相当于比较const char*</span></span><br></pre></td></tr></table></figure><p>所以上述ca1和ca2相比其实是两个const char*的值，这两个指针指向的不是一个对象，因此得到未定义的结果。</p><p>如果想要比较两个c风格字符串则需要调用strcmp函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(ca1, ca2) &lt; <span class="number">0</span>) <span class="comment">//相等返回0，前面大返回正值，否则负值。</span></span><br></pre></td></tr></table></figure><h4 id="c风格字符串的连接拷贝："><a href="#c风格字符串的连接拷贝：" class="headerlink" title="c风格字符串的连接拷贝："></a>c风格字符串的连接拷贝：</h4><p>使用strcpy 和 ctrcat函数来进行连接、拷贝，如果使用则需要提供一个用于存放结果的数组，必须足够大容纳下结果字符串以及<strong>末尾的空字符</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strcpy</span>(largeStr, ca1);<span class="comment">//cal拷贝给largeStr</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">strcat</span>(largeStr, “ ”);</span><br><span class="line"></span><br><span class="line"><span class="built_in">strcat</span>(largeStr, ca2);<span class="comment">//ca2连接到largeStr后面</span></span><br></pre></td></tr></table></figure><p>ps：在vs中使用c风格字符串的函数时，会报错。因为c库的函数内部进行参数检验，所以vs提出警告要求使用vs改写的函数。报错：</p><table><thead><tr><th>错误</th><th>描述</th></tr></thead><tbody><tr><td>C4996</td><td>‘strcpy’: This function or variable may be unsafe. Consider using strcpy_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.</td></tr></tbody></table><p>需要改写成：</p><table><thead><tr><th>老接口</th><th>新接口</th></tr></thead><tbody><tr><td>mkdir</td><td>_mkdir</td></tr><tr><td>fopen</td><td>fopen_s</td></tr><tr><td>strcmp</td><td>strcmp_s</td></tr><tr><td>strcpy</td><td>strcpy_s</td></tr><tr><td>strcat</td><td>strcat_s</td></tr></tbody></table><h3 id="与旧代码的接口"><a href="#与旧代码的接口" class="headerlink" title="与旧代码的接口"></a>与旧代码的接口</h3><p>很多c++程序在标准库出现之前就已经写成了，因此c++专门提供了一组功能来衔接c++程序与数组/c风格字符串的代码。</p><h4 id="混用string对象和C风格字符串："><a href="#混用string对象和C风格字符串：" class="headerlink" title="混用string对象和C风格字符串："></a>混用string对象和C风格字符串：</h4><p><strong>任何出现字符串字面值的地方都可以用空字符结束的字符数组来替代：</strong></p><ol><li>允许使用以空字符结束的字符数组来初始化string对象或赋值。</li><li>在string对象的加法运算中允许使用空字符结束的字符数组作为其中一个运算对象(不能两个都是)；</li></ol><p>反之不行，不能用string对象来代替c风格字符串。为了完成这个功能，string专门提供了一个函数<strong>c_str</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *str = s; <span class="comment">//错误，不能用string对象初始化char*</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *str = s.c_str(); <span class="comment">//正确</span></span><br></pre></td></tr></table></figure><p>c_str()函数返回值是一个以空字符结束的字符数组的指针。指针类型是const char*。但如果后续操作改变了s的值那么之前返回的数组失去作用。</p><p>所以：如果执行完c_str()函数后想一直使用，那么最好拷贝一份。</p><h4 id="使用数组初始化vector对象："><a href="#使用数组初始化vector对象：" class="headerlink" title="使用数组初始化vector对象："></a>使用数组初始化vector对象：</h4><p>用数组初始化vector对象只需指明拷贝区域的<strong>首元素地址和尾后地址</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> int_arr[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec(begin(arr), end(arr));</span><br></pre></td></tr></table></figure><p>同样可以只拷贝数组的一部分：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; subVec(arr + <span class="number">1</span>, arr + <span class="number">4</span>);<span class="comment">//拷贝arr[1],arr[2],arr[3]</span></span><br></pre></td></tr></table></figure><h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><p>多维数组就是数组的数组。</p><h4 id="多维数组的初始化："><a href="#多维数组的初始化：" class="headerlink" title="多维数组的初始化："></a>多维数组的初始化：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="comment">//3个元素，每个元素都是大小为4 的数组</span></span><br><span class="line">&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;,</span><br><span class="line">&#123;<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中内嵌花括号不是必需的，例如下面：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>&#125;;<span class="comment">//功能同上</span></span><br></pre></td></tr></table></figure><p>类似一维数组，初始化时并非所有元素都包含在初始化列表内：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//显式的初始化每行的首元素</span></span><br><span class="line"><span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">0</span>&#125;,&#123;<span class="number">4</span>&#125;,&#123;<span class="number">8</span>&#125;&#125;;</span><br><span class="line"><span class="comment">//显式初始化第一行</span></span><br><span class="line"><span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure><h4 id="多维数组下标引用："><a href="#多维数组下标引用：" class="headerlink" title="多维数组下标引用："></a>多维数组下标引用：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (&amp;row)[<span class="number">4</span>] = ia[<span class="number">1</span>]; <span class="comment">//row是含有4个元素的数组的引用，引用ia数组的第二个四元数组上</span></span><br></pre></td></tr></table></figure><h4 id="使用范围for处理多维数组："><a href="#使用范围for处理多维数组：" class="headerlink" title="使用范围for处理多维数组："></a>使用范围for处理多维数组：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">使用范围<span class="keyword">for</span>处理多维数组：</span><br><span class="line"><span class="keyword">size_t</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;row : ia)&#123;<span class="comment">//对于外层数组的每一个元素，row是int[4]类型的引用</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;col : row)&#123;<span class="comment">//对于内层数组的每一个元素</span></span><br><span class="line">col = cnt;</span><br><span class="line">++cnt;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上<strong>row必需声明为引用类型</strong>，这是因为如果不用引用类型那么auto会变为指向数组内首元素的指针，那么遍历指针就不合法了。所以除了最内层的循环，其他的循环变量都为引用类型。</p><h4 id="指针和多维数组："><a href="#指针和多维数组：" class="headerlink" title="指针和多维数组："></a>指针和多维数组：</h4><p>定义指向多维数组的指针，就是指向指针的指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> (*p)[<span class="number">4</span>] = ia;<span class="comment">//指向ia第一个四元素数组的指针</span></span><br><span class="line">p = &amp;ia[<span class="number">2</span>];<span class="comment">//指向ia的第三个元素</span></span><br></pre></td></tr></table></figure><p>通过使用auto或者decltype可以避免在数组面前加一个指针类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> p = begin(ia);p!=end(ia);++p)&#123; <span class="comment">//p指向ia的内层数组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> q = begin(*p);q!=end(*p);++q)&#123;<span class="comment">//q指向*p的数组的首元素</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;*q&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类型别名简化多维数组的指针："><a href="#类型别名简化多维数组的指针：" class="headerlink" title="类型别名简化多维数组的指针："></a>类型别名简化多维数组的指针：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> int_array = <span class="keyword">int</span>[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> int_array[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(int_array p = begin(ia);p!=end(ia);++p)&#123; <span class="comment">//p指向ia的内层数组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> q = begin(*p);q!=end(*p);++q)&#123;<span class="comment">//q指向*p的数组的首元素</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;*q&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数组&quot;&gt;&lt;a href=&quot;#数组&quot; class=&quot;headerlink&quot; title=&quot;数组&quot;&gt;&lt;/a&gt;数组&lt;/h1&gt;&lt;p&gt;数组是一种类似于标准库类型vector的数据结构。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;与vector相似的是，数组也是存放类型相同的对象的容器，这些
      
    
    </summary>
    
      <category term="C++Primer笔记" scheme="http://yoursite.com/categories/C-Primer%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="array" scheme="http://yoursite.com/tags/array/"/>
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>迭代器</title>
    <link href="http://yoursite.com/2018/11/23/iterator/"/>
    <id>http://yoursite.com/2018/11/23/iterator/</id>
    <published>2018-11-23T13:14:57.000Z</published>
    <updated>2019-03-10T05:41:29.354Z</updated>
    
    <content type="html"><![CDATA[<h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><h3 id="迭代器的介绍"><a href="#迭代器的介绍" class="headerlink" title="迭代器的介绍"></a>迭代器的介绍</h3><p>迭代器是一种比下标运算符访问元素更通用的机制。</p><p>所有标准库容器都可以使用<strong>迭代器</strong>，但是只有少数几种才同时支持<strong>下标运算符</strong>。</p><h4 id="迭代器类型："><a href="#迭代器类型：" class="headerlink" title="迭代器类型："></a>迭代器类型：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it1;<span class="comment">//能读写vector&lt;int&gt;的元素</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span>::iterator it2;<span class="comment">//能读写string对象中的元素</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator it3;<span class="comment">//只能读vector&lt;int&gt;的元素</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span>::const_iterator it4;<span class="comment">//只能读string对象中的元素</span></span><br></pre></td></tr></table></figure><p>跟常量指针差不多，如果vector对象或string对象不是常量，那么既可以用iterator也可以用const_iterator。</p><h4 id="迭代器成员begin和end："><a href="#迭代器成员begin和end：" class="headerlink" title="迭代器成员begin和end："></a>迭代器成员begin和end：</h4><p>有迭代器的类型同时拥有返回迭代器的成员。比如这些类型都拥有名为begin和end的成员，其中begin成员负责返回指向第一个元素的迭代器。如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> a = v.begin(), b =v.end();</span><br></pre></td></tr></table></figure><p>迭代器b被称作尾后迭代器。它指向的是尾元素的下一个位置，本不存在的位置。</p><p><strong>如果容器为空，那么begin和end返回的是同一个尾后迭代器。</strong></p><p>如果容器对象的类型是常量，那么begin 和end返回的类型是const_iterator。如果不是则返回iterator：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cv;</span><br><span class="line"><span class="keyword">auto</span> it1 = v.begin();<span class="comment">//it1的类型是vector&lt;int&gt;::iterator</span></span><br><span class="line"><span class="keyword">auto</span> it2 = cv.begin();<span class="comment">//it2的类型是vector&lt;int&gt;::const_iterator</span></span><br></pre></td></tr></table></figure><p>如果对象只需读操作，那么我们可以使用两个新函数:</p><p><strong>cbegin</strong>和<strong>cend</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> it3 = v.cbegin(); <span class="comment">//it3的类型是const_iterator</span></span><br></pre></td></tr></table></figure><h3 id="迭代器运算符-操作-："><a href="#迭代器运算符-操作-：" class="headerlink" title="迭代器运算符(操作)："></a>迭代器运算符(操作)：</h3><table><thead><tr><th>*iter</th><th>返回迭代器iter所指元素的引用</th></tr></thead><tbody><tr><td>iter-&gt;mem</td><td>解引用iter并获取该元素的名为mem的成员，等价于(*iter).mem</td></tr><tr><td>++iter</td><td>令iter指示容器中的下一个元素</td></tr><tr><td>–iter</td><td>令iter指示容器中的上一个元素</td></tr><tr><td>iter1 == iter2、iter1 != iter2</td><td>判断两个迭代器是否相等(不相等)，如果两个迭代器指示的是同一个元素或者它们是同一个容器的尾后迭代器，则相等。</td></tr></tbody></table><h4 id="解引用和成员访问："><a href="#解引用和成员访问：" class="headerlink" title="解引用和成员访问："></a>解引用和成员访问：</h4><p>和指针一样，迭代器也能被解引用来获取所指示的元素，当然前提是迭代器合法并且确实指示某一个元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">"some string"</span>)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (s.begin() != s.end())&#123;<span class="comment">//确保s非空</span></span><br><span class="line">    <span class="keyword">auto</span> it = s.begin();<span class="comment">//it指示s的第一个字符</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; *it &lt;&lt;<span class="built_in">endl</span>;<span class="comment">//解引用获取元素输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解引用可以获得迭代器所指的对象，如果对象的类型刚好是类，就能进一步<strong>访问它的成员</strong>。例如vector<string>想要检查元素是否为空就可以用：</string></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(*it).empty();<span class="comment">//此处的括号必须要加</span></span><br></pre></td></tr></table></figure><p>然后为了简化上述操作，c++定义了 箭头运算符(-&gt;)。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">it-&gt;empty();<span class="comment">//和上面意思相同</span></span><br></pre></td></tr></table></figure><h4 id="迭代器的移动："><a href="#迭代器的移动：" class="headerlink" title="迭代器的移动："></a>迭代器的移动：</h4><p>将迭代器从一个元素移到另外一个元素：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s= “some thing”;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it = s.begin();it!=s.end &amp;&amp; !<span class="built_in">isspace</span>(*it);++it)&#123;</span><br><span class="line">*it = <span class="built_in">toupper</span>(*it); <span class="comment">//将当前字符大写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在for里不用&lt;而用!= 的原因是因为迭代器使然</strong>，之前说只有string和vector等一些标准库类型有下标运算符，并非全部如此。与之类似，所有标准库容器的迭代器都定义了==和!=，但是大多数没有&lt;运算符。</p><h4 id="某些对vector对象操作会使迭代器失效："><a href="#某些对vector对象操作会使迭代器失效：" class="headerlink" title="某些对vector对象操作会使迭代器失效："></a>某些对vector对象操作会使迭代器失效：</h4><p>vector是动态增长，但也有副作用。已知的一个限制是不能在范围for循环中向vector对象添加元素。另外一个是任何一种可能改变vector容量的操作，比如push_back。都会使迭代器失效。9.3.6</p><h4 id="迭代器运算："><a href="#迭代器运算：" class="headerlink" title="迭代器运算："></a><strong>迭代器运算：</strong></h4><p>迭代器的算术运算(必须是两个迭代器指向同一个容器中的元素)：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">iter += n;<span class="comment">//向前移动了n个元素</span></span><br><span class="line"></span><br><span class="line">iter -= n;<span class="comment">//向后移动了n个元素</span></span><br><span class="line"></span><br><span class="line">iter1 - iter2; <span class="comment">//两个迭代器相减就是他们的距离</span></span><br><span class="line"></span><br><span class="line">&lt;、&gt;、&lt;=、&gt;=;<span class="comment">//两个迭代器的前后位置比较</span></span><br></pre></td></tr></table></figure><p>只要两个迭代器指向的是同一个容器或者尾元素，就能相减。距离是指右侧迭代器向前移动多少位就能追上左侧迭代器，其类型名是<strong>difference_type</strong>的带符号整型数。</p><p>ps：还需拓展</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;迭代器&quot;&gt;&lt;a href=&quot;#迭代器&quot; class=&quot;headerlink&quot; title=&quot;迭代器&quot;&gt;&lt;/a&gt;迭代器&lt;/h1&gt;&lt;h3 id=&quot;迭代器的介绍&quot;&gt;&lt;a href=&quot;#迭代器的介绍&quot; class=&quot;headerlink&quot; title=&quot;迭代器的介绍&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="C++Primer笔记" scheme="http://yoursite.com/categories/C-Primer%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="iterator" scheme="http://yoursite.com/tags/iterator/"/>
    
      <category term="迭代器" scheme="http://yoursite.com/tags/%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>MySQL中索引的类型</title>
    <link href="http://yoursite.com/2018/11/10/zhuan-java8/"/>
    <id>http://yoursite.com/2018/11/10/zhuan-java8/</id>
    <published>2018-11-10T05:18:35.000Z</published>
    <updated>2019-03-10T05:20:32.009Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL中索引的类型"><a href="#MySQL中索引的类型" class="headerlink" title="MySQL中索引的类型"></a>MySQL中索引的类型</h1><p>索引(在MySQL中也被叫做”键(key)”)是存储引擎用于快速找到记录的一种数据结构。这是索引的基本功能。</p><h3 id="索引的类型"><a href="#索引的类型" class="headerlink" title="索引的类型"></a>索引的类型</h3><p>索引很很多种类型，可以为不同的场景提供更好的性能。在MySQL中，索引是在存储引擎层实现而不是服务器层。所以不同的存储引擎索引的工作方式不同，也不是所有存储引擎都支持所有类型的索引。即使多个存储引擎支持同一种类型的索引，其底层的实现也可能不同。</p><h4 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B-Tree索引"></a>B-Tree索引</h4><p>B-Tree索引使用B-Tree数据结构来存储数据。大多数MySQL引擎都支持这种索引，Archive引擎是例外。</p><p>使用术语”B-Tree”，是因为MySQL在CREATE TABLE和其他语句中也使用该关键字。不过，底层不同的存储引擎也可能使用不同的存储结构。例如，NDB集群存储引擎内部使用了T-Tree结构存储这种索引，即使其名字是BTree;InnoDB则使用的是B+Tree。</p><p>B-Tree通常意味着所有的值都是按照顺序存储的，并且每个叶子节点到根的距离都是相等的。</p><p>B-Tree索引能够加快访问数据的速度，因为存储引擎不再需要进行全表扫描来获取数据，而是从索引的根节点开始搜索，根节点的槽中存放了指向子节点的指针，存储引擎根据这些指针向下层查找。通过比较节点页的值和要查找的值可以找到合适的指针进入下一层子节点。这些指针实际上定义了子节点页中值的上限和下限。最终存储引擎要么找到对应的值，要么该记录不存在。</p><p>叶子节点比较特别，因为它们的指针指向的是被索引的数据，而不是其他节点页。</p><p>B-Tree对索引列是顺序组织存储的，索引很适合查找范围数据。例如”找出A到C开头的名字”<br><strong>索引的维护</strong><br>B+树为了维护索引的有序性，在插入新值的时候需要做必要的维护。如果插入新的行，需要挪动后面的数据，空出位置，而更糟糕的情况是，如果插入所在数据页已经满了，根据B+树算法，这时候需要申请一个新的数据页，然后挪动部分数据过去。这个过程称为页分裂。这种情况下，性能自然会受到影响，除了性能外，页分裂操作还影响数据页的利用率。原本放在一个页的数据，现在分到两个页中，整体空间利用率降低大约50%。在相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并。合并的过程，可以认为是分裂过程的逆过程。<br><strong>可以使用B-Tree索引的查询类型</strong></p><ol><li><strong>全值匹配</strong></li></ol><p>全值匹配是指和索引中的所有列进行匹配，例如前面提到的索引可查找名字Cuba Allen、出生于1960-01-01的人。</p><ol><li><strong>匹配最左前缀</strong></li></ol><p>可以只匹配某一列的值的开头部分。例如前面提到的索引可以用于查找所有以J开头的姓氏的人。这里也只使用了索引的第一列。</p><ol><li><strong>匹配范围值</strong></li></ol><p>例如前面提到的索引可以用于查找姓氏在Allen和Barrymore之间的人。这里也只使用了索引的第一列。</p><ol><li><strong>精确匹配某一列并范围匹配另外一列</strong></li></ol><p>例如前面提到的索引可以用于查找所有姓为Allen，并且名字是字母K开头的人。这里第一列姓氏last_name全匹配，第二列范围匹配。</p><p><strong>B-Tree索引的使用限制</strong></p><ol><li><strong>如果不是按照索引的最左列开始查找，则无法使用索引</strong>。例如前面提到的索引无法查找名字为yuanzhi的人，也无法查找某个特定生日的人，也无法查找姓氏以某个字母结尾的人。因为这些都不是最左数据列。</li><li><strong>不能跳过索引中的列</strong>。例如前面提到的索引无法查找last_name为Smith并且某个日期出生的人。如果不指定first_name这一列，则MySQL只能使用索引的第一列。</li><li><strong>如果查询中有个某个列的范围查询，则其右边所有列都无法使用索引优化查找</strong>。例如查询WHERE last_name=’Smith’ AND first_name LIKE ‘J%’ AND dob = ‘1976-12-23’,这里只能使用索引的前两列，因为LIKE是一个范围条件。</li></ol><p>索引列的顺序很重要，这些限制都和索引列的顺序有关。在优化性能的时候，可能需要使用相同的列但顺序不同的索引来满足不同类型的查询需求。</p><h3 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h3><p>哈希索引(hash index)基于哈希表实现，只有精确匹配索引所有列的查询才有效。对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码(hash code)，哈希码是一个较小的值，并且不同键值的行计算出来的哈希码也不一样。哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。</p><p>在MySQL中，只有Memory引擎显式支持哈希索引。这也是Memory引擎表的默认索引类型，Memory引擎同时也支持B-Tree索引。值得一提的是，Memory引擎是支持非唯一哈希索引的，如果多个列的哈希值相同，索引会以链表的方式存放多个记录指针到同一个哈希条目中。</p><p>例如<code>SELECT last_name FROM test WHERE first_name = &#39;Peter&#39;;</code>MySQL先计算‘Peter’的哈希值，并使用该值寻找对应的记录指针。然后根据哈希值，找到指向数据行的指针，最后一步是判断数据行的值是否为‘Peter’，以确保就是要查找的行。</p><p>因为哈希索引只需要存储哈希值，索引结构十分紧凑，这也让哈希索引查找的速度非常快。然而，哈希索引也有他的限制:</p><ol><li>哈希索引只包含哈希值和行指针，不存储字段值，所以不能使用索引中的值来避免读取行。</li><li>哈希索引数据不是按照索引值顺序存储的，所以无法用于排序。</li><li>哈希索引也不支持索引列的匹配查找。因为哈希索引使用索引列的全部内容来计算哈希值。</li><li>当出现哈希冲突的时候(不同的索引列值却有相同的哈希值)，存储引擎必须遍历链表中所有的行指针，逐行进行比较，直到找到所有符合条件的行。哈希冲突很多的话，索引维护操作的代价也会很高。例如从表中删除一行时，存储引擎需要遍历对应哈希值的链表的每一行，找到并删除对应行 的引用，冲突越多，代价越大。</li></ol><p>InnoDB引擎有一个特殊的功能叫做“自适应哈希索引”。当InnoDB注意到某些索引值被使用得非常频繁时，它会在内存中基于B-Tree索引之上再创建一个哈希索引，这样让B-Tree索引也具有哈希索引的一些优点，比如快速哈希查找。这是一个完全自动的，内部行为，用户无法控制或者配置，不过有必要，完全可以关闭该功能。</p><p>创建自定义哈希索引。让不支持哈希索引的存储引擎可以模拟和InnoDB一样创建哈希索引。</p><h4 id="空间数据索引-R-Tree"><a href="#空间数据索引-R-Tree" class="headerlink" title="空间数据索引(R-Tree)"></a>空间数据索引(R-Tree)</h4><p>MyISAM表支持空间索引，可以用作地理数据存储。和B-Tree索引不同，空间数据索引无须前缀查询。可以从所有纬度来索引数据。查询时，可以有效地使用任意纬度来组合查询。必须使用MySQL的GIS相关函数如MBRCONTAINS()等来维护数据。MySQL的GIS支持并不完善，所以大部分人都不会使用这个特性。</p><h4 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h4><p>全文索引是一种特殊类型的索引，它查找的是文本中的关键词，而不是直接比较索引中的值。全文搜索和其他几类索引的匹配方式完全不一样。全文索引更类似搜索引擎做的事情，而不是简单的WHERE条件匹配。</p><p>在相同的列上同时创建全文索引和基于值的B-Tree索引不会有冲突，全文索引适用于MATCH AGAINST操作，而不是普通的WHERE条件操作。</p><h3 id="索引的优点"><a href="#索引的优点" class="headerlink" title="索引的优点"></a>索引的优点</h3><p>最常见的B-Tree索引，按照顺序存储数据，所以MySQL可以用来做ORDER BY 和GROUP BY操作。因为数据是有序的，所以B-Tree会将相关的列值存储在一起。最后，因为所以中存储了实际的列值，所以有些查询可以只使用索引就能够完成全部查询。总结三个优点:</p><ol><li>索引大大减少了服务器需要扫描的数据量。</li><li>索引可以帮助服务器避免排序和临时表。</li><li>索引可以将随机I/O变为顺序I/O。</li></ol><h3 id="主键索引与非主键索引的区别"><a href="#主键索引与非主键索引的区别" class="headerlink" title="主键索引与非主键索引的区别"></a>主键索引与非主键索引的区别</h3><p>主键索引的叶子节点存放的是整行数据，在InnoDB里，主键索引也被称为聚簇索引。<br>非主键索引的叶子节点存放的是主键的值。在InnoDB里，非主键索引也被称为二级索引。</p><ul><li>如果语句是SELECT * FROM T WHRER 主键 = 1,即主键查询方式，则只需要搜索主键这棵B+树；</li><li>如果语句是SELECT * FROM T WHRER 非主键 = 1，则需要先搜索这个非主键索引树，得到主键Id，再到主键索引树搜索一次。这个过程称为回表。</li></ul><p>也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，应该尽量使用主键查询。并且主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。</p><p>聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。具体的细节依赖于实现方式，InnoDB的聚簇索引实际上在同一个结构中保存了B-Tree索引和数据行。当表有聚簇索引时，它的数据行实际上是存放在索引的叶子页中的。术语”聚簇”表示数据行和相邻的键值紧凑地存储在一起(实际上也不都成立)。因为无法同时吧数据行存放在两个不同的地方，所以一个表只能由一个聚簇索引。因为存储引擎负责实现索引，因此不是所有的存储引擎都支持聚簇索引。</p><p>聚簇索引的优点:</p><ul><li>可以把相关数据保存在一起。例如在实现电子邮箱时，可以根据用户ID来聚集数据，这样只需要从磁盘中读取少数的数据页就能获取某个用户的全部邮件。如果没有使用聚簇索引，则没封邮件都可能导致一次磁盘I/O。</li><li>数据访问更快。聚簇索引将索引和数据保存在同一个B-Tree中，因此从聚簇索引中获取数据通常比在非聚簇索引中查找要快。</li><li>使用覆盖索引扫描的查询可以直接使用叶节点中的主键值。</li></ul><p>聚簇索引的缺点:</p><ul><li><p>聚簇数据最大限度地提高了I/O密集型应用的性能，但如果数据全部都放在内存中，则访问的顺序就没有那么重要了，聚簇索引也没什么优势了。</p></li><li><p>插入速度严重依赖于插入顺序。安卓主键的顺序插入是加载数据到InnoDB表中速度最快的方式。但如果不是按照主键顺序加载数据，那么在加载完成之后最后使用OPTIMIZE TABLE命令重新组织一下表。</p></li><li><p>更新聚簇索引列的代价很高，因为会强制InnoDB将每个被更新的行移到新的位置。</p></li><li><p>基于聚簇索引的表在插入新行，或者主键被更新导致需要移动行的时候，可能面临“页分裂(page split)”的问题。当行的主键值要求必须将这一行插入到某个已满的页中时，存储引擎会将该页分裂成两个页面来容纳该行，这就是一次页分裂操作。页分裂会导致表占用更多的磁盘空间。</p></li><li><p>聚簇索引可能导致全表扫描变慢，尤其是行比较稀疏，或者由于页分裂导致数据存储不连续。</p></li><li><p>二级索引(非聚簇索引)可能比想象的要更大，因为在二级索引的叶子节点包含了引用行的主键列。</p></li><li><p>二级索引(非聚簇索引)访问需要两次索引查找。(二级索引叶子节点保存的不是指向行的物理位置的指针，而是行的主键值。这意味着通过二级索引查找行，存储引擎需要找到二级索引的叶子节点获得对应的主键值，然后根据这个值去聚簇索引中查找到对应的行。对于InnoDB，自适应哈希索引能够减少这样的重复工作)</p><h3 id="覆盖索引、联合索引、索引下推"><a href="#覆盖索引、联合索引、索引下推" class="headerlink" title="覆盖索引、联合索引、索引下推"></a>覆盖索引、联合索引、索引下推</h3><p>覆盖索引</p><p>:当索引已经覆盖了我们的查询需求时，称为覆盖索引。</p><p>由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。</p><p>联合索引</p><p>:两个或者两个以上列的索引称为联合索引，又称复合索引。</p><p>根据创建联合索引的顺序，以最左原则进行where检索。在建立联合索引的时候，如何安排索引内的字段顺序，主要看索引的复用能力，因为支持最左前缀，所以当已经有了(a,b)这个联合索引之后，一般就不需要单独在a上建立索引了。因此，第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往是需要优先考虑的。但是当查询条件里只有b的语句，是无法使用(a,b)这个联合索引的，这个时候你不得不维护另外一个索引，也就是说你需要同时维护(a,b)、(b)这两个索引。这个时候，需要考虑的原则就是空间了，如果a的字段比b的字段大，那就建议创建一个(a,b)的联合索引和一个(b)的单字段索引。</p><p>索引下推</p><p>:</p><p>例如SQL语句:SELECT * FROM T WHERE name LIKE ‘丁%’ AND age = 10;有联合索引(name,age)。</p><p>那么此时只能使用name字段。当然还要判断其他条件是否满足。</p><p>在MySQL5.6之前，只能从找到name满足条件的，然后一个一个回表。到主键索引中找出数据行，再对比字段值。</p><p>再MySQL引入的索引下推优化(index condition pushdown),可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，</p><p>减少回表次数</p><p>。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MySQL中索引的类型&quot;&gt;&lt;a href=&quot;#MySQL中索引的类型&quot; class=&quot;headerlink&quot; title=&quot;MySQL中索引的类型&quot;&gt;&lt;/a&gt;MySQL中索引的类型&lt;/h1&gt;&lt;p&gt;索引(在MySQL中也被叫做”键(key)”)是存储引擎用于快速找到
      
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL索引" scheme="http://yoursite.com/tags/MySQL%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>MySQL数据库事务、隔离级别、多版本并发控制(MVCC)</title>
    <link href="http://yoursite.com/2018/11/07/zhuan-java9/"/>
    <id>http://yoursite.com/2018/11/07/zhuan-java9/</id>
    <published>2018-11-07T05:18:57.000Z</published>
    <updated>2019-03-10T05:21:47.815Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL数据库事务、隔离级别以及多版本并发控制-MVCC"><a href="#MySQL数据库事务、隔离级别以及多版本并发控制-MVCC" class="headerlink" title="MySQL数据库事务、隔离级别以及多版本并发控制(MVCC)"></a>MySQL数据库事务、隔离级别以及多版本并发控制(MVCC)</h1><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>事务就是一组原子性的SQL查询。也就是说，事务内的语句，要么全部执行成功，要么全部执行失败。</p><h3 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h3><p><strong>原子性(atomicity)</strong></p><p>一个事务必须被视为一个不可分割的最小单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作，这就是事务的原子性。</p><p><strong>一致性(consistency)</strong></p><p>数据库总是从一个一致性的状态转换到另外一个一致性的状态。一致性确保了事务只要没有最终提交，就不会把事务中所作的修改保存到数据库中。</p><p><strong>隔离性(isolation)</strong></p><p>通常来说(因为要考虑隔离级别，所以说是通常情况)，一个事务所作的修改在最终提交之前，对其他事务是不可见的。</p><p><strong>持久性(durability)</strong></p><p>一旦事务提交，其所作的修改就会永久保存到数据库中。此时即使系统奔溃，修改的数据也不会丢失。持久性是个模糊的概念，因为持久性也分很多级别。有些持久性策略能够提供非常强的安全保障，而有些则未必。而且不可能做到百分之百的持久性保证的策略。</p><h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><p>隔离性其实比想象的要复杂。在SQL标准中定义了四种隔离级别，每一种级别规定了一个事务中所作的修改，哪些在事务间是可见的，哪些是不可见的。较低级别的隔离通常可以执行更高的并发，系统的开销也更低。</p><p><strong>READ UNCOMMITTED(读未提交)</strong></p><p>在READ UNCOMMITTED级别，事务中的修改即使是没有提交，对其他事务也是可见的。事务可以读取到未提交的数据，这被称为脏读(Dirty Read)。从性能来说，READ UNCOMMITTED不会比其他级别好太多，但缺乏其他级别的很多优势，所以实际应用很少。</p><p><strong>READ COMMITTED(读提交)</strong></p><p>大多数数据库的默认隔离级别都是READ COMMITTED(但MySQL不是)。READ COMMITTED满足隔离性的简单定义:一个事务开始时，只能看见已经提交的事务所作的修改。换句话说，一个事务从开始直到提交之前，所作的任何修改对其他事务都是不可见的。这个级别有时候会产生不可重复读(nonrepeatable read)，因为执行两次执行同样的查询，可能会得到不一样的结果。</p><p><strong>REPEATABLE READ(可重复读)</strong></p><p>REPEATABLE READ解决了脏读，和不可重复读的问题。但是无法解决幻读(Phantom Read)的问题。幻读是指当某个事务在读取某个范围内的记录时，另外一个事务又在范围内插入新的记录，当之前的事务再次读取该范围的记录，会产生幻行(Phantom Row)。InnoDB和XtraDB存储引擎通过多版本并发控制(MVCC)解决了幻读的问题。(可重复读是MySQL的默认事务隔离级别)。</p><p><strong>SERIALIZABLE(可串行化)</strong></p><p>SERIALIZABLE是最高隔离级别。它通过强制事务串行执行，避免幻读问题。简单来说，SERIALIZABLE会在读取的每一行上都加锁，所以可能导致大量的超时和锁争用的问题。实际应用很少使用该隔离级别，只有在非常需要确保数据一致性而且可以接受没有并发的情况下，才考虑采用该级别。</p><table><thead><tr><th>隔离级别</th><th>脏读可能性</th><th>不可重复读可能性</th><th>幻读可能性</th><th>加锁读</th></tr></thead><tbody><tr><td>READ UNCOMMITTED</td><td>Yes</td><td>Yes</td><td>Yes</td><td>No</td></tr><tr><td>READ COMMITTED</td><td>No</td><td>Yes</td><td>Yes</td><td>No</td></tr><tr><td>REPEATABLE READ</td><td>No</td><td>No</td><td>Yes</td><td>No</td></tr><tr><td>SERIALIZABLE</td><td>No</td><td>No</td><td>No</td><td>Yes</td></tr></tbody></table><h3 id="多版本并发控制-MVCC"><a href="#多版本并发控制-MVCC" class="headerlink" title="多版本并发控制(MVCC)"></a>多版本并发控制(MVCC)</h3><p>MySQL的大多数事务型存储引擎实现的都不是简单的行级锁。基于提升并发性能的考虑，它们一般都同时实现了多版本并发控制(MVCC)。不仅是MySQL，包括Oracle、PostgreSQL等其他数据库系统也实现了MVCC，但是实现机制不尽相同，因为MVCC没有一个统一的实现标准。</p><p>可以认为MVCC是行级锁的一个变种，但是它在多数情况下都避免了加锁操作，因此开销更低。虽然实现机制有所不同，但大都实现了非阻塞的读操作，写操作也只锁定必要的行。</p><p>MVCC的实现，是通过保存数据在某个时间点的快照来实现的。也就是说，不管执行多长时间，每个事物看到的数据都是一致的。根据事务开始时间的不同，每个事物对同一张表，同一时刻看到的数据可能是不一样的。</p><p>InnoDB的MVCC，是通过在每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存行的过期时间或者删除时间。存储的并不是实际的时间值，而是系统版本号(system version number)。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。</p><p><strong>MVCC在REPEATABLE READ隔离级别下的操作</strong></p><p><strong>SELECT</strong></p><p>InnoDB会根据以下两个条件检查每行记录:</p><p>a.InnDB只查找版本早于当前事务版本的数据行(也就是，行的系统版本号小于或者等于事务的系统版本号)，这样可以确保事务读取的行，要么是在事务开始前已经存在，要么是事务自身插入或者修改过的。</p><p>b.行的删除版本要么未定义，要么大于当前事务版本号。这可以确保事务读取到的行，在事务开始之前未被删除。</p><p>只有符合上述两个条件的记录，才能返回作为查询的结果。</p><p><strong>INSERT</strong></p><p>InnoDB为新插入的每一行保存当前系统版本号作为行版本号。</p><p><strong>DELETE</strong></p><p>InnoDB为删除的每一行保存当前系统版本号作为行删除标识。</p><p><strong>UPDATE</strong></p><p>InnoDB先插入一行新记录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行的删除标识。</p><p>保存这样两个系统版本号，使大多数读操作都可以不用加锁。这样设计使得读操作很简单，性能很好，并且也能保证只会读到符合标准的行。不足之处是每行记录都是需要额外的存储空间，需要做更多的行检查工作以及一些额外的维护工作。</p><p>MVCC只在REPEATABLE READ和READ COMMITTED两个隔离级别下工作。其他两个隔离级别都和MVCC不兼容。因为READ UNCOMMITTED总是读到最新的数据行，而不是符合当前事务版本的数据行。SERIALIZABLE则会对所有读取的行都加锁。</p><h3 id="InnoDB中幻读的解决到底是依赖Next-Key-Locks还是MVCC"><a href="#InnoDB中幻读的解决到底是依赖Next-Key-Locks还是MVCC" class="headerlink" title="InnoDB中幻读的解决到底是依赖Next-Key Locks还是MVCC?"></a>InnoDB中幻读的解决到底是依赖Next-Key Locks还是MVCC?</h3><p>首先读分为:快照读、当前读。</p><ul><li><p>快照读。例: SELECT * FROM table WHERE …;</p></li><li><p>当前读。当前读都是先读后写,只能读当前的值特殊的读操作。比如更新，插入，删除操作，属于当前读，需要加锁。</p><p>SELECT <em>FROM table WHERE ? lock in share mode;SELECT</em> from FROM table WHERE ? for update;<br>INSERT INTO table values (…);<br>UPDATE table SET ? WHERE ?;</p></li></ul><p>结论:</p><ul><li>对于快照读来讲，幻读的解决依赖于MVCC，使用 MVCC 读取的是快照中的数据，这样可以减少加锁所带来的开销。</li><li>对于当前读，读取的是最新的数据，需要加锁，依赖Next-Key Locks。</li></ul><p><em>拓展</em>:</p><p>Next-key Locks:是InnoDB存储引擎的一种锁实现。</p><p>Record Locks:锁定一个记录上的索引，而不是记录本身。</p><p>Gap Locks:锁定索引之间的间隙，但是不包含索引本身。</p><p>Next-key Locks:是上述两者的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MySQL数据库事务、隔离级别以及多版本并发控制-MVCC&quot;&gt;&lt;a href=&quot;#MySQL数据库事务、隔离级别以及多版本并发控制-MVCC&quot; class=&quot;headerlink&quot; title=&quot;MySQL数据库事务、隔离级别以及多版本并发控制(MVCC)&quot;&gt;&lt;/
      
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL数据库事务" scheme="http://yoursite.com/tags/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/"/>
    
      <category term="MySQL隔离级别" scheme="http://yoursite.com/tags/MySQL%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
    
  </entry>
  
  <entry>
    <title>函数</title>
    <link href="http://yoursite.com/2018/11/05/function/"/>
    <id>http://yoursite.com/2018/11/05/function/</id>
    <published>2018-11-05T11:50:16.000Z</published>
    <updated>2019-03-10T05:42:04.774Z</updated>
    
    <content type="html"><![CDATA[<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="函数基础"><a href="#函数基础" class="headerlink" title="函数基础"></a>函数基础</h2><p>函数的定义包括： 返回类型、函数名、形参列表、函数体。</p><p>通过调用运算符()来执行函数。</p><h4 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h4><p>函数的调用完成两项工作：</p><ol><li>用实参初始化函数对应的形参</li><li>将控制权转移给被调用函数。此时，主调函数的执行被暂时中断，被调函数开始执行。</li></ol><p>当遇到一条return语句时函数结束执行过程。return语句也完成两项工作：</p><ol><li>返回return语句中的值(有的话)</li><li>将控制权从被调函数转移回主调函数。继续完成主调函数剩余部分。</li></ol><h4 id="形参和实参"><a href="#形参和实参" class="headerlink" title="形参和实参"></a>形参和实参</h4><p>实参是形参的初始值。第一个实参初始化第一个形参，第二个实参初始化第二个形参，以此类推。</p><p>尽管实参与形参存在对应关系，但是没有规定实参的求值顺序。编译器能任意可行的顺序对实参求值。</p><p>实参类型必须与对应的形参匹配，且数量必须相等。两个形参的名字不能相同。    </p><h4 id="函数的形参列表"><a href="#函数的形参列表" class="headerlink" title="函数的形参列表"></a>函数的形参列表</h4><p>函数的形参列表可以为空，但是不能省略。要想定义一个不带形参的函数，最常用的办法是书写一个空的形参列表。为了与C语言兼容，也可以使用关键字void表示函数没有形参：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span><span class="comment">//隐式的定义空形参列表</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">void</span>)</span><span class="comment">//显示的定义空形参列表</span></span></span><br></pre></td></tr></table></figure><h4 id="函数返回类型"><a href="#函数返回类型" class="headerlink" title="函数返回类型"></a>函数返回类型</h4><p>大多数类型都能用作函数的返回类型。一种特殊的返回类型是void，它表示函数不返回任何值。</p><p>一种特殊的返回值是void：不返回任何值。</p><p>函数的返回类型不能是数组或者函数类型。可以是指针或者引用。</p><h3 id="局部对象"><a href="#局部对象" class="headerlink" title="局部对象"></a>局部对象</h3><p>在c++中，名字有作用域；对象有生命周期。</p><ul><li>名字的作用域是程序文本的一部分，名字在其中可见</li><li>对象的生命周期是程序执行过程中该对象存在的一段时间</li></ul><p>函数体是一个语句块。块构成一个新的作用域，我们可以再其中定义变量。形参和函数体内部定义的变量统称为局部变量。它们对函数而言是局部的，仅在函数的作用域内可见，同时局部变量还会隐藏在外层作用域中同名的其他所有声明中。</p><h4 id="自动对象"><a href="#自动对象" class="headerlink" title="自动对象"></a>自动对象</h4><p>对于普通局部变量对应的对象来说，当函数的控制路径经过变量定义语句时创建对象，到达定义所在的块末尾时销毁它。我们把只存在于块执行期间的对象称为自动对象。</p><p><strong>对于局部变量来说，如果没有初始化的值那就会执行默认初始化，意味着默认初始化内置变量将产生未定义的值。</strong></p><h4 id="局部静态对象"><a href="#局部静态对象" class="headerlink" title="局部静态对象"></a>局部静态对象</h4><p>某些时候，有必要令局部变量的生命周期贯穿函数调用及之后的时间。可以将局部变量定义成static类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">size_t</span> ctr = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p><strong>局部静态对象</strong>在程序第一次执行经过对象定义语句时初始化，并且直到程序终止才被销毁，期间就算函数结束执行也不会对它有影响。</p><p>内置类型局部静态变量默认初始化为0。</p><h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><p>类似于变量，函数只能定义一次，但是可以声明多次。</p><p>函数的声明与定义类似，只是声明无须函数体，用一个分号替代即可。</p><p>函数的三要素(<strong>返回类型、函数名、形参类型</strong>)描述了函数的接口，说明了调用该函数所需的信息。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator beg,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator end)</span></span>;</span><br></pre></td></tr></table></figure><p>函数声明也被称为函数原型。</p><p>函数通常在头文件中进行函数声明而在源文件中定义。</p><h3 id="分离式编译"><a href="#分离式编译" class="headerlink" title="分离式编译"></a>分离式编译</h3><p>随着程序越来越复杂，我们希望把程序的各个部分分别存储在不同文件中。</p><p>分离式编译(separate compilation)允许我们可以根据逻辑关系把程序分离成不同的文件中，每个文件独立编译。</p><h4 id="编译和链接"><a href="#编译和链接" class="headerlink" title="编译和链接"></a>编译和链接</h4><p>比如fact函数定义在一个fact.cc的文件中，它的声明在Chapter6.h的头文件中，在名为factMain.cc的文件中创建main函数调用fact函数。要生成可执行文件必须要告诉编译器需要用到的文件。</p><p>接下来编译器把对象文件(.obj(windows)或.o(unix))链接在一起形成可执行文件。</p><h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p>如前所述，每次调用函数都会重新创建它的形参，并用传入的实参对形参进行初始化。</p><p><strong>形参初始化的机理与变量初始化一样。</strong></p><ul><li>当形参是引用类型时，我们说它对应的实参被<strong>引用传递</strong>或者函数被传引用调用。它将绑定到对应实参上</li><li>当实参的值被拷贝给形参时，形参和实参是相互独立的两个对象。我们说这样的实参被<strong>值传递</strong>或者函数被传值调用</li></ul><h4 id="指针形参"><a href="#指针形参" class="headerlink" title="指针形参"></a>指针形参</h4><p>和其他非引用类型一样。执行指针拷贝操作时，拷贝的是指针的值。拷贝之后两个指针是不同的指针，但是指向的是同一个对象。因为指针使我们可以间接访问它所指的对象，所以通过指针可以修改它所指对象的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wrap</span><span class="params">(<span class="keyword">int</span> *p)</span></span>;</span><br><span class="line">wrap(&amp;a);<span class="comment">//调用</span></span><br></pre></td></tr></table></figure><p><strong>建议</strong>用引用类型的形参代替指针类型。</p><h4 id="传引用参数"><a href="#传引用参数" class="headerlink" title="传引用参数"></a>传引用参数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wrap</span><span class="params">(<span class="keyword">int</span> &amp;r)</span></span>;</span><br><span class="line"></span><br><span class="line">wrap(a);</span><br></pre></td></tr></table></figure><p>使用引用从而避免拷贝。</p><p>可以使用引用参数获得额外的信息：定义一个引用的形参用来获取值</p><h4 id="const形参和实参"><a href="#const形参和实参" class="headerlink" title="const形参和实参"></a><strong>const形参和实参</strong></h4><p>和其他初始化一样，当用实参初始化形参时会忽略顶层const(作用于对象本身)。当形参有const时，传给他常量或者非常量都是可以的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fcn</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> i)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fcn</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;&#125;<span class="comment">//错误：重复定义了fcn(int)</span></span><br></pre></td></tr></table></figure><p>因为上面两个方法传入的参数可以一样，所以是重复定义了。</p><h4 id="指针或引用形参与const"><a href="#指针或引用形参与const" class="headerlink" title="指针或引用形参与const"></a>指针或引用形参与const</h4><p>形参的初始化方式和变量是一样的。我们可以使用非常量初始化一个底层const对象，但是反过来不行：</p><p>也就是，形参参数是int <em>,那么实参不能是const int </em>;</p><p>如果形参参数是int &amp;那么实参不能是const int &amp;。</p><h4 id="数组形参"><a href="#数组形参" class="headerlink" title="数组形参"></a><strong>数组形参</strong></h4><p>数组的两个特殊性质会影响函数的使用：</p><ol><li>数组不能被拷贝（所以不能使用值传递）</li><li>使用数组时通常被转换成指针</li></ol><p>尽管不能以值传递的方式传递数组，但是我们可以把形参写成类似数组的形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>[<span class="number">10</span>])</span></span>;</span><br></pre></td></tr></table></figure><p>以上三个函数是等价的：每个函数的唯一形参都是const int *。定义的第一个维度会被忽略。</p><p><strong>因为不知道长度，所以需要管理形参：</strong></p><p>管理形参的三个方法：</p><ol><li>使用标记指定数组长度：使用c风格字符串，在字符数组中跟一个空字符，那么运行到空字符就停止</li><li>使用标准库规范：传递数组首指针和尾后指针。begin()、end()</li><li>显示传递一个表示数组大小的形参</li></ol><p><strong>数组形参和const</strong></p><p>当函数不需要执行写操作的时候定义为const的指针</p><p><strong>数组引用形参</strong></p><p>可以将引用形参绑定到数组上：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> (&amp;arr)[<span class="number">10</span>])</span></span>;</span><br></pre></td></tr></table></figure><p>括号不可少，这表明arr是具有10个整数的数组引用。这样在函数体内就能放心的使用数组，只要不超过维度。但是这样增加了局限性，这个函数只能作用于大小为10的数组。16.1.1介绍传递任意大小的数组。</p><h4 id="传递多维数组"><a href="#传递多维数组" class="headerlink" title="传递多维数组"></a>传递多维数组</h4><p>传递的就是指向一个数组的指针，数组第二维(以及后面所有的维度)的大小都是数组类型的一部分，不能省略：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> (*matrix)[<span class="number">10</span>], <span class="keyword">int</span> rowSize)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>同样可以用数组的语法定义函数，此时依然会忽略第一个维度：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等价定义</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> matrix[][<span class="number">10</span>, <span class="keyword">int</span> rowSize])</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="main：处理命令行选项"><a href="#main：处理命令行选项" class="headerlink" title="main：处理命令行选项"></a><strong>main：处理命令行选项</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br></pre></td></tr></table></figure><p>第二个参数是指向c风格字符串的指针的数组。第一个参数是数组内的数量。</p><p>比如可执行文件名：prog</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prog -d -o ofile data0</span><br></pre></td></tr></table></figure><p>那么数组argv就是：</p><p>argv[0] = “prog”;         //第0位是执行文件的名字</p><p>argv[1] = “-d”            //接下来就是命令行输入的字符串了</p><p>…</p><p>在vs中设置main()选项：</p><ol><li>右键项目-&gt;属性-&gt;调试</li><li>在命令参数里面写需要写的参数，用空格分开</li></ol><p><img src="/2018/11/05/function/main.png" alt=""></p><p>用cmd命令行则是：</p><p><img src="/2018/11/05/function/cmd.png" alt=""></p><h4 id="可变形参——initializer-list形参"><a href="#可变形参——initializer-list形参" class="headerlink" title="可变形参——initializer_list形参"></a>可变形参——initializer_list形参</h4><p>这是一个标准库类型，如果传入的参数数量是不定的但是类型都相同，那么可以用这个模板类型。</p><p><img src="/2018/11/05/function/initializer-list.png" alt="img"></p><p>像vector一样：</p><p>initializer_list<string> ls;</string></p><p><strong>initializer_list类型</strong>的元素都是常量，因此在用for循环时候不能设为普通引用，编译会报错。（？除非是类类型或者容器类型(比如string)才能将设为引用）。</p><h3 id="返回类型和return"><a href="#返回类型和return" class="headerlink" title="返回类型和return"></a>返回类型和return</h3><p>return语句终止当前正在执行的函数并将控制权返回到调用该函数的地方。</p><p>return语句有两种形式：</p><ol><li>return;</li><li>return expression</li></ol><h4 id="无返回值函数"><a href="#无返回值函数" class="headerlink" title="无返回值函数"></a>无返回值函数</h4><p>void函数可以不加return，函数的最后一句会隐式的地执行return。</p><p>void函数可以执行第二种return但是返回的必须是另一个void的函数</p><h4 id="有返回值函数"><a href="#有返回值函数" class="headerlink" title="有返回值函数"></a>有返回值函数</h4><p>除了void的函数必须要有返回值，不然会编译报错。但是如果某一条路径上没有返回值，则会在运行时报错。</p><p><strong>值的返回</strong></p><p>return一个值的方式和初始化一个变量和形参的方式完全一样。</p><p>但是不能返回一个局部变量的指针或者引用，因为局部变量在函数完成后它的存储空间也被释放掉，那么局部变量(字面值也算)的引用将指向不再有效的内存。</p><p><strong>返回类类型的函数和调用运算符</strong></p><p>调用运算符和点运算符箭头运算符优先级一样并且符合左结合律。因此能如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> sz = shortString(s1, s2).size();</span><br></pre></td></tr></table></figure><p><strong>引用返回左值</strong></p><p>函数的返回类型决定函数调用是否是左值。调用一个返回引用的函数是左值，其他返回类型是右值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> &amp;<span class="title">get_val</span><span class="params">()</span></span>;</span><br><span class="line">get_val(s, <span class="number">0</span>) = ‘A’;<span class="comment">//能给返回的引用赋值</span></span><br></pre></td></tr></table></figure><p><strong>列表初始化返回值</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; process()&#123;</span><br><span class="line"><span class="keyword">return</span> &#123;“a”,”b”,”c”&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>主函数main的返回值</strong></p><p>main函数会隐式在最后一行返回0，它的函数值看作是状态指示器，返回0表示执行成功，别的值则是执行失败。非0的值含义根据机器而定。</p><p>cstdlib头文件里面定义了两个预处理变量，可以用这两个变量表示成功(0)与失败。这样返回值与机器无关：</p><p>EXIT_FALLURE;</p><p>EXIT_SUCCESS;</p><p>main函数不能调用他自己。</p><h4 id="返回数组指针"><a href="#返回数组指针" class="headerlink" title="返回数组指针"></a>返回数组指针</h4><p>因为数组不能被拷贝所以能返回数组的引用或者指针。</p><p>声明一个返回指针的函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Type(*function(parameter _list))[dimension]</span><br></pre></td></tr></table></figure><p>Type表示元素类型，dimension是数组的大小，括号必须存在。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (*func(<span class="keyword">int</span> i))[<span class="number">10</span>];<span class="comment">//func返回一个10个int元素的数组的指针</span></span><br></pre></td></tr></table></figure><p><strong>尾置返回类型</strong></p><p>用于简化函数声明，这种形式对比较复杂的函数返回类型比较有用，上述可定义为：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto func(int i)-&gt;int (*)[10];</span><br></pre></td></tr></table></figure><p>在参数列表后面有一个箭头符号，后面代表返回类型，然后在前面加一个auto。</p><p>使用<strong>decltype</strong></p><p>如果我们知道指针指向哪个数组，就可以使用decltype，但是它返回的是数组，所以我们需要把它在声明时加一个*。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(odd) *func(<span class="keyword">int</span> i)&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>如果同一作用域内的几个函数的名字相同但形参列表不同，称之为重载函数。</p><p>定义：</p><ol><li>形参数量或者形参类型上有所不同。<br>注（以下不算函数重载）：</li><li>如果只是返回类型不同不算函数重载</li><li>省略了形参名字、或只是形参别名也不算</li><li>传入的是顶层const</li></ol><h4 id="重载和const形参"><a href="#重载和const形参" class="headerlink" title="重载和const形参"></a>重载和const形参</h4><p>顶层const不影响传入函数的对象，因此一个顶层const的函数和一个没有const的函数不能区分成两个函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Phone)</span></span>;</span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Phone)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Phone*)</span></span>;</span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Phone* <span class="keyword">const</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>这两组都是重复的声明，因为是顶层const</p><p>如果传入的是底层的const，区分指针或者引用指向的对象是否是const可以区分成<strong>两个</strong>函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Account&amp;)</span></span>;</span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Account&amp;)</span></span>;</span><br></pre></td></tr></table></figure><p>指针同上。</p><h4 id="const-cast-和重载"><a href="#const-cast-和重载" class="headerlink" title="const_cast 和重载"></a>const_cast 和重载</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="built_in">string</span> &amp;<span class="title">shorterString</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s1, <span class="keyword">const</span> <span class="built_in">string</span> &amp;s1)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> s1.size()&gt;s2.size()?s2:s1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传入和返回的都是const类型的string引用，我们想传入普通引用。那么可以用const_cast：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> &amp;<span class="title">shorterString</span><span class="params">(<span class="built_in">string</span> &amp;s1, <span class="built_in">string</span> &amp;s2)</span></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> &amp;r = shorterString(<span class="keyword">const_cast</span>&lt;<span class="keyword">const</span> <span class="built_in">string</span>&amp;&gt;(s1), </span><br><span class="line"><span class="keyword">const_cast</span>&lt;<span class="keyword">const</span> <span class="built_in">string</span>&amp;&gt;(s2));</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;<span class="built_in">string</span>&amp;&gt;(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样操作是安全的。</p><h3 id="重载与作用域"><a href="#重载与作用域" class="headerlink" title="重载与作用域"></a>重载与作用域</h3><p>一般来说函数声明置于全局而不是局部。如果将函数声明在局部，那么会将在外层作用域中同名的函数实体隐藏。在不同作用域中无法重载函数名：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fooBar</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">bool</span> read = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">string</span> s = read();<span class="comment">//错误：read变为bool值而非函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">print(“Value : ”);<span class="comment">//错误：print(const string&amp;)被隐藏了</span></span><br><span class="line">print(<span class="number">1</span>);</span><br><span class="line">print(<span class="number">3.14</span>);<span class="comment">//正确：调用print(int);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上可知，局部声明的函数会隐藏作用域外的同名函数。调用函数时，编译器首先寻找对该函数的声明，找到的是局部声明，就会忽略掉外层的同名实体。</p><h2 id="特殊用途语言特性"><a href="#特殊用途语言特性" class="headerlink" title="特殊用途语言特性"></a>特殊用途语言特性</h2><h3 id="默认实参"><a href="#默认实参" class="headerlink" title="默认实参"></a>默认实参</h3><p>如果一个函数多次调用，传入的参数是相同的那么我们可以设置一个默认参数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">string</span>::size sz;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">screen</span><span class="params">(sz ht = <span class="number">24</span>, sz wid = <span class="number">80</span>, <span class="keyword">char</span> backgrnd = ‘ ’)</span></span>;</span><br></pre></td></tr></table></figure><p>想使用默认实参只需要省略参数就可以了。</p><p>默认实参负责填补函数调用缺少的尾部实参，意思就是如果想要覆盖第三个参数，那么前面两个参数也要给定实参：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window = screen(, , ‘?’);<span class="comment">//错误：只能省略尾部的实参</span></span><br></pre></td></tr></table></figure><h4 id="默认实参声明"><a href="#默认实参声明" class="headerlink" title="默认实参声明"></a>默认实参声明</h4><p>在给定的作用域中一个形参只能被赋予一次默认实参。后续声明只能为没有默认值的形参添加实参，而且该形参的右侧必须都有默认值:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">screen</span><span class="params">(sz, sz, <span class="keyword">char</span> = ‘ ‘)</span></span>;<span class="comment">//char = ‘ ’等同于char c = ‘ ’。</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">screen</span><span class="params">(sz, sz, <span class="keyword">char</span> = ‘*’)</span></span>;<span class="comment">//错误：重复声明了char</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">screen</span><span class="params">(sz=<span class="number">24</span>, sz = <span class="number">80</span>, <span class="keyword">char</span>)</span></span>;<span class="comment">//正确：添加默认实参</span></span><br></pre></td></tr></table></figure><p>如果在局部内声明，那么会<strong>隐藏外层作用域的声明</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">make_plural</span><span class="params">(<span class="keyword">size_t</span>, <span class="keyword">const</span> <span class="built_in">string</span>&amp;, <span class="keyword">const</span> <span class="built_in">string</span>&amp; = <span class="string">"s"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; make_plural(<span class="number">1</span>, <span class="string">"success"</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; make_plural(<span class="number">2</span>, <span class="string">"success"</span>, <span class="string">"es"</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; make_plural(<span class="number">2</span>, <span class="string">"failure"</span>) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//输出failures</span></span><br><span class="line"><span class="comment">//隐藏了外层的声明</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">make_plural</span><span class="params">(<span class="keyword">size_t</span>, <span class="keyword">const</span> <span class="built_in">string</span>&amp; word = <span class="string">"dog"</span>, <span class="keyword">const</span> <span class="built_in">string</span>&amp; = <span class="string">"p"</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; make_plural(<span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//输出dogp</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">make_plural</span><span class="params">(<span class="keyword">size_t</span> c, <span class="keyword">const</span> <span class="built_in">string</span>&amp; word, <span class="keyword">const</span> <span class="built_in">string</span>&amp; ending)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (c &gt; <span class="number">1</span>) ? word + ending : word;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>局部变量不能作为默认实参。除此之外，只要表达式的类型能转换成形参所需的类型就能作为默认实参。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sz wd = <span class="number">80</span>;</span><br><span class="line"><span class="keyword">char</span> def = ‘ ’;</span><br><span class="line"><span class="function">sz <span class="title">ht</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">screen</span><span class="params">(sz=ht(), sz=wd, <span class="keyword">char</span>=def)</span></span>;</span><br></pre></td></tr></table></figure><p>用作默认实参的名字在函数声明所在的作用域内解析：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>&#123;</span><br><span class="line">def=’*’;<span class="comment">//改变默认实参的值</span></span><br><span class="line">sz wd = <span class="number">100</span>;</span><br><span class="line">window = screen();<span class="comment">//调用screen(ht(), 80, ‘*’) def实参被改变了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内联函数和constexpr函数"><a href="#内联函数和constexpr函数" class="headerlink" title="内联函数和constexpr函数"></a>内联函数和constexpr函数</h3><p>内联函数可以避免函数调用的开销：将函数指定为内联inline，通常就是将他在每个调用点上内联的展开。内联说明只是向编译器发出的一个请求，编译器可以忽略。一般用于优化规模小、流程直接、调用频繁的函数。</p><h4 id="constexpr函数"><a href="#constexpr函数" class="headerlink" title="constexpr函数"></a>constexpr函数</h4><p>constexpr函数是指能用于常量表达式的函数，它的函数返回类型以及所有的形参类型都得是<strong>字面值</strong>类型，而且只能有一条return语句。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">new_sz</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="number">42</span>;&#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> foo = new_sz();<span class="comment">//正确foo是一个常量表达式</span></span><br></pre></td></tr></table></figure><p>在初始化变量时候，编译器会验证new_sz函数返回值是否是常量表达式，如果是那么就能初始化成功。</p><p>为了能在编译过程中随时展开，constexpr函数被隐式的指定为内联函数。</p><p><strong>允许constexpr的返回值不是常量</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> size_t <span class="title">scale</span><span class="params">(<span class="keyword">size_t</span> cnt)</span></span>&#123;<span class="keyword">return</span> new_sz()*cnt;&#125;</span><br><span class="line"><span class="keyword">int</span> arr[scale(<span class="number">2</span>)];<span class="comment">//正确</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> a2[scale(i)];<span class="comment">//错误</span></span><br></pre></td></tr></table></figure><p>如上，数组初始化值只能是常量表达式，当传入一个字面值是2的常量表达式时scale函数返回的也是常量表达式，反之传入非常量表达式i返回的也是非常量表达式。那么编译器会发出错误信息。</p><p><strong>constexpr函数和内联函数放在头文件内</strong></p><p>和其他函数不一样，这两个函数能定义多次，但是它的多个定义必须一致。所以放在头文件中。</p><h3 id="assert预处理宏和NDEBUG预处理变量"><a href="#assert预处理宏和NDEBUG预处理变量" class="headerlink" title="assert预处理宏和NDEBUG预处理变量"></a>assert预处理宏和NDEBUG预处理变量</h3><p>assert是一个预处理宏，行为类似内联函数。使用一个表达式作为他的条件：</p><p>assert(expr)；</p><p>如果表达式为假(即0)，那么assert输出信息并且终止程序的运行。</p><p>assert定义在 cassert头文件中，预处理变量和宏名字在程序内都唯一不需要提供using声明。不能定义assert为名字的其他变量或者函数名。</p><p>NDEBUG：</p><p>如果定义了NDEBUG预处理变量，那么assert就不会被检查。也就是失效</p><p>预处理定义了几个对程序调试很有用的名字：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func__<span class="comment">//存放函数名的const char数组</span></span><br><span class="line"></span><br><span class="line">__FILE__<span class="comment">//存放文件名的字符串字面值</span></span><br><span class="line"></span><br><span class="line">__LINE__<span class="comment">//存放当前行号的整型字面值</span></span><br><span class="line"></span><br><span class="line">__TIME__<span class="comment">//存放编译时间的字符串字面值</span></span><br><span class="line"></span><br><span class="line">__DATE__<span class="comment">//存放文件编译日期的字符串字面值</span></span><br></pre></td></tr></table></figure><h2 id="函数匹配"><a href="#函数匹配" class="headerlink" title="函数匹配"></a>函数匹配</h2><p>当几个重载函数的形参数量相等以及某些形参的类型可以由其他类型转换得来时，进行函数匹配的流程如下：</p><ol><li>选定本次调用的<strong>候选函数</strong>：<ol><li>与被调用函数同名</li><li>其声明在调用点可</li></ol></li><li>选出<strong>可行函数</strong>：<ol><li>其形参数量跟本次调用实参数量相等</li><li>每个实参对应的类型相同或者能转换成形参类型</li></ol></li><li>寻找最佳匹配：基本思想是实参类型与形参类型越接近，它们<strong>匹配的越好（实参类型转换）</strong>。满足下面两个条件才算匹配成功：<ol><li>该函数每个实参的匹配的都不劣于其他可行函数需要的匹配</li><li>至少有一个实参的匹配优于其他可行函数提供的匹配</li></ol></li></ol><p>例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> , <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">double</span>, <span class="keyword">double</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">f(<span class="number">5</span>,<span class="number">2.3</span>);</span><br></pre></td></tr></table></figure><p>上面这个调用会产生二义性，因为在第一个参数上匹配int精确匹配，但是在第二个参数上需要转成int；或者匹配double，第一个参数需要转。</p><p>调用重载函数尽量避免强制转换。如果需要则说明设计不合理。</p><h4 id="实参类型转换"><a href="#实参类型转换" class="headerlink" title="实参类型转换"></a>实参类型转换</h4><p>为了确定最佳匹配，编译器将实参类型到形参类型的转换划分为几个等级如下：</p><ol><li><p>精确匹配：</p><p>(1) 实参类型和形参类型相同</p><p>(2) 实参从数组类型或函数类型转换成对应的指针类型</p><p>(3) 向实参添加顶层const或者从实参中删除顶层const</p></li><li><p>通过const转换实现的匹配</p></li><li><p>通过类型提升(char-&gt;int)</p></li><li><p>通过算数类型转换(int -&gt; long)</p></li><li><p>通过类类型转换实现的匹配</p></li></ol><p>第4点：所有算术类型转换的级别都一样。比如从int到unsigned int或者double的级别是一样的。一个double如果能转到long跟float那么存在二义性</p><p>第2点：函数匹配和const实参：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Account&amp;)</span></span>;</span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Account&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Account a;</span><br><span class="line">Account b;</span><br><span class="line"></span><br><span class="line">lookup(a);<span class="comment">//调用lookup(const Account&amp;)</span></span><br><span class="line">lookup(b);<span class="comment">//调用lookup(Account&amp;)</span></span><br></pre></td></tr></table></figure><p>第二个调用中传入b。对于这个调用来说两个函数都是可行的，我们可以用b初始化常量引用。但是需要转换。所以精确匹配到了非常量引用的函数</p><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>函数指针指向的是函数而非对象。函数的类型由返回类型和形参类型决定：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> (*pf) (<span class="keyword">const</span> <span class="built_in">string</span>&amp;, <span class="keyword">const</span> <span class="built_in">string</span>&amp;);</span><br></pre></td></tr></table></figure><p>pf是一个指向函数的指针，这个函数返回bool并且参数列表是两个const string &amp;</p><p>把函数名作为值使用时，自动转成指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pf = lengthCompare;</span><br><span class="line">pf = &amp; lengthCompare;<span class="comment">//等价的赋值</span></span><br></pre></td></tr></table></figure><p>在使用指针的时候也可以不需要解引用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> b1 = pf();</span><br><span class="line"><span class="keyword">bool</span> b2 = (*pf)();<span class="comment">//等价的调用函数</span></span><br></pre></td></tr></table></figure><p>在指向不同函数类型间不存在转换规则，但是可以指向nullptr。</p><p>使用重载函数时，必须清晰的界定选用那个函数，必须精确匹配。</p><h4 id="函数形参"><a href="#函数形参" class="headerlink" title="函数形参"></a>函数形参</h4><p>和数组类似，函数不能定义成形参，但是形参可以是指向函数的指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">useBigger</span><span class="params">(<span class="keyword">bool</span> pf(<span class="keyword">const</span> <span class="built_in">string</span>&amp;,<span class="keyword">const</span> <span class="built_in">string</span>&amp;))</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">useBigger</span><span class="params">(<span class="keyword">bool</span> (*pf)(<span class="keyword">const</span> <span class="built_in">string</span>&amp;,<span class="keyword">const</span> <span class="built_in">string</span>&amp;))</span></span>;<span class="comment">//等价的声明</span></span><br></pre></td></tr></table></figure><p>我们可以直接把函数当成实参使用，他会自动转成指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useBigger(lengthCompare);</span><br></pre></td></tr></table></figure><p>使用typedef别名能简化函数名：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">bool</span> <span class="title">Func</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;,<span class="keyword">const</span> <span class="built_in">string</span>&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(lengthCompare)</span> Func2</span>;<span class="comment">//同上，func2是函数类型</span></span><br></pre></td></tr></table></figure><p>在上述func前加*就是函数指针。</p><h4 id="返回函数的指针"><a href="#返回函数的指针" class="headerlink" title="返回函数的指针"></a>返回函数的指针</h4><p>和数组一样，不能直接返回一个函数但是可以返回函数指针。</p><p>使用类型别名显得方便：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> F = <span class="keyword">int</span>(<span class="keyword">int</span>*, <span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">using</span> PF = <span class="keyword">int</span>(*)(<span class="keyword">int</span>*, <span class="keyword">int</span>);<span class="comment">//PF是指针类型</span></span><br><span class="line"></span><br><span class="line"><span class="function">PF <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span></span>;<span class="comment">//正确：PF是指向函数的指针</span></span><br><span class="line"><span class="function">F <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span></span>;<span class="comment">//错误：不能返回函数</span></span><br><span class="line"><span class="function">F *<span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span></span>;<span class="comment">//正确：显示声明指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> (*f1(<span class="keyword">int</span>))(<span class="keyword">int</span>*, <span class="keyword">int</span>);<span class="comment">//同上声明</span></span><br></pre></td></tr></table></figure><p>由内向外阅读：f1是一个函数，返回的是一个指针类型。指针类型指向的是返回int的函数，参数列表是(int *，int)</p><p><strong>使用尾置返回类型的方式显得更加完整</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto f1(int) -&gt; int (*)(int*, int);</span><br></pre></td></tr></table></figure><p>同时如果知道返回类型指向的是哪个函数就可以使用decltype:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(sunLength) *getFcn(<span class="keyword">const</span> <span class="built_in">string</span>&amp;);<span class="comment">//注意需要加*</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;函数&quot;&gt;&lt;a href=&quot;#函数&quot; class=&quot;headerlink&quot; title=&quot;函数&quot;&gt;&lt;/a&gt;函数&lt;/h1&gt;&lt;h2 id=&quot;函数基础&quot;&gt;&lt;a href=&quot;#函数基础&quot; class=&quot;headerlink&quot; title=&quot;函数基础&quot;&gt;&lt;/a&gt;函数基础&lt;/h
      
    
    </summary>
    
      <category term="C++Primer笔记" scheme="http://yoursite.com/categories/C-Primer%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="function" scheme="http://yoursite.com/tags/function/"/>
    
      <category term="函数" scheme="http://yoursite.com/tags/%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>语句</title>
    <link href="http://yoursite.com/2018/11/04/statement/"/>
    <id>http://yoursite.com/2018/11/04/statement/</id>
    <published>2018-11-04T13:26:46.000Z</published>
    <updated>2019-03-10T05:41:17.055Z</updated>
    
    <content type="html"><![CDATA[<h1 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h1><h3 id="简单语句"><a href="#简单语句" class="headerlink" title="简单语句"></a>简单语句</h3><p>c++中大多数语句都以分号结束，一个表达式，比如<code>ival + 5</code>，末尾加上分号就变成了<strong>表达式语句</strong>。</p><p>表达式语句的作用是执行表达式并丢弃掉求值结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ival + <span class="number">5</span>;<span class="comment">//一条没什么用的表达式</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ival;<span class="comment">//一条输出表达式</span></span><br></pre></td></tr></table></figure><h4 id="空语句"><a href="#空语句" class="headerlink" title="空语句"></a>空语句</h4><p>最简单的语句是<strong>空语句(null statement)</strong>，只有一个单独的分号:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;<span class="comment">//空语句</span></span><br></pre></td></tr></table></figure><p>如果在某个地方，语法上需要一条空语句而逻辑上不需要，此时应该使用空语句。</p><p>例：当循环的全部工作在条件部分完成时，通常用到空语句。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重复读入数据直至到达文件末尾或依次输入的值等于sought</span></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span>&gt;&gt;s &amp;&amp; s!=sought)</span><br><span class="line">;<span class="comment">//空语句</span></span><br></pre></td></tr></table></figure><p>需要注意的是，因为空语句也是一条语句，所以可用在任何需要语句的地方。所以，要是多了个分号有可能会造成严重错误，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//出现糟糕的情况：额外的分号，循环体是空语句</span></span><br><span class="line"><span class="keyword">while</span>( iter!=sevc.end()) ;</span><br><span class="line">++iter;</span><br></pre></td></tr></table></figure><p>虽然while下面那行有缩进，但是他的循环体是后面的空语句，会造成死循环。</p><h4 id="复合语句-块"><a href="#复合语句-块" class="headerlink" title="复合语句(块)"></a>复合语句(块)</h4><p>复合语句(compound statement)是指用花括号{}括起来(可能是空的)的语句和声明的序列，也被称作块(block)。同样的在块中定义的名字只能在块内部以及嵌套在块中的子块访问。</p><p>如果在程序的某个地方，语法上需要一条语句，但是逻辑上需要多条语句，则应该使用复合语句。</p><p><strong>例如while和for的循环体必须是一条语句</strong>，但是我们常常需要做很多事情，因此需要将多条语句用花括号括起来变成复合语句，<strong>将语句序列变成块</strong>。</p><h3 id="语句作用域"><a href="#语句作用域" class="headerlink" title="语句作用域"></a>语句作用域</h3><p>可以在if、switch、while、for语句的控制结构内定义变量，这些变量只有在语句的内部可见，一旦语句结束，会自动销毁。</p><p>如果其他代码也需要访问控制变量，则变量必须定义在语句的外部。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">int</span> i = get_num())<span class="comment">//每次迭代创建并初始化i</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">i = <span class="number">0</span>;<span class="comment">//错误，外部无法访问i</span></span><br></pre></td></tr></table></figure><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><p>c++提供了两种按条件执行的语句。</p><ul><li>一种是if语句，他根据条件决定控制流；</li><li>第二种是switch语句，它计算一个整型表达式的值，然后根据这个值从几条执行路径中选择一条。</li></ul><h4 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h4><p>if语句的作用：判断一个条件是否为真，根据判断结果决定是否执行另一条。</p><p>它有两种形式，一种有else，另一种没有：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition)</span><br><span class="line">statement</span><br></pre></td></tr></table></figure><p><strong>if else</strong>语句的形式是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition)</span><br><span class="line">statement1</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">statement2</span><br></pre></td></tr></table></figure><p>如果condition为真，执行statement1；如果为假，执行statement2。</p><p><strong>悬垂else</strong></p><p>当一个if语句嵌套在另一个if语句内部时，很可能if比else多，那么如何对应else是哪个if的呢，这个问题叫做悬垂else。</p><p><strong>c++规定else与离它最近尚未匹配的if匹配，从而消除了二义性。</strong></p><p><strong>使用花括号控制执行路径</strong></p><p>通常使用花括号来控制if与else匹配以达到我们想要的结果。例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (condition1)&#123;</span><br><span class="line">    if(condition2)</span><br><span class="line">    statement1</span><br><span class="line">&#125;else//这个花括号让else与最外层if匹配。</span><br><span class="line">statement2</span><br></pre></td></tr></table></figure><h4 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h4><p>switch语句适用于在若干固定选项中做出选择。例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(ch)&#123;</span><br><span class="line"><span class="keyword">case</span> ‘a’:</span><br><span class="line">++aCnt;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> ‘b’:</span><br><span class="line">++bCnt;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> ‘c’:</span><br><span class="line">++cCnt;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">++count;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>switch的执行流程：</p><ol><li>首先对括号里的表达式进行求值，该表达式紧跟在关键字switch后面，可以是初始化的变量声明，如: int ch = get_char()</li><li>表达式的值转换成整数类型，然后与每个case标签的值比较</li><li>如果匹配成功，程序从该标签之后的第一条语句开始执行，直到break或者switch结尾。</li><li>如果没有匹配上，则跳到switch之后的第一条语句。</li></ol><p>case关键字和它对应的值一起被称为case标签(case label)。</p><ul><li>case标签的值必须是<strong>整型常量表达式</strong></li><li>任意两个case标签的值不能相同</li></ul><p><strong>default</strong></p><p>如果没有任何一个case标签能够匹配上switch表达式的值，程序将执行default标签后面的语句。</p><p>即时不准备在default标签下 做任何工作，定义一个default标签也是有用的。如果switch结构以一个空的default标签作为结束，则该default标签后面必须跟上一条空语句或一个空块。</p><p><strong>switch内部的变量定义</strong></p><p>switch的执行流程有可能会跨过某些case标签。如果跳转到了某个特定的case，而在之前忽略的case里面有变量的初始化，那么是非法行为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="literal">true</span>:</span><br><span class="line"><span class="built_in">string</span> file_name;<span class="comment">//错误，控制流绕过一个隐式初始化的变量</span></span><br><span class="line"><span class="keyword">int</span> ival = <span class="number">0</span>;<span class="comment">//错误，控制流绕过一个显示初始化的变量</span></span><br><span class="line"><span class="keyword">int</span> jval;<span class="comment">//正确：jval没有被初始化</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="literal">false</span>:</span><br><span class="line"><span class="comment">//变量jval在作用域内 但是没有被初始化。</span></span><br><span class="line">jval = next_num();</span><br><span class="line"><span class="keyword">if</span>(file_name.empty());</span><br></pre></td></tr></table></figure><p><strong>所以我们应该把变量的定义放在块内，这样保证了每个case里的变量有自己的作用域 。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="literal">true</span>:</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">string</span> file_name = get_file_name();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="迭代语句"><a href="#迭代语句" class="headerlink" title="迭代语句"></a>迭代语句</h3><p>迭代语句通常称为循环，它重复执行操作直到满足某个条件才停止。</p><p>while循环特别适用于条件保持不变。反复执行操作的情况，例如，当未达到文件末尾时不断读取下一个值。</p><p>for循环更像在按步骤迭代，它的索引值在某个范围内依次变化，<strong>结构严谨</strong>。</p><h4 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h4><p>只要条件为真，while语句就一直执行，语法形式如下：</p><p>while(condition){<br>    statement<br>}</p><p><strong>定义在while条件部分或者循环体内的变量每次迭代都经历从创建到销毁的过程。</strong></p><p><strong>不定数量的输入：</strong></p><p>while(cin&gt;&gt;value) : 当使用一个istream作为条件时其效果检测流的状态。当遇到end-if-file，或无效输入(值不为整数),istream状态会变为无效。则条件为假.<br>文件结束符end-of-file: windows 为Ctrl+Z，unix为Ctrl+D</p><h4 id="传统的for语句"><a href="#传统的for语句" class="headerlink" title="传统的for语句"></a>传统的for语句</h4><p>for语句的语法形式是</p><p>for(init-statement;condition;expression)</p><p>​    statement</p><p><strong>传统for循环的执行流程</strong></p><ol><li>循环开始时，执行一次init-statement。</li><li>接下来判断condition。如果为真则执行，否则终止循环。</li><li>最后执行expression。</li></ol><p><strong>for语句头中的多重定义</strong></p><p>init-statement可以定义多个对象。但是它只能有一条声明语句，因此所有变量的基本类型必须相同。</p><p><strong>省略for语句头中的某些部分</strong></p><p>for 语句能省略三个里面的任何一个或者全部：</p><ol><li>如果无需初始化，我们可以使用一条空语句作为init-statement</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> beg = v.begin();</span><br><span class="line"><span class="keyword">for</span>( ; beg!=v.end() &amp;&amp; *beg&gt;<span class="number">0</span>; ++beg)</span><br><span class="line">;</span><br></pre></td></tr></table></figure><ol start="2"><li>省略condition相当于在条件部分写了一个true。所以我们必须在循环体内有语句负责退出循环。</li><li>省略掉expression，就要求在条件部分或者循环体内改变迭代变量的值。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i; <span class="built_in">cin</span>&gt;&gt;i ; )</span><br><span class="line">v.push_back(i);</span><br></pre></td></tr></table></figure><h4 id="范围for语句"><a href="#范围for语句" class="headerlink" title="范围for语句"></a>范围for语句</h4><p>这种语句可以遍历容器或其他序列的所有元素。语法形式如下：</p><p>for (declaration : expression)</p><p>​    statement</p><p>expression表示的必须是一个序列，比如用花括号括起来的初始值列表、数组、vector或string等类型的对象，这些类型的共同特点是拥有能返回<strong>迭代器的begin和end</strong>成员。</p><p>declaration 定义一个变量，序列中每个元素都能转换成该变量的类型。</p><p>如果需要对序列中元素执行写操作，循环变量必须声明成引用类型。</p><p>例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;r : v)</span><br><span class="line">r*=<span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>在范围for中预存了end()的值，如果在序列中添加或删除元素，end函数的值就可能变的无效了。</p><h4 id="do-while语句"><a href="#do-while语句" class="headerlink" title="do while语句"></a>do while语句</h4><p>do while语句和while语句非常相似，唯一的区别是do while语句先执行循环体后检查条件。不管条件的值如何，我们都至少执行一次。do while的语法形式如下：</p><p>do</p><p>​    statement</p><p>while(condition);</p><p>对于do while语句来说限制性语句块，后判断条件。<strong>所以不允许在条件部分定义变量。</strong></p><p>例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ival = <span class="number">1</span>;<span class="comment">//condition中的变量只能定义在do while之外。</span></span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">ival = get_num();</span><br><span class="line">&#125;<span class="keyword">while</span>(ival);</span><br></pre></td></tr></table></figure><h3 id="跳转语句"><a href="#跳转语句" class="headerlink" title="跳转语句"></a>跳转语句</h3><p>跳转语句中断当前的执行过程。c++语言提供了4种跳转语句：break、continue、goto和return。</p><h4 id="break语句"><a href="#break语句" class="headerlink" title="break语句"></a>break语句</h4><p>break语句负责终止离他最近的while、do while、for或switch语句。</p><h4 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h4><p>终止最近的循环中的当前迭代并开始下一次迭代，只能出现在for、while和do while循环的内部。</p><p>对于while 和 do while来说，继续判断条件的值;对于传统for，继续执行expression；对于范围for则是用序列中的下一个元素循环控制变量。</p><h4 id="goto-不要使用"><a href="#goto-不要使用" class="headerlink" title="goto(不要使用)"></a>goto(不要使用)</h4><p>goto语句的作用是从goto语句无条件跳转到同一函数内的另一条语句。</p><p><strong><u>注意：不要在程序中使用goto语句，因为它使得程序既难理解又难修改。</u></strong></p><p>语法形式如下：</p><p>goto label;    </p><p>label是用于标识一条语句的标识符。    带标签语句是一种特殊的语句，在它之前有一个标示符以及一个冒号：</p><p>end: return;        //end是标签后面跟语句</p><p>和switch一样他也不能将程序的控制权冲变量的作用域之外转移到作用域之内：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">goto</span> end;</span><br><span class="line"><span class="keyword">int</span> ix = <span class="number">10</span>;<span class="comment">//错误：goto语句桡骨了一个带初始化的变量定义</span></span><br><span class="line">end:</span><br><span class="line">ix = <span class="number">42</span>;<span class="comment">//错误：此处需要用到ix 但是goto跳过了声明</span></span><br></pre></td></tr></table></figure><p>goto跳回到定义变量之前是合法的，相当于销毁后重新定义。</p><h3 id="try语句块和异常处理"><a href="#try语句块和异常处理" class="headerlink" title="try语句块和异常处理"></a><strong>try语句块和异常处理</strong></h3><p>异常是指存在于运行时的反常行为，这些行为超出了函数正常功能的范围。典型的异常包括失去数据库连接以及遇到意外输入等。</p><p>异常处理机制为程序中<strong>异常检测和异常处理</strong>这两部分的协作提供支持。</p><p>异常处理机制包括：</p><ul><li><strong>throw表达式</strong>，异常检测部分用throw表达式来表示它遇到了无法处理的问题。我们说throw引发了异常。</li><li><strong>try语句块</strong>，异常处理部分使用try语句块处理异常，try语句块以关键字try开始，并以一个或多个catch子句结束。try语句块中抛出的异常通常会被某个catch子句处理。因为catch子句处理异常，所以它们也被称作<strong>异常处理代码</strong></li><li>一套<strong>异常类</strong>，用于在throw表达式和相关的catch子句之间传递异常的具体信息。</li></ul><h4 id="throw表达式"><a href="#throw表达式" class="headerlink" title="throw表达式"></a>throw表达式</h4><p>检测部分用throw表达式引发一个异常。throw表达式包含关键字throw和紧随其后的一个表达式，其中表达式的类型就是抛出的异常类型。</p><p>例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> runtime_error(“Data must refer to same ISBN”);</span><br></pre></td></tr></table></figure><h4 id="try语句块"><a href="#try语句块" class="headerlink" title="try语句块"></a><strong>try语句块</strong></h4><p>try语句块的语法形式：</p><p><strong>try{</strong></p><p>​    program-statement</p><p><strong>} catch (exception-declaration){</strong></p><p>​    handler-statement</p><p><strong>} catch (exception-declaration){</strong></p><p>​    handler-statement</p><p><strong>}</strong>//…</p><p>try后面跟一个或多个catch，try语句块内有检测异常的代码。catch后面的括号是一个异常声明，捕获到之后执行所在的语句块来处理异常。</p><p>寻找处理代码的过程跟函数调用链刚好相反。当异常被抛出时，首先搜索抛出该异常的函数。如果没有匹配到catch子句，终止该函数，并且在调用该函数的函数中寻找。如果找不到则转到名为 terminate的标准库函数。</p><h4 id="标准异常"><a href="#标准异常" class="headerlink" title="标准异常"></a><strong>标准异常</strong></h4><p>c++标准库定义了一组异常类，分别定义在4个头文件中：</p><ol><li>exception头文件定义了最通用的异常类exception。它至报告异常发生，不提供任何额外信息。</li><li>stdexcept头文件定义了下表的几种异常类。</li><li>new头文件定义了bad_alloc异常类型12.1.2</li><li>type_info 定义了bad_cast异常类型19.2</li></ol><p><img src="/2018/11/04/statement/stdexcept.png" alt=""></p><p>exception、bad_alloc和bad_cast对象只能以默认初始化方式进行初始化；</p><p>而其他异常类型洽洽相反，因使用string对象或者c风格字符串初始化，并且不允许默认初始化方式。创建此类对象必须提供<strong>初始值</strong>，这个对象初始值是用于提示异常的文本信息。</p><p>异常类型值定义了一个名为what的成员函数，该函数没有任何参数，返回值是一个C风格字符串的const char*。对于其他无初始值的异常类型 what返回的内容由编译器决定。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;语句&quot;&gt;&lt;a href=&quot;#语句&quot; class=&quot;headerlink&quot; title=&quot;语句&quot;&gt;&lt;/a&gt;语句&lt;/h1&gt;&lt;h3 id=&quot;简单语句&quot;&gt;&lt;a href=&quot;#简单语句&quot; class=&quot;headerlink&quot; title=&quot;简单语句&quot;&gt;&lt;/a&gt;简单语句&lt;/h
      
    
    </summary>
    
      <category term="C++Primer笔记" scheme="http://yoursite.com/categories/C-Primer%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="statement" scheme="http://yoursite.com/tags/statement/"/>
    
      <category term="语句" scheme="http://yoursite.com/tags/%E8%AF%AD%E5%8F%A5/"/>
    
  </entry>
  
  <entry>
    <title>IO(流)</title>
    <link href="http://yoursite.com/2018/10/27/io/"/>
    <id>http://yoursite.com/2018/10/27/io/</id>
    <published>2018-10-27T13:04:42.000Z</published>
    <updated>2019-03-10T05:41:37.304Z</updated>
    
    <content type="html"><![CDATA[<p>ps：先是简单的介绍一下IO类、文件的输入输出以及string流。看到之后章节再记录拓展~</p><h1 id="IO库"><a href="#IO库" class="headerlink" title="IO库"></a>IO库</h1><h3 id="基本介绍："><a href="#基本介绍：" class="headerlink" title="基本介绍："></a>基本介绍：</h3><h4 id="include："><a href="#include：" class="headerlink" title="#include："></a><strong>#include：</strong></h4><p>#include指令用于添加头文件。通常情况下，它必须出现现在所有函数之外。一般将他放在源文件最开始的位置。</p><ul><li>#include &lt;&gt;:尖括号用于添加<strong>标准库头文件</strong></li><li>#include “”:双引号用于添加<strong>自己定义</strong>的头文件</li></ul><h4 id="lt-lt-、-gt-gt-左侧、右侧运算符"><a href="#lt-lt-、-gt-gt-左侧、右侧运算符" class="headerlink" title="&lt;&lt;、&gt;&gt;左侧、右侧运算符:"></a><strong>&lt;&lt;、&gt;&gt;左侧、右侧运算符:</strong></h4><p>&lt;&lt;左侧的对象必须是一个ostream对象，返回一个ostream对象。&gt;&gt;左侧的对象必须是一个istream对象，返回一个istream对象。</p><h4 id=""><a href="#" class="headerlink" title="::"></a><strong>::</strong></h4><p>作用域运算符::用来表示某个作用域。</p><h4 id="部分IO库设施："><a href="#部分IO库设施：" class="headerlink" title="部分IO库设施："></a>部分IO库设施：</h4><table><thead><tr><th>istream(输入流)</th><th>提供输入操作</th></tr></thead><tbody><tr><td>ostream(输出流)</td><td>提供输出操作</td></tr><tr><td>cin</td><td>从标准输入读取数据</td></tr><tr><td>cout</td><td>从标准输出写入数据</td></tr><tr><td>cerr</td><td>通常用于输出程序错误信息，写入到标准错误</td></tr><tr><td>运算符&gt;&gt;</td><td>用来从一个istream对象读取输入数据</td></tr><tr><td>运算符&lt;&lt;</td><td>用来从一个ostream对象写入输出数据</td></tr><tr><td>getline函数</td><td>从一个给定的istream读取一行数据存入一个给定的string对象中</td></tr></tbody></table><h3 id="IO类"><a href="#IO类" class="headerlink" title="IO类"></a>IO类</h3><p>为了继承不同种类的IO操作，标准库还定义了其他一些IO类型。分别定义在三个头文件中：</p><ol><li>iostream定义了用于读写流的基本类型。<ol><li>istream、wistream从流读取数据</li><li>ostream、wostream向流写入数据</li><li>iostream、wiostream读写流</li></ol></li><li><p>fstream定义了读写命名文件的类型</p><ol><li>ifstream、wifstream从文件读取数据</li><li>ofstream、wofstream向文件写入数据</li><li>iofstream、wiofstream读写文件</li></ol></li><li><p>sstream定义了读写内存string对象的类型</p><ol><li>istringstream、wistringstream从string读取数据</li><li>ostringstream、wostringstream向string写入数据</li><li>iostringstream、wiostringstream读写string</li></ol></li></ol><p>以上w开头是为了支持宽字符w_char类型的数据。wcin、wcout、wcerr对应cin、cout、cerr等等。</p><p><strong>而fstream和sstream都是继承iostream的</strong></p><h4 id="IO对象无法拷贝或赋值"><a href="#IO对象无法拷贝或赋值" class="headerlink" title="IO对象无法拷贝或赋值"></a>IO对象无法拷贝或赋值</h4><p>IO对象无法拷贝，因此不能将形参或者返回值定为流类型，但是可以定义为流的引用类型。</p><h4 id="流的条件状态"><a href="#流的条件状态" class="headerlink" title="流的条件状态"></a>流的条件状态</h4><p>IO操作有可能发生错误。有些是可以恢复的而有些是不可恢复的，因此下表列出了一些<strong>函数和标志</strong>来帮助我们访问和操纵 流的<strong>条件状态(condition state)</strong>：下表中strm是表示一种流类型(上表所列出的)，s表示一个流</p><table><thead><tr><th>strm:iostate</th><th>iostate是一种机器相关的类型，提供了表达条件状态的完整功能</th></tr></thead><tbody><tr><td>strm:badbit</td><td>用来指出流已崩溃/第四位</td></tr><tr><td>strm:failbit</td><td>用来指出一个IO操作失败/第三位</td></tr><tr><td>strm:eofbit</td><td>用来指出流到达了文件结束/第二位</td></tr><tr><td>strm:goodbit</td><td>用来指出流未处于错误状态/第1位(从右往左)</td></tr><tr><td>s.eof()</td><td>若流s的eofbit置位，则返回true</td></tr><tr><td>s.fail()</td><td>若failbit或badbit置位，则返回true</td></tr><tr><td>s.bad()</td><td>若badbit置位，返回true</td></tr><tr><td>s.good()</td><td>若s处于有效状态，则返回true</td></tr><tr><td>s.clear()</td><td>将流s中所有条件状态复位，将流状态置为有效。返回void</td></tr><tr><td>s.clear(flags)</td><td>根据给定flags标志位，将流s中对应状态置为有效。flags类型为strm::iostate，返回void</td></tr><tr><td>s.setstate(flags)</td><td>根据给定flags标志位，将流s中对应状态置位。flags类型为strm::iostate，返回void</td></tr><tr><td>s.rdstate()</td><td>返回流s的当前条件状态，返回类型为iostate</td></tr></tbody></table><p>例：如果在一个int类型中输入字符时，读操作就会失败。类似的输入一个文件结束符时。cin也会进入错误状态。</p><h4 id="查询流的状态"><a href="#查询流的状态" class="headerlink" title="查询流的状态"></a>查询流的状态</h4><p><strong>标准库定义的类型：</strong></p><p>上表中定义了4个iostate类型的constexpr值，表示特定的位模式。意思就是每一个值用一位二进制来表示，例如他们初始值为1110，右边第一位表示goodbit，第二位是eofbit…</p><p>badbit：表示系统级错误，不可恢复。</p><p>failbit：表示可以恢复的错误，例如期望读取int类型却读出了字符等错误。流可以被修正，能继续使用。</p><p>eofbit：如果达到文件结尾，eofbit和failbit都会被置位</p><p>goodbit：值为0表示流未发生错误</p><p>如果badbit、failbit、eofbit三个其中一个发生错误，则流检测状态的条件会失败。</p><p><strong>标准库定义的函数：</strong></p><p>good():在所有错误未置位的情况下返回true</p><p>bad、fail、eof 则在对应类型被置位下返回true。</p><p>此外在badbit被置位时fail也会返回true。因此使用good或fail是确定流总体状态的正确方法。实际上我们用的<strong>条件while(cin)就等于!fail()</strong></p><h4 id="管理条件状态"><a href="#管理条件状态" class="headerlink" title="管理条件状态"></a>管理条件状态</h4><p>clear() :将所有状态复位。</p><p>clear(flags)：将指定状态复位。flags是iostate类型。<strong>例：</strong></p><p>​    初始值1110.加入产生了错误导致failbit和badbit置位，iostate变成0010.如果想单独将failbit置位那么就需要传入0110。这时代码可写成clear(s.rdstate() &amp; ~s.failbit)</p><h4 id="管理输出缓冲"><a href="#管理输出缓冲" class="headerlink" title="管理输出缓冲"></a>管理输出缓冲</h4><p>每个输出流都管理一个缓冲区，用来保存程序读写的数据。有了缓冲机制，操作系统就可以将程序的多个输出操作组合成单一的系统级写操作。提升很大的性能。</p><p><strong>导致缓冲刷新的原因：</strong></p><ul><li>程序正常结束，作为main的return操作的一部分，缓冲刷新</li><li>缓冲区满的时候</li><li>可以使用操纵符endl来显式刷新</li><li>在每个输出操作之后，用操纵符unitbuf设置流的内部状态，来清空缓冲区。默认情况对cerr是设置unitbuf的。</li><li>一个输出流可以被关联到另一个流。在这种情况下，当读写被关联的流时，关联到的流缓冲区会被刷新。例如：cin和cerr都关联到cout。因此读cin或写cerr都会导致cout缓冲区被刷新。</li></ul><p><strong>刷新输出缓冲区：</strong></p><p>endl: 输出内容和一个换行，刷新缓冲区</p><p>flush:输出内容，刷新缓冲区</p><p>ends:出书内容和一个空字符，刷新缓冲区</p><p><strong>unitbuf操纵符：</strong></p><p>如果想每次输出后都刷新缓冲区可以使用unitbuf操纵符。它告诉流在每次写操作之后进行一次flush操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; unitbuf;<span class="comment">//所有输出操作后都会刷新缓冲区</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; nounitbuf;<span class="comment">//回到正常缓冲方式</span></span><br></pre></td></tr></table></figure><p><strong>关联输入输出流：</strong></p><p>一个输出流可以被关联到另一个流。在这种情况下，当读写被关联的流时，关联到的流缓冲区会被刷新。例如：cin和cerr都关联到cout。因此读cin或写cerr都会导致cout缓冲区被刷新。</p><p>NOTE:交互式系统通常关联输入流与输出流。这意味这所有输出都会在写入之前打印出来。</p><p><strong>tie：</strong>tie函数有两个版本：</p><ul><li>一个无参版本，返回指向输出流的指针。如果本对象关联一个输出流，返回的就是这个流的指针，否则未关联则返回空指针；</li><li>tie的第二个版本接受一个<strong>指向ostream</strong>的指针，将自己关联到此ostream，即：x.tie(&amp;o)将流x关联到o</li></ul><p>我们可以将istream关联到ostream也可以将ostream关联到ostream。每个流只能关联一个流，但是一个流可以被多个流关联。</p><h3 id="文件输入输出"><a href="#文件输入输出" class="headerlink" title="文件输入输出"></a>文件输入输出</h3><p>之前有说到，头文件<strong>fstream</strong>定义了三个类型来支持文件IO：ifstream从一个给定文件读取数据；ofstream向一个给定文件写入数据； fstream能读写文件。这三个类型的操作与之前一样，能用IO运算符(&lt;&lt;和&gt;&gt;)来读写文件，可用getline()来获取行数据。</p><p>除了继承自iostream类型的行为之外，它还定义了新的成员来管理文件流。如下：fstream是头文件fstream中定义的一个类型</p><table><thead><tr><th>fstream fstrm;</th><th>创建一个未绑定的文件流</th></tr></thead><tbody><tr><td>fstream fstrm(s);</td><td>创建一个fstream并打开名为s的文件(加后缀)。s可以是string或指向c风格字符串的指针。这些构造函数都是explicit的。默认文件模式mode依赖于fstream的类型</td></tr><tr><td>fstream fstrm(s, mode);</td><td>与前一个<strong>构造函数</strong>相似，但指定了mode</td></tr><tr><td>fstrm.open(s)</td><td>打开名为s的文件，并将文件与fstrm绑定。返回void</td></tr><tr><td>fstrm.close()</td><td>关闭与fstrm绑定的文件。返回void</td></tr><tr><td>fstrm.is_open()</td><td>返回一个bool值，指出与fstrm关联的文件是否成功打开并且未关闭</td></tr></tbody></table><p>上表中前三个是构造函数，用于创建一个文件流并且可以选择<strong>是否绑定文件</strong>以及打开文件的<strong>模式</strong>。</p><h4 id="使用文件流对象"><a href="#使用文件流对象" class="headerlink" title="使用文件流对象"></a>使用文件流对象</h4><p><strong>创建文件流：</strong></p><p>我们可以先定义一个文件流并且与文件相关联，也可以只先定义一个文件流对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">in</span><span class="params">(file.txt)</span></span>;<span class="comment">//构造一个ifstream并打开文件</span></span><br><span class="line">ofstream out;<span class="comment">//定义一个输出文件流未关联文件</span></span><br></pre></td></tr></table></figure><p>文件名可以是string对象，也可以是C风格字符数组。</p><p><strong>函数open和close：</strong></p><p>如果定义了一个空文件流对象，可以随后调用open来将它与文件相关联。比如上述输出文件流out：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">out.open(<span class="string">"file.txt"</span>);<span class="comment">//打开指定文件</span></span><br></pre></td></tr></table></figure><p>如果调用open失败，failbit会置位。</p><p><strong><u>自动构造和析构:</u></strong>如果将创建流定义在while里面，那么while的每一步都会创建与销毁文件流，当一个fstream对象被销毁的时候，会自动调用close函数。</p><h4 id="文件模式"><a href="#文件模式" class="headerlink" title="文件模式"></a>文件模式</h4><p>在上表中的第三个构造函数中有个mode参数，这是流关联的文件模式。在调用open打开文件时也可以，不论显示隐式 都会调用一种模式。</p><table><thead><tr><th>in</th><th>以读方式打开</th></tr></thead><tbody><tr><td>out</td><td>以写方式打开</td></tr><tr><td>app</td><td>每次<strong>写操作</strong>前均定位到文件末尾</td></tr><tr><td>ate</td><td>打开文件后立即定位到文件末尾</td></tr><tr><td>trunc</td><td>截断文件</td></tr><tr><td>binary</td><td>以二进制方式进行IO</td></tr></tbody></table><ul><li>只可以对ostream设定out模式</li><li>只可以对istream设定in模式</li><li>只有当out也被设定时才可以设定trunc模式</li><li>只要没有设定trunc就可以设定app模式。在app模式下没有设定out也会默认out模式。</li><li>默认情况下没有指定trunc，以out模式打开的文件也会被截断。如果要保留文件内容，必须指定app模式，或者同时指定in模式。</li><li>ate和binary模式可以用于任何类型的文件，并且能与其他模式组合使用。</li></ul><p>当不指定时，文件流使用默认的文件模式，ifstream是in模式；ofstream是out模式；fstream是in和out模式。</p><h4 id="以out打开会丢弃数据"><a href="#以out打开会丢弃数据" class="headerlink" title="以out打开会丢弃数据"></a>以out打开会丢弃数据</h4><p>当一个文件以out模式打开时，会被截断，文件的内容会被丢弃。阻止此行为的方法是指定app模式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ofstream <span class="title">out</span><span class="params">(<span class="string">"file.txt"</span>)</span></span>;<span class="comment">//隐含以输出模式打开并截断</span></span><br><span class="line"><span class="function">ofstream <span class="title">out2</span><span class="params">(<span class="string">"file.txt"</span>, ofstream::out)</span></span>;<span class="comment">//隐含截断文件</span></span><br><span class="line"><span class="function">ofstream <span class="title">out3</span><span class="params">(<span class="string">"file.txt"</span>, ofstream::out|ofstream::trunc)</span></span>;</span><br></pre></td></tr></table></figure><p>指定app模式则能保留文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ofstream <span class="title">app</span><span class="params">(<span class="string">"file.txt"</span>，ofstream::app)</span></span>;<span class="comment">//隐含为out模式</span></span><br><span class="line"><span class="function">ofstream <span class="title">app</span><span class="params">(<span class="string">"file.txt"</span>，ofstream::out | ofstream::app)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="string流"><a href="#string流" class="headerlink" title="string流"></a>string流</h3><p>类似的，sstream头文件定义了三个类型来支持内存IO：istringstream从string读取数据，ostringstream向string写入数据，stringstream可以读写数据。sstream除了继承来的操作，还定义了一些成员来管理string流。</p><table><thead><tr><th>sstream strm;</th><th>sstream是头文件sstream中定义的一个类型，strm是一个未绑定的stringstream对象</th></tr></thead><tbody><tr><td>sstream strm(s);</td><td>strm是一个sstream对象，保存string s的一个拷贝。此构造函数是explicit的</td></tr><tr><td>strm.str();</td><td>返回strm所保存的string的拷贝</td></tr><tr><td>strm.str(s);</td><td>将string s拷贝到strm中。返回void</td></tr></tbody></table><h4 id="使用istringstream"><a href="#使用istringstream" class="headerlink" title="使用istringstream"></a>使用istringstream</h4><p>当我们的某些工作是对整行文本进行处理，而其他的一些工作是处理行内的某个单词时，通常能用istringstream。</p><p><strong>定义：</strong></p><p>可以将一个istringstream与string对象绑定，也可以只定义一个istringstream。然后用str(s)方法绑定</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">istringstream</span> <span class="title">in</span><span class="params">(s)</span></span>;<span class="comment">//定义一个istringstream与string s绑定</span></span><br><span class="line"><span class="built_in">istringstream</span> in2;<span class="comment">//定义一个未绑定的流in2</span></span><br><span class="line">in2.str(s);<span class="comment">//将流in2与string s绑定</span></span><br></pre></td></tr></table></figure><p><strong>例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> line = <span class="string">"hello world"</span>, word;</span><br><span class="line"><span class="function"><span class="built_in">istringstream</span> <span class="title">in</span><span class="params">(line)</span></span>;</span><br><span class="line">in &gt;&gt; word;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; word &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h4 id="使用ostringstream"><a href="#使用ostringstream" class="headerlink" title="使用ostringstream"></a>使用ostringstream</h4><p>当我们逐步构造输出，希望最后一起打印时，ostringstream是很有用的。</p><p><strong>定义：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">ostringstream</span> <span class="title">out</span><span class="params">(s)</span></span>;<span class="comment">//定义一个ostringstream 并将s写入</span></span><br><span class="line"><span class="built_in">ostringstream</span> in2;<span class="comment">//定义ostringstream </span></span><br><span class="line">in2.str(s);<span class="comment">//将s写入内存中</span></span><br></pre></td></tr></table></figure><p><strong>例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">ostringstream</span> <span class="title">os</span><span class="params">(<span class="string">"hello world"</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; os.str();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ps：先是简单的介绍一下IO类、文件的输入输出以及string流。看到之后章节再记录拓展~&lt;/p&gt;
&lt;h1 id=&quot;IO库&quot;&gt;&lt;a href=&quot;#IO库&quot; class=&quot;headerlink&quot; title=&quot;IO库&quot;&gt;&lt;/a&gt;IO库&lt;/h1&gt;&lt;h3 id=&quot;基本介绍：&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="C++Primer笔记" scheme="http://yoursite.com/categories/C-Primer%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="IO" scheme="http://yoursite.com/tags/IO/"/>
    
      <category term="流" scheme="http://yoursite.com/tags/%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>标准库类型vector</title>
    <link href="http://yoursite.com/2018/10/23/vector/"/>
    <id>http://yoursite.com/2018/10/23/vector/</id>
    <published>2018-10-23T13:14:37.000Z</published>
    <updated>2019-03-10T05:40:44.469Z</updated>
    
    <content type="html"><![CDATA[<h1 id="标准库类型vector"><a href="#标准库类型vector" class="headerlink" title="标准库类型vector"></a>标准库类型vector</h1><p>vector表示对象的集合，其中所有对象的类型都相同。它是一个容器。</p><p>想要使用vector需要添加头文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span></span><br></pre></td></tr></table></figure><p>同时vector也是一个<strong>类模板</strong>,因此需要提供额外信息指定模板实例化成什么样的类。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec;<span class="comment">//ivec保存int类型的对象</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; file;<span class="comment">//该向量的元素是vector对象</span></span><br></pre></td></tr></table></figure><h3 id="vector的初始化"><a href="#vector的初始化" class="headerlink" title="vector的初始化"></a>vector的初始化</h3><p><strong>常用初始化vector对象的方法:</strong></p><table><thead><tr><th>vector<t> v1</t></th><th>v1是一个空vector，它潜在元素是T类型的，执行默认初始化</th></tr></thead><tbody><tr><td>vector<t> v2(v1)</t></td><td>v2中包含有v1所有元素的副本</td></tr><tr><td>vector<t> v2 = v1</t></td><td>等价于v2(v1)</td></tr><tr><td>vector<t> v3(n, val)</t></td><td>v3包含了n个重复的元素，每个元素的值都是val</td></tr><tr><td>vector<t> v4(n)</t></td><td>v4包含了n个重复的执行了值初始化的对象</td></tr><tr><td>vector<t> v5{a, b, c…}</t></td><td>v5包含了初始值个数的元素，每个元素都被赋予相应的初始值</td></tr><tr><td>vector<t> v5 = {a, b, c…}</t></td><td>等价于v5{a, b, c…}</td></tr></tbody></table><h4 id="列表初始化vector对象："><a href="#列表初始化vector对象：" class="headerlink" title="列表初始化vector对象："></a>列表初始化vector对象：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; articles = &#123;“a”, “an”, “the”&#125;; <span class="comment">//花括号</span></span><br></pre></td></tr></table></figure><h4 id="创建指定元素的数量："><a href="#创建指定元素的数量：" class="headerlink" title="创建指定元素的数量："></a>创建指定元素的数量：</h4><p>用vector对象容纳的<strong>元素数量</strong>，和<strong>元素统一初始值</strong>来初始化vector。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec(<span class="number">10</span>, <span class="number">-1</span>); <span class="comment">//10个int类型的元素，值都为-1</span></span><br></pre></td></tr></table></figure><h4 id="值初始化："><a href="#值初始化：" class="headerlink" title="值初始化："></a>值初始化：</h4><p>通常情况下，我们可以只提供vector元素的数量。那么库会创建一个<strong>值初始化</strong>的元素初值，由vector对象的类型决定。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec(<span class="number">10</span>);<span class="comment">//10个元素都是0</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; svec(<span class="number">10</span>);<span class="comment">//10个每个都是空的string对象</span></span><br></pre></td></tr></table></figure><p>这种初始化有两个限制：</p><ul><li>其一，有些类要求明确必须提供初始值(2.2.1)。</li><li>其二，只提供元素的数量而没有设定初始值只能用直接初始化,而不是拷贝初始化。</li></ul><h4 id="初始化的圆括号-，与花括号"><a href="#初始化的圆括号-，与花括号" class="headerlink" title="初始化的圆括号()，与花括号{}"></a>初始化的圆括号()，与花括号{}</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1(<span class="number">10</span>);<span class="comment">//v1有10个元素，每个都是0 </span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2&#123;<span class="number">10</span>&#125;;<span class="comment">//v2有1个元素是10  </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v3(<span class="number">10</span>, <span class="number">1</span>)<span class="comment">//v3 10个元素每个是1</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v4&#123;<span class="number">10</span>,<span class="number">1</span>&#125; <span class="comment">//v3 有个2个元素。10和1</span></span><br></pre></td></tr></table></figure><p> 可以说：</p><ol><li>如果用的是圆括号，可以说提供的值是用来构造vector对象。</li><li>如果是用花括号，首先是表述为想用列表初始化该vector对象，除非当提供的值无法进行列表初始化，那么它会考虑其他初始化方式，比如下列：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; svec&#123;<span class="number">10</span>, “hi”&#125;;<span class="comment">//花括号，会初始化为10个”hi”</span></span><br></pre></td></tr></table></figure><p>上述代码可以看出，int值无法初始化string对象，所以当编译器确定了无法执行列表初始化后，会尝试用默认值初始化vector对象。</p><h3 id="vector的操作："><a href="#vector的操作：" class="headerlink" title="vector的操作："></a>vector的操作：</h3><p><strong>vector支持的操作：</strong></p><table><thead><tr><th>v.empty()</th><th>如果v中不含有元素，返回真；否则返回假</th></tr></thead><tbody><tr><td>v.size()</td><td>返回v中元素的个数</td></tr><tr><td>v.push_back(t)</td><td>向v的尾端添加一个值为t的元素</td></tr><tr><td>v[n]</td><td>返回v中第n个位置上元素的引用</td></tr><tr><td>v1 = v2</td><td>用v2中元素拷贝替换v1中元素</td></tr><tr><td>v1 = {a, b, c…}</td><td>用列表中元素拷贝替换v1中元素</td></tr><tr><td>v1 == v2、 v1 != v2</td><td>v1和v2相等 当且仅当 它们的元素数量相同且对应位置元素值相同</td></tr><tr><td>&lt;, &lt;=, &gt;, &gt;=</td><td>以字典顺序比较</td></tr></tbody></table><h4 id="v-size-："><a href="#v-size-：" class="headerlink" title="v.size()："></a>v.size()：</h4><p>类似string类，v.size()返回的是 <strong>vector<t>::size_type</t></strong>类型</p><h4 id="vector不能用下标形式添加元素："><a href="#vector不能用下标形式添加元素：" class="headerlink" title="vector不能用下标形式添加元素："></a><strong>vector不能用下标形式添加元素：</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec;<span class="comment">//空vector</span></span><br><span class="line">ivec[<span class="number">0</span>] = <span class="number">1</span>;<span class="comment">//错误，ivec不包含任何元素</span></span><br></pre></td></tr></table></figure><p>空的vector不包含任何元素，自然不能用下标访问不存在的元素，正确的方法是用push_back。 否则会造成缓冲区溢出(buffer overflow)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;标准库类型vector&quot;&gt;&lt;a href=&quot;#标准库类型vector&quot; class=&quot;headerlink&quot; title=&quot;标准库类型vector&quot;&gt;&lt;/a&gt;标准库类型vector&lt;/h1&gt;&lt;p&gt;vector表示对象的集合，其中所有对象的类型都相同。它是一个容器。
      
    
    </summary>
    
      <category term="C++Primer笔记" scheme="http://yoursite.com/categories/C-Primer%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="vector" scheme="http://yoursite.com/tags/vector/"/>
    
  </entry>
  
  <entry>
    <title>标准库类型string</title>
    <link href="http://yoursite.com/2018/10/20/string/"/>
    <id>http://yoursite.com/2018/10/20/string/</id>
    <published>2018-10-19T22:44:44.000Z</published>
    <updated>2019-03-10T05:41:03.151Z</updated>
    
    <content type="html"><![CDATA[<h1 id="标准库类型string"><a href="#标准库类型string" class="headerlink" title="标准库类型string"></a>标准库类型string</h1><p>string表示可变长的字符序列。</p><ul><li>使用string类型必须首先包含头文件</li><li>作为标准库的一部分，string定义在命名空间std中。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>一个类可以定义很多种初始化对象的方式，但是这些方式之间必须有所区别：</p><ul><li>或者是初始值数量不同</li><li>或者是初始值类型不同</li></ul><p><strong>以下是初始化string的方式：</strong></p><ol><li>默认初始化</li></ol><p>通过默认的方式初始化一个string对象，得到的s1是个空字符串。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s1;<span class="comment">//默认初始化</span></span><br></pre></td></tr></table></figure><ol start="2"><li>用另一个string进行初始化</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(s1)</span></span>;<span class="comment">//s2是s1的副本</span></span><br><span class="line"><span class="built_in">string</span> s2 = s1;<span class="comment">//等价于s2(s1)</span></span><br></pre></td></tr></table></figure><ol start="3"><li>给定一个字符串字面值</li></ol><p>则该字面值中除了最后一个空字符外其他所有的字符都被拷贝到新创建的string对象中去。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s3</span><span class="params">(“value”)</span></span>;<span class="comment">//s3是字面值”value”的副本，除了字面值最后一个空字符外</span></span><br><span class="line"><span class="built_in">string</span> s3 = “value”;<span class="comment">//同上</span></span><br></pre></td></tr></table></figure><ol start="4"><li>给定一个数字和一个字符</li></ol><p>则string对象的内容是给定字符连续重复若干次后得到的序列。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s4</span><span class="params">(n,’c’)</span></span>;<span class="comment">//把s4初始化为由连续n个字符c组成的串</span></span><br></pre></td></tr></table></figure><h4 id="直接初始化和拷贝初始化"><a href="#直接初始化和拷贝初始化" class="headerlink" title="直接初始化和拷贝初始化"></a>直接初始化和拷贝初始化</h4><p>像用“=”等号初始化一个变量是拷贝初始化，反之则是直接初始化。</p><p>而像上面的s4那样初始化用到的值有多个，一般来说只能使用直接初始化的方式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s5 = <span class="string">"hi"</span>;<span class="comment">//拷贝初始化</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s6</span><span class="params">(<span class="string">"hi"</span>)</span></span>;<span class="comment">//直接初始化</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s7</span><span class="params">(<span class="number">10</span>, <span class="string">'C'</span>)</span></span>;<span class="comment">//直接初始化，s7为cccccccccc</span></span><br></pre></td></tr></table></figure><h4 id="string对象上的操作"><a href="#string对象上的操作" class="headerlink" title="string对象上的操作:"></a><strong>string对象上的操作:</strong></h4><p>以下是大多数操作：</p><table><thead><tr><th>os&lt;&lt;s</th><th>将s写到输出流os中，返回os</th></tr></thead><tbody><tr><td>is&gt;&gt;s</td><td>将is中读出字符串赋给s，字符串以<strong>空白分隔</strong>，返回is</td></tr><tr><td>getline(is,s)</td><td>从is中读取一行赋给s，返回is</td></tr><tr><td>s.empty()</td><td>s为空返回true，否则返回false</td></tr><tr><td>s.size()</td><td>返回s中字符的个数</td></tr><tr><td>s[n]</td><td>返回s中第n个字符的引用，位置从0计起</td></tr><tr><td>s1+s2</td><td>返回s1和s2连接后的结果</td></tr><tr><td>s1=s2</td><td>用s2的副本代替s1中原来的字符</td></tr><tr><td>s1==s2</td><td>如果s1和s2中所含的字符完全一样，则他们相等</td></tr><tr><td>s1!=s2</td><td>与上相反</td></tr><tr><td>&lt;,&lt;=,&gt;,&gt;=</td><td>利用字符在字典中的顺序进行比较，对大小写敏感</td></tr></tbody></table><h4 id="读写string对象"><a href="#读写string对象" class="headerlink" title="读写string对象"></a>读写string对象</h4><p>可以使用io操作符读写string对象:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s1, s2;<span class="comment">//空字符串</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s1 &gt;&gt; s2;<span class="comment">//将string对象读入s，遇到空白停止</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; s1 &lt;&lt; s2 &lt;&lt;<span class="built_in">endl</span>;<span class="comment">//输出s</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在执行读取操作时，string对象会自动<strong>忽略开头的空白</strong>(即空格符、换行符、制表符等)并从第一个真正的字符读起，直到<strong>遇见下一处空白</strong>。</p><p>例如输入”    hello world    “，那么输出会是”hello”和”world”，不会有空白。</p><h5 id="使用getline-读取一整行："><a href="#使用getline-读取一整行：" class="headerlink" title="使用getline()读取一整行："></a>使用getline()读取一整行：</h5><p>有时我们希望最终得到的字符串中保留输入时的空白符，那么用getline()代替原来的&gt;&gt;运算符。他的参数是一个输入流和一个string对象，函数从给定的输入流中读入内容，直到遇到换行符位置(换行符也读入)，然后将内容存到string(不存换行符)。随后返回它的流参数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> line;</span><br><span class="line">getline(<span class="built_in">cin</span>, line);<span class="comment">//读入一整行</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; line &lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h5 id="string-size-type类型："><a href="#string-size-type类型：" class="headerlink" title="string::size_type类型："></a>string::size_type类型：</h5><p>对于size()函数来说，返回一个int类型或者unsigned似乎都是合情合理的。但是size函数返回的是一个string::size_type类型的值。</p><p>string类以及其他大多数标准库类型都定义了几种配套的类型，为了体现标准库类型与机器无关。</p><p>它是一个<strong>无符号类型</strong>的值，而且<strong>足够存放</strong>下任何string对象的大小。</p><h5 id="比较string对象："><a href="#比较string对象：" class="headerlink" title="比较string对象："></a>比较string对象：</h5><p>相等性运算符(== 、!=)和关系运算符(&lt;、&lt;=、&gt;、&gt;=)都按照字典顺序：</p><ol><li><p>如果两个string对象的长度不同，而且较短string对象的每个字符都与较长string对象对应位置上字符相同，就说较短string小于较长string</p></li><li><p>如果两个string对象在某些对应位置上不一致，则string对象比较的结果其实是string对象中第一对不同字符比较的结果</p></li></ol><p>例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str = <span class="string">"Hello"</span>;</span><br><span class="line"><span class="built_in">string</span> phrase = <span class="string">"Hello World"</span>;</span><br><span class="line"><span class="built_in">string</span> slang = <span class="string">"Hiya"</span>;</span><br></pre></td></tr></table></figure><p>根据规则1，str&lt;phrase。根据规则2, slang&gt;phrase 也 &gt;str。</p><h5 id="字面值和string对象相加："><a href="#字面值和string对象相加：" class="headerlink" title="字面值和string对象相加："></a>字面值和string对象相加：</h5><p>标准库允许把字符字面值和字符串字面值转换成string对象。但必须确保每个加法运算符(+)两侧运算对象至少有一个是string：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s3 = s1 + <span class="string">"value"</span>;<span class="comment">//正确 </span></span><br><span class="line"><span class="built_in">string</span> s4 = <span class="string">"value"</span> + <span class="string">","</span>;<span class="comment">//错误 两个都不是string</span></span><br><span class="line"><span class="built_in">string</span> s5 = s1 + <span class="string">"value"</span> + <span class="string">","</span> + <span class="string">"dog"</span>; <span class="comment">//正确，每个加法都有一个string</span></span><br><span class="line"><span class="built_in">string</span> s6 = <span class="string">"value"</span> + <span class="string">","</span> + s1;<span class="comment">//错误，不能把字面值相加</span></span><br></pre></td></tr></table></figure><p><strong><u>注意</u>：字符串字面值与string是不同的类型。</strong></p><h5 id="string处理字符的一些函数"><a href="#string处理字符的一些函数" class="headerlink" title="string处理字符的一些函数:"></a>string处理字符的一些函数:</h5><p><strong>表:cctype头文件的函数</strong></p><table><thead><tr><th>isalnum(c)</th><th>当c是字母或数字时为真</th></tr></thead><tbody><tr><td>isalpha(c)</td><td>当c是字母时为真</td></tr><tr><td>iscntrl(c)</td><td>当c是控制字符为真</td></tr><tr><td>isdigit(c)</td><td>当c是数字时为真</td></tr><tr><td>isgraph(c)</td><td>当c不是空格但可打印时为真</td></tr><tr><td>islower(c)</td><td>当c是小写字母时为真</td></tr><tr><td>isprint(c)</td><td>当c是可打印字符时为真(即c是空格或c具有可视形式)</td></tr><tr><td>ispunct(c)</td><td>当c是标点符号时为真(即c不是控制字符、数字、字母、可打印空白中的一种)</td></tr><tr><td>isspace(c)</td><td>当c是空白时为真(即c是空格、横向制表符、纵向制表符、回车符、换行符、进纸符中的一种)</td></tr><tr><td>isupper(c)</td><td>当c是大写字母时为真</td></tr><tr><td>isxdigit(c)</td><td>当c是十六进制数字时为真</td></tr><tr><td>tolower(c)</td><td>如果c是大写字母，输出对应的小写字母；否则原样输出c</td></tr><tr><td>toupper(c)</td><td>如果c是小写字母，输出对应的大写字母；否则原样输出c</td></tr></tbody></table><p><strong><u>建议</u>使用c++的兼容c的标准库头文件</strong>。c语言头文件为name.h而c++则将命名为cname。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;标准库类型string&quot;&gt;&lt;a href=&quot;#标准库类型string&quot; class=&quot;headerlink&quot; title=&quot;标准库类型string&quot;&gt;&lt;/a&gt;标准库类型string&lt;/h1&gt;&lt;p&gt;string表示可变长的字符序列。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用s
      
    
    </summary>
    
      <category term="C++Primer笔记" scheme="http://yoursite.com/categories/C-Primer%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="string" scheme="http://yoursite.com/tags/string/"/>
    
  </entry>
  
  <entry>
    <title>变量、基本类型和类型别名</title>
    <link href="http://yoursite.com/2018/10/19/variable-type/"/>
    <id>http://yoursite.com/2018/10/19/variable-type/</id>
    <published>2018-10-19T14:32:03.000Z</published>
    <updated>2019-03-10T05:40:51.473Z</updated>
    
    <content type="html"><![CDATA[<h1 id="变量、基本类型和类型别名"><a href="#变量、基本类型和类型别名" class="headerlink" title="变量、基本类型和类型别名"></a><strong>变量、基本类型和类型别名</strong></h1><p><strong>任何编程语言都具备一组公共语法特征，基本特征包括</strong>：</p><ul><li>整型、字符型等内置类型</li><li>变量，用来为对象命名</li><li>表达式和语句，用于操纵上述数据类型的具体值</li><li>if或while等控制结构，这些结构允许我们有选择的执行一些语句。</li><li>函数，用于定义可供随时调用的计算单元</li></ul><p><strong>大多数变成语言通过两种方式来进一步补充其基本特征</strong>：</p><ol><li>赋予程序员自定义数据类型的权利，从而实现扩展</li><li>将一些有用的功能封装成库函数提供使用</li></ol><h2 id="基本内置类型"><a href="#基本内置类型" class="headerlink" title="基本内置类型"></a>基本内置类型</h2><p>C++定义了一套包括算术类型(arithmetic type)和空类型(void)在内的基本数据类型。其中算术类型包括字符、整型数、布尔值和浮点数。</p><h3 id="C-基本类型大小"><a href="#C-基本类型大小" class="headerlink" title="C++基本类型大小"></a>C++基本类型大小</h3><p>int，long int，short int的宽度都可能随编译器而异。但有几条铁定的原则（ANSI/ISO制订的）：</p><ul><li>sizeof(short int) &lt;= sizeof(int)</li><li>sizeof(int) &lt;= sizeof(long int)</li><li>short int至少应为16位（2字节）</li><li>long int至少应为32位。</li></ul><p><strong>表：c++算数类型</strong></p><table><thead><tr><th>类型</th><th>含义</th><th>最小尺寸</th></tr></thead><tbody><tr><td>bool</td><td>布尔类型(true,false)</td><td>未定义</td></tr><tr><td>char</td><td>字符</td><td>8位</td></tr><tr><td>wchar_t</td><td>宽字符</td><td>16位</td></tr><tr><td>char16_t</td><td>Unicode字符</td><td>16位</td></tr><tr><td>char32_t</td><td>Unicode字符</td><td>32位</td></tr><tr><td>short</td><td>短整型</td><td>16位</td></tr><tr><td>int</td><td>整型</td><td>16位</td></tr><tr><td>long</td><td>长整型</td><td>32位</td></tr><tr><td>long long</td><td>长整型</td><td>64位</td></tr><tr><td>float</td><td>单精度浮点数</td><td>6位有效数字</td></tr><tr><td>double</td><td>双精度浮点数</td><td>10位有效数字</td></tr><tr><td>long double</td><td>扩展进度浮点数</td><td>10位有效数字</td></tr></tbody></table><p>c++标准制定了一个浮点数有效位数的最小值，然而大多数编译器实现了更高的进度。通常float以1个字节(32位)来表示，double以2个字节表示，long double以3或4个字节表示。</p><h4 id="带符号和不带符号类型"><a href="#带符号和不带符号类型" class="headerlink" title="带符号和不带符号类型"></a>带符号和不带符号类型</h4><p>除去布尔型和扩展的字符型之外，其他可以划分为带符号的(signed)和不带符号的(unsigned)。带符号可表示正数、负数或0，无符号仅能表示大于等于0的值。</p><p>类型int、short、long、long long都是带符号的，在前添加unsigned就是不带符号的类型，unsigned int可以缩写为unsigned。</p><p>与其他整型不同 char被分为三种 char 、signed char、unsigned char。尽管字符型有3种但是字符的表现形式只有两种：带符号和无符号。类型char会表现为以上两种，具体由编译器决定。</p><p>例：8bit的signed char表示范围定为-128~127。</p><p><u><strong>建议：选择类型</strong></u></p><ul><li>当明确数值为正时，选用无符号类型</li><li>使用int执行整数运算。在应用中，short常常太小而long一般和int一样的尺寸。如果数值超过了int表示范围。选用long long</li><li>算数表达式中不要使用char 或 bool，只有在存放字符或布尔时使用它们。因为类型char在一些机器上是有符号而另一些是无符号，容易出问题。如果需要使用一个不大的整数明确是unsigned char 还是 signed char。</li><li>执行浮点数运算选用double，因为float通常精度不够而且双精度浮点数和单精度浮点数计算代价相差无几。事实上对于某些机器来说双精度运算更快。</li></ul><h3 id="字面值常量（literal）"><a href="#字面值常量（literal）" class="headerlink" title="字面值常量（literal）"></a>字面值常量（literal）</h3><p>一个形如42的值被称作<strong>字面值常量</strong>，这样的值一望而知。每个字面值常量都对应一种数据类型，由它的形式和值决定。</p><h4 id="整数和浮点型字面值："><a href="#整数和浮点型字面值：" class="headerlink" title="整数和浮点型字面值："></a><strong>整数和浮点型字面值：</strong></h4><p> 整型字面值写成 十进制、八进制、十六进制。以0开头的整数代表八进制数，以0x、0X代表十六进制。例如：</p><p> 20  (十进制 )             024 (八进制)             0x14 (十六进制)</p><p>整型字面值的数据类型由他的值和符号决定。默认情况，十进制字面值带符号数，八进制和十六进制带符号不带符号都可能。十进制是int、long、long long中能容纳下当前值的最小尺寸（例如三者最小是int）。八进制和十六进制是int 、unsigned int、…unsigned long long 中容纳下当前值的最小尺寸。如果一个字面值与之关联的最大数据类型都放不下则产生错误。short无字面值。</p><p>负号字面值只是 字面值取反。例如-42，负号不在字面值内，它的作用仅仅是对字面值取负值而已。</p><p>浮点数字面值表示为 小数或带e的科学计数法的指数。默认是double</p><h4 id="字符和字符串字面值："><a href="#字符和字符串字面值：" class="headerlink" title="字符和字符串字面值："></a>字符和字符串字面值：</h4><p>字符：‘a’</p><p>字符串：“hello”</p><p>字符串字面值是由常量字符组成的数组，<strong>最后有个‘\0’空字符</strong>。如果两个字符串字面值由空格、缩进、换行符分隔，实际上是一个字符串。</p><h4 id="布尔和指针字面值："><a href="#布尔和指针字面值：" class="headerlink" title="布尔和指针字面值："></a>布尔和指针字面值：</h4><p>布尔：true、false</p><p>指针：nullptr</p><h4 id="转义序列："><a href="#转义序列：" class="headerlink" title="转义序列："></a>转义序列：</h4><p>有两类字符程序员不能直接使用：</p><ol><li>不可打印的字符，如退格或其他控制字符</li><li>在c++语言中含有特殊含义的字符（引号、问号等）</li></ol><p>这时候就需要用到转义序列。</p><table><thead><tr><th>换行符</th><th>\n</th><th>横向制表符</th><th style="text-align:left">\t</th><th>报警符</th><th>\a</th></tr></thead><tbody><tr><td><strong>纵向制表符</strong></td><td><strong>\v</strong></td><td><strong>退格符</strong></td><td style="text-align:left">\b</td><td>双引号</td><td>\“</td></tr><tr><td><strong>反斜线</strong></td><td>\ \</td><td>问号</td><td style="text-align:left">\?</td><td><strong>单引号</strong></td><td>\‘</td></tr><tr><td><strong>回车符</strong></td><td><strong>\r</strong></td><td><strong>进纸符</strong></td><td style="text-align:left">\f</td><td></td></tr></tbody></table><p>也可以用泛化的转义序列，有下两种形式：</p><ol><li>\x 后紧跟1个或多个十六进制数字（一般超过8位的十六进制字符都是与下表中的某个前缀开头的扩展字符集一起使用的）</li><li>\ 后紧跟1~3个八进制数字</li></ol><h4 id="指定字面值的类型："><a href="#指定字面值的类型：" class="headerlink" title="指定字面值的类型："></a>指定字面值的类型：</h4><p><strong>表：字符和字符串字面值：</strong></p><table><thead><tr><th>前缀</th><th>含义</th><th>类型</th></tr></thead><tbody><tr><td>u</td><td>Unicode16字符</td><td>char16_t</td></tr><tr><td>U</td><td>Unicode32字符</td><td>char32_t</td></tr><tr><td>L</td><td>宽字符</td><td>wchar_t</td></tr><tr><td>u8</td><td>UTF-8（仅用于字符串字面常量）</td><td>char</td></tr></tbody></table><p><strong>表：整型字面值</strong>                            </p><table><thead><tr><th>后缀</th><th>最小匹配类型</th></tr></thead><tbody><tr><td>u or U</td><td>unsigned</td></tr><tr><td>l or L</td><td>long</td></tr><tr><td>ll or LL</td><td>long long</td></tr></tbody></table><p><strong>表：浮点型字面值</strong></p><table><thead><tr><th>后缀</th><th>最小匹配类型</th></tr></thead><tbody><tr><td>f or F</td><td>float</td></tr><tr><td>l or L</td><td>long double</td></tr></tbody></table><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量提供一个具名的、可供程序操作的存储空间。C++中的每个变量都有其数据类型，数据类型决定着变量所占空间的大小和布局方式、该空间存储值的范围，以及变量能参与的运算。</p><h4 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h4><p>变量定义的基本形式：类型说明符 变量名，变量名；</p><p>例：int a=0,b;</p><h4 id="变量初始化"><a href="#变量初始化" class="headerlink" title="变量初始化"></a>变量初始化</h4><p>初始化的含义是创建变量时赋予一个初始值。而赋值这是把对象的当前值擦除，用一个新值代替。</p><ol><li>列表初始化</li><li>默认初始化: 如果定义变量时没有指定初值，则变量被<strong>默认初始化</strong>。内置类型在函数体外定义的话初始化为0， 函数体内则不被初始化. string 在函数内外都是默认为空字符串</li></ol><h4 id="变量的声明与定义（extern关键字）"><a href="#变量的声明与定义（extern关键字）" class="headerlink" title="变量的声明与定义（extern关键字）"></a>变量的声明与定义（extern关键字）</h4><p>C++语言支持分离式编译机制，该机制允许每个文件独立编译。为了支持分离时编译，C++将声明与定义区分开来。<strong>声明</strong>使得名字为程序所知，<strong>定义</strong>创建与名字相关联的实体。</p><p>定义区别于声明是定义除了规定了变量的类型和名字，还会申请存储空间与赋初始值。</p><p>在变量名前加关键字(extern)是声明但不要显示地初始化。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> i; <span class="comment">//声明非定义</span></span><br><span class="line"><span class="keyword">int</span> i ; <span class="comment">//声明且定义</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> i = <span class="number">2</span>; <span class="comment">//定义</span></span><br></pre></td></tr></table></figure><p>变量只能被定义一次，但可以被多次声明。在函数内部如果试图初始化一个extern关键字标记的变量会引发错误。</p><h4 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h4><p>标识符由字母数字下划线组成，必须以字母下划线开始，对长度无限制大小写敏感，不得使用c++关键字，不得连续两个下划线或下划线后加大写字母。</p><p><img src="/2018/10/19/variable-type/identifier.png" alt="c++关键字"></p><h4 id="作用域（scope）："><a href="#作用域（scope）：" class="headerlink" title="作用域（scope）："></a><strong>作用域（scope）：</strong></h4><p>作用域是程序的一部分，C++语言中大多数作用域都以花括号分隔。</p><p>同一个名字在不同的作用域中可能指向不同的实体。名字的有效区域始于名字的声明语句，以声明语句所在的作用域末端为结束。</p><p>外层作用域的变量能被能层作用域使用，当内层同样定义了一个相同的变量时会覆盖外层的变量，如需使用则要显示的调用，用<strong>作用域符号</strong>   “<strong>::</strong>“</p><h3 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h3><p>复合类型是指基于其他类型定义的类型。最常见的两种是<strong>引用</strong>和<strong>指针</strong>。</p><h4 id="复合类型的声明"><a href="#复合类型的声明" class="headerlink" title="复合类型的声明"></a>复合类型的声明</h4><p>变量的定义包括一个基本数据类型和一组声明符。在一条定义语句中，基本数据类型只有一个但是声明符的不同可以定义出不同类型的变量。</p><p>例：int i = 1024, *p = &amp;i, &amp;r = i;        //i是一个int数， p是int型指针， r是int型引用</p><h4 id="指针和引用的区别："><a href="#指针和引用的区别：" class="headerlink" title="指针和引用的区别："></a><strong>指针和引用的区别：</strong></h4><ol><li>指针指向内存中的某个对象，引用直接绑定对象。</li><li>指针本身是一个对象，允许指针赋值拷贝，在生命周期内可以指向不同的对象；引用不是对象，无法令引用重新绑定到其他对象。</li><li>指针无须在定义时赋初值，和其他内置类型一样，在块作用域内如果没有被初始化则将拥有一个不确定的值；引用则必须在定义时赋初值。</li></ol><h3 id="类型的处理"><a href="#类型的处理" class="headerlink" title="类型的处理"></a>类型的处理</h3><h4 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h4><p>类型别名用于简化一些复杂的类型名字。有typedef (类型别名)和 using (别名声明)两种方法。</p><p><strong>typedef：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> wages;<span class="comment">//wages是double的同义词</span></span><br><span class="line"><span class="keyword">typedef</span> wages base, *p;<span class="comment">//base是double的同义词，p是double*的同义词</span></span><br></pre></td></tr></table></figure><p><strong>using:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> db = <span class="keyword">double</span>;<span class="comment">//db是double的同义词</span></span><br></pre></td></tr></table></figure><p><strong><u>注意</u>的是某个类型别名指代的是符合类型或常量，那么用到声明语句就会产生意想不到的后果。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *pstring;</span><br><span class="line"><span class="keyword">const</span> pstring cstr = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>上面定义了pstring为char*类型，而const是对给定类型的修饰。所以const是修饰指针类型，cstr则是指向char的常量指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *cstr = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>而这处const修饰的是char，则cstr是指向常量char的指针。</p><h4 id="auto类型说明符"><a href="#auto类型说明符" class="headerlink" title="auto类型说明符"></a>auto类型说明符</h4><p>auto 类型说明符可以让编译器通过初始值去推算类型。因此auto定义的变量必须有初始值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> item = val1 + val2;<span class="comment">//val1、val2相加的结果推出item的类型</span></span><br></pre></td></tr></table></figure><p>使用auto也能在一条语句中声明多个变量。但是一条声明语句只能有一个基本数据类型，所以语句中变量的初始基本类型都必须一样。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> i = <span class="number">0</span>, *p = &amp;i;<span class="comment">//正确：i是整数、p是整型指针</span></span><br><span class="line"><span class="keyword">auto</span> sz = <span class="number">0</span>, pi = <span class="number">3.14</span>;<span class="comment">//错误：sz和pi的类型不一致</span></span><br></pre></td></tr></table></figure><p><strong>编译器推断出来的auto类型有时候和初始值的类型并不完全一样。</strong></p><p>例如<strong>引用</strong>，编译器会以引用对象的类型来作为auto的类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, r = &amp;i;</span><br><span class="line"><span class="keyword">auto</span> a = r;<span class="comment">//a是一个int类型的整数</span></span><br></pre></td></tr></table></figure><p>其次一般会忽略掉顶层const，而底层const会保留下来:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = i;</span><br><span class="line"><span class="keyword">auto</span> b = ci;<span class="comment">//b是整数(ci的顶层const被忽略)</span></span><br><span class="line"><span class="keyword">auto</span> c = &amp;i;<span class="comment">//c是整型指针(整数的地址就是指向整数的指针)</span></span><br><span class="line"><span class="keyword">auto</span> d = &amp;ci; <span class="comment">//d是指向整数常量的指针(对常量对象取地址是底层const)</span></span><br></pre></td></tr></table></figure><p>如果希望推出的是顶层const则需要明确定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> e = ci；</span><br></pre></td></tr></table></figure><h4 id="decltype类型指示符"><a href="#decltype类型指示符" class="headerlink" title="decltype类型指示符:"></a><strong>decltype类型指示符:</strong></h4><p>decltype说明符能从表达式的类型推断出要定义的变量的类型。在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(f()) sum = x;<span class="comment">//sum的类型就是函数f的返回类型</span></span><br></pre></td></tr></table></figure><p>decltype处理顶层const与auto有些不同。</p><p>如果decltype使用的表达式是一个变量，则decltype返回的类型包括<strong>顶层const</strong>和<strong>引用</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">0</span>, &amp;cj = ci;</span><br><span class="line"><span class="keyword">decltype</span>(ci) x = <span class="number">0</span>;<span class="comment">//x的类型是const int</span></span><br><span class="line"><span class="keyword">decltype</span>(cj) y = x;<span class="comment">//y的类型是const int&amp;，y绑定到变量x</span></span><br><span class="line"><span class="keyword">decltype</span>(cj) z;<span class="comment">//错误，z是引用，必须初始化</span></span><br></pre></td></tr></table></figure><p><strong>需要指出的是，引用从来都是作为所指对象的同义词出现，只有用在decltype处是个例外。</strong></p><p>如果decltype使用的表达式不是一个变量，则decltype返回表达式结果对应的类型：</p><p>如果表达式求值的结果是一个<strong>左值</strong>(参看左值与右值)，那么decltype返回的是一个引用类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>, *p = &amp;i, &amp;r = i;</span><br><span class="line"><span class="keyword">decltype</span>(r + <span class="number">0</span>) b;<span class="comment">//正确：加法的结果是int，因此b是一个int</span></span><br><span class="line"><span class="keyword">decltype</span>(*p) c;<span class="comment">//错误：c是int&amp;，必须初始化</span></span><br></pre></td></tr></table></figure><p>解释一下上面代码。因为r是一个引用，因此decltype(r)的结果是引用类型，如果想让结果是r所指的类型，可以把r作为表达式的一部分。显然这个表达式的结果是一个具体值。</p><p>而解引用操作得到的结果是一个左值，因此decltype(*p)是一个引用类型。</p><p>decltype的一个注意的点是：如果decltype所用的表达式是一个变量名加上了一层或多层括号，编译器就会将变量认为是表达式。而变量是一种可以作为赋值语句左值的特殊表达式。所以decltype得到的结果会是引用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>((i)) d;<span class="comment">//错误：d是int &amp;,必须初始化</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;变量、基本类型和类型别名&quot;&gt;&lt;a href=&quot;#变量、基本类型和类型别名&quot; class=&quot;headerlink&quot; title=&quot;变量、基本类型和类型别名&quot;&gt;&lt;/a&gt;&lt;strong&gt;变量、基本类型和类型别名&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;任何编程语
      
    
    </summary>
    
      <category term="C++Primer笔记" scheme="http://yoursite.com/categories/C-Primer%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="变量" scheme="http://yoursite.com/tags/%E5%8F%98%E9%87%8F/"/>
    
      <category term="基本类型" scheme="http://yoursite.com/tags/%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/"/>
    
      <category term="auto" scheme="http://yoursite.com/tags/auto/"/>
    
      <category term="decltype" scheme="http://yoursite.com/tags/decltype/"/>
    
      <category term="typedef" scheme="http://yoursite.com/tags/typedef/"/>
    
      <category term="using" scheme="http://yoursite.com/tags/using/"/>
    
  </entry>
  
  <entry>
    <title>GUN编译器</title>
    <link href="http://yoursite.com/2018/10/18/gun-compile/"/>
    <id>http://yoursite.com/2018/10/18/gun-compile/</id>
    <published>2018-10-18T15:11:44.000Z</published>
    <updated>2019-03-10T05:41:55.964Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GUN编译器"><a href="#GUN编译器" class="headerlink" title="GUN编译器"></a>GUN编译器</h2><p>编译器的一部分工作是检查文本错误：</p><ol><li>语法错误(syntax)：引号 分号等</li><li>类型错误(type error): 向一个int类型的变量传递了字符串字面值常量</li><li>声明错误(declaration error): c++的每个名字都要先声明才能使用。两种常见的声明错误是:对来自标准库的名字忘记使用std:: 、标识符名字拼写错误。(v1 写成v)</li></ol><h3 id="安装GUN编译器出现的错误："><a href="#安装GUN编译器出现的错误：" class="headerlink" title="安装GUN编译器出现的错误："></a>安装GUN编译器出现的错误：</h3><p><strong>“没有文件扩展‘.js’的脚本引擎。”</strong></p><p><img src="/2018/10/18/gun-compile/no-js.png" alt="no-js"></p><p>该错误是默认js打开方式被修改了。（我是安装了webstorm。-  -）</p><ol><li>打开注册表编辑器中的“HEKY_CLASSES_ROOT.js” </li><li>修改默认的文件为 <strong>JSFile</strong></li></ol><p><img src="/2018/10/18/gun-compile/register.png" alt="注册表编辑器"></p><h3 id="安装完成后的步骤："><a href="#安装完成后的步骤：" class="headerlink" title="安装完成后的步骤："></a>安装完成后的步骤：</h3><ol><li>打开MinGW Installation Manager</li><li>选择MinGW Compiler Suite之后，添加The GUN C++ Compiler的相关项</li><li>然后点击installation -&gt; apply changes 等待完成</li></ol><h3 id="环境变量配置："><a href="#环境变量配置：" class="headerlink" title="环境变量配置："></a>环境变量配置：</h3><ul><li>在PATH里面添加bin目录路径，我的是C:\MinGW\bin</li><li>重启cmd 然后输入g++ -v 如果出现gcc版本就说明配置成功</li></ul><p><img src="/2018/10/18/gun-compile/cmd-gcc.png" alt="cmd-gcc-version"></p><h3 id="GUN编译"><a href="#GUN编译" class="headerlink" title="GUN编译"></a>GUN编译</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -o _test test.cpp</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;GUN编译器&quot;&gt;&lt;a href=&quot;#GUN编译器&quot; class=&quot;headerlink&quot; title=&quot;GUN编译器&quot;&gt;&lt;/a&gt;GUN编译器&lt;/h2&gt;&lt;p&gt;编译器的一部分工作是检查文本错误：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;语法错误(syntax)：引号 分号等&lt;/li
      
    
    </summary>
    
      <category term="C++Primer笔记" scheme="http://yoursite.com/categories/C-Primer%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="gun" scheme="http://yoursite.com/tags/gun/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="http://yoursite.com/2018/10/03/zhuan-java12/"/>
    <id>http://yoursite.com/2018/10/03/zhuan-java12/</id>
    <published>2018-10-03T05:27:52.000Z</published>
    <updated>2019-03-10T05:39:43.138Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>单例的定义是，单例对象的类必须保证只有一个实例存在。</p><p>通常单例模式被分为饿汉式和懒汉式两大类。</p><ul><li>饿汉式:单例在类加载的时候创建</li><li>懒汉式:单例第一次被使用的时候创建</li></ul><p>下面介绍一下推荐使用的三种实现单例的方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒汉式，双重校验版</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个代码中，主要有三点需要考虑。分别是<code>volatile</code>，<code>synchronized</code>以及<code>两个if判断</code>的作用。</p><p><code>synchronized</code>的作用：</p><p>加了synchronized关键字后，只能有一个线程获取锁进入同步代码块，去执行<code>instance = new Singleton()</code>。</p><p><code>两个if判断</code>的作用：</p><p>第一个if是为了保证效率，只有在instance为null时才进入同步块。</p><p>第二个if是了防止出现多个实例。</p><p><code>volatile</code>的作用：</p><p>首先需要了解到JVM执行<code>instance = new Singleton()</code>,大致经历三个步骤1.给Singleton对象分配地址；2.通过Singleton的构造方法，实例化对象；3.instance引用指向Singleton对象。但是在JVM编译器中存在指令重排序优化，即步骤2，步骤3的执行先后顺序是不确定的。有可能是1-2-3执行，也可能是1-3-2执行。如果在1-3-2的执行顺序情况下，线程A执行完了步骤3，但还没开始执行步骤2，然后cpu被线程B抢占，线程B执行<code>if (instance == null)</code>，由于此时instance已经不是null了(但还没被初始化，比较特殊的中间状态)，所以线程B会直接返回instance，顺理成章地就会报错了。这里的关键是volatile防止出现线程A写操作未完成，线程B就进行读操作了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒汉式，静态内部类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>《Effective Java》第一版的推荐写法，非常巧妙。</p><ul><li>内部类SingletonHolder，它是一个饿汉式的单例实现，SingletonHolder初始化的时候会由ClassLoader来保证同步，使INSTANCE成一个单例。</li><li>由于SingletonHolder是一个内部类，只在外部类的<code>public final Singleton getInstance()</code>方法中被使用，所以SingletonHolder加载的时机是<code>public final Singleton getInstance()</code>方法第一次被调用的时候</li></ul><p>利用ClassLoader来保证同步，并且还能控制类的加载时机。从内部类SingletonHolder看是一个饿汉式单例的实现，从外部类Singleton看又是一个懒汉式单例的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 枚举实现单例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whateverMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最简洁的方法。由于枚举的特性它保证绝对不被实例化，即使在反射的情况下，并且还提供了序列化。当然，也因为是枚举的特性，它无法被继承。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;单例模式&quot;&gt;&lt;a href=&quot;#单例模式&quot; class=&quot;headerlink&quot; title=&quot;单例模式&quot;&gt;&lt;/a&gt;单例模式&lt;/h1&gt;&lt;p&gt;单例的定义是，单例对象的类必须保证只有一个实例存在。&lt;/p&gt;
&lt;p&gt;通常单例模式被分为饿汉式和懒汉式两大类。&lt;/p&gt;
&lt;ul
      
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="单例模式" scheme="http://yoursite.com/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程基础</title>
    <link href="http://yoursite.com/2018/09/21/zhuan-java7/"/>
    <id>http://yoursite.com/2018/09/21/zhuan-java7/</id>
    <published>2018-09-21T05:16:51.000Z</published>
    <updated>2019-03-10T05:18:17.280Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java多线程基础"><a href="#Java多线程基础" class="headerlink" title="Java多线程基础"></a>Java多线程基础</h1><h2 id="创建线程的方式"><a href="#创建线程的方式" class="headerlink" title="创建线程的方式"></a>创建线程的方式</h2><ol><li>实现Runnable接口</li><li>实现Callable接口</li><li>继承Thread类</li></ol><p>实现Runnable和Callable接口的类只能当作一个可以在线程中运行的任务，不是真正意义上的线程，因为最后还是需要通过Thread类来调用，可以说任务是通过线程驱动而执行的。</p><p>实现Runnable接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"运行中！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        MyRunnable myRunnable = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(myRunnable);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现Callable接口</p><p>与Runnable相比，Callable可以有返回值，返回值通过FutureTasK封装。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1024</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        MyCallable myCallable = <span class="keyword">new</span> MyCallable();</span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(myCallable);</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(futureTask);</span><br><span class="line">        thread.start();</span><br><span class="line">        System.out.println(futureTask.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继承Thread类</p><p>因为Thread类也实现了Runnable接口，因此同样需要实现run()方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">     System.out.println(<span class="string">"Hello world!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        MyThread myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        myThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现接口的方式与继承Thread比较</p><p>实现接口可能更好一些：1.Java不支持多继承2.类可能只要求可以执行就好了，继承整个类开销过大。</p><h2 id="sleep-、join-、yield-的区别"><a href="#sleep-、join-、yield-的区别" class="headerlink" title="sleep()、join()、yield()的区别"></a>sleep()、join()、yield()的区别</h2><p><strong>Thread.sleep()</strong>方法会休眠当前正在执行的线程，休眠时间单位为毫秒。sleep()可能抛出InterruptedException异常，因为异常不能跨线程传播，因此须在本地处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySleep</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(System.currentTimeMillis());</span><br><span class="line">            Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">            System.out.println(System.currentTimeMillis());</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        MySleep mySleep = <span class="keyword">new</span> MySleep();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(mySleep);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>yield方法</strong></p><p>调用静态方法yield()说明当前线程已经完成了生命周期中最重要的部分，可以切换给其他线程来执行。该方法只是对线程调度器的一个建议，而且也只是建议具有相同优先级的其他线程可以运行。</p><h2 id="CountDownLatch与CyclicBarrier"><a href="#CountDownLatch与CyclicBarrier" class="headerlink" title="CountDownLatch与CyclicBarrier"></a>CountDownLatch与CyclicBarrier</h2><p><strong>CountDownLatch</strong></p><p>用来控制一个线程等待多个线程。</p><p>原理:维护一个计数器，每次调用countDown()方法会让计数器的值减1，减到0的时候，那些因为调用await()方法而等待的线程会被唤醒。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCountDownLatch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> totalThread = <span class="number">10</span>;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(totalThread);</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;totalThread;i++)&#123;</span><br><span class="line">            executorService.execute(()-&gt;&#123;</span><br><span class="line">                System.out.println(<span class="string">"Hello "</span>);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(<span class="string">"World"</span>);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>CyclicBarrier</strong></p><p>用来控制多线程互相等待，只有这些线程都等待时，这些线程才会继续执行。</p><p>原理:维护一个计数器，线程执行await()方法之后，计数器减1并等待，直到计数器为0，所有调用await()方法的线程才能继续执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCyclicBarrier</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> totalThread = <span class="number">10</span>;</span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(totalThread);</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;totalThread;i++)&#123;</span><br><span class="line">            executorService.execute(()-&gt;&#123;</span><br><span class="line">                System.out.println(<span class="string">"Hello"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"World"</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CyclicBarrier与CountDownLatch的一个区别是，CyclicBarrier的计数器可以通过调用<code>cyclicBarrier.reset()</code>方法循环使用，所以又被称为循环屏障。</p><h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p>类似于操作系统中的信号量，可以控制对互斥资源的访问线程数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySemaphore</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> clientCount = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> totalRequstCount = <span class="number">10</span>;</span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(clientCount);</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;totalRequstCount;i++)&#123;</span><br><span class="line">            executorService.execute(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    System.out.println(semaphore.availablePermits());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程池的实现原理"><a href="#线程池的实现原理" class="headerlink" title="线程池的实现原理"></a>线程池的实现原理</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure><p>ThreadPoolExecutor的7个核心参数:</p><ol><li>corePoolSize:核心线程池大小。在创建线程之后，默认情况下，线程池没有任何线程，而是等待任务到来才创建线程区执行任务。</li><li>maximumPoolSize:线程池允许的最大线程数。当任务数比corePoolSize大时，任务添加到workQueue中，当workQueue满了，将继续创建线程以处理任务。</li><li>keepAliveTime:只有当线程池中的线程数量大于核心线程数时，这个参数才会起作用，多余的空闲线程等待任务的最长时间。</li><li>unit: keepAliveTime的时间单位</li><li>workQueue:存储没来得及执行的任务</li><li>threadFactory:执行程序创建线程时使用的工厂</li><li>handler:因为超出线程池容量范围和队列容量而执行的处理程序</li></ol><h2 id="Exector"><a href="#Exector" class="headerlink" title="Exector"></a>Exector</h2><p>Exector管理多个异步任务的执行，而无需开发人员显式地管理线程的生命周期。这里的异步指多个任务执行互不干扰，不需要同步操作。</p><ol><li>CachedThreadPool:一个任务创建一个线程</li><li>FixedThreadPool:所有任务只能使用固定大小的线程</li><li>SingleThreadExecutor:相当于大小为1的FixedThreadPool</li></ol><p><em>拓展</em></p><p><strong>阿里编码规范插件给出的建议</strong>:线程池不允许使用Exectors去创建，而是通过ThreadPoolExecutor的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</p><p>说明:Exectors各个方法的弊端:</p><ul><li><p>newFixedThreadPool和newSingleThreadExecutor:主要问题是堆积的请求处理队列可能会耗费非常大的内存，甚至OOM。</p></li><li><p>newCachedThreadPool和newScheduledThreadPool:主要问题是最大线程数是Integer.MAX_VALUE，可能会创建数量非常多的线程，甚至OOM。</p><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2></li></ul><p>通俗来讲，线程对于一个volatile变量的修改，对于其他线程是可见的。即线程每次获取的volatile变量的值都是最新的。</p><p>汇编代码层面用Lock前缀指令</p><ol><li>将当前cpu缓存行的数据写回主内存中。</li><li>这个写回主内存的操作会导致其他CPU缓存里该内存地址的数据失效。</li></ol><p>volatile的可见性与禁止重排序是基于内存屏障(Memory Barrier)实现的。内存屏障又称为内存栅栏，是一个CPU指令。在程序运行时，为了提高执行性能，编译器和处理器会对指令进行，插入一条内存屏障会告诉编译器和CPU，不管什么指令都不能和这条内存屏障重排序。</p><h2 id="synchronized与lock"><a href="#synchronized与lock" class="headerlink" title="synchronized与lock"></a>synchronized与lock</h2><p>用法比较:</p><ol><li>lock使用比较灵活，但必须手动获取和释放锁。</li><li>lock只适用于代码块，synchronized可用于方法和代码块。</li><li>lock可以控制公平性。</li><li>lock可以中断地获取锁，中断异常将被抛出，锁会被释放。</li></ol><p><strong>ReetrantLock</strong>是Lock的实现类，是一个互斥的同步器，在多线程高竞争的条件下，ReetrantLock比synchronized有更加优异的性能表现。</p><p>ReetrantLock主要利用CAS+CLH队列(带头节点的双向非循环队列)实现，它支持公平锁和非公平锁。</p><p>基本实现:先通过CAS获取锁，如果此时已经有线程占据了锁，那就加入CLH队列并挂起。当锁被释放后，排在CLH队首的线程会被唤醒，然后通过CAS再次获取锁。</p><p>如果此时是公平锁:并且同时还有另一线程进来尝试获取锁，当它发现自己不是队首时，会排到队尾，由队首线程获取到锁。</p><p>如果此时是非公平锁:并且同时还有另一线程进来获取锁，那么有可能让这个线程先获取。</p><p><strong>synchronized</strong></p><p>synchronized代码块是由一对monitorenter/monitorexit指令实现的。</p><p>类型上可以分为偏斜锁、轻量级锁、重量级锁</p><p>当没有竞争，默认使用偏斜锁，JVM利用CAS操作在对象头上的Mark Word部分设置线程Id，如果有另外的线程试图锁定某个被偏斜过的对象，则升级成轻量级锁，轻量级锁依赖CAS操作Mark Word来获取锁，如果成功，就使用轻量级锁，否则，进一步升级成为重量级锁。</p><p><em>拓展</em><br><strong>自旋锁</strong>:竞争锁失败的线程，并不会真实的在操作系统层面挂起等待，而是让JVM做几个空循环，在经过若干循环之后，如果可以获取锁，那么进入临界区，如果还不能获取锁，才会将线程挂起。<br><strong>重入</strong>:由于内置锁是可重入的，因此如果某个线程试图获得一个已经由他自己持有的锁，那么这个请求就会成功。”重入”意味着获取锁的操作的粒度是”线程”，而不是调用。重入的实现方式是，为每个锁关联一个获取计数值和一个所有者线程。当计数值为0时，这个锁就被认为是没有被任何线程持有。当线程请求一个未被持有的锁时，JVM将记下锁的持有者，并且将获取计数值置为1。如果同一个线程再次获取这个锁，计数值将递增，而当线程退出同步代码块时，计数值会相应递减。当计数值为0时，这个锁将被释放。(内置锁:每个Java对象都可以用做一个实现同部的锁，这些锁被称为内置锁(Intrinsic Lock)或者监视器(Monitor Lock)–《Java并发编程实战》)</p><h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p>CAS是非阻塞同步的。</p><p>CAS指令需要三个操作数，分别是内存地址V，旧的预期值A和新值B。当执行操作时，只有当V的值等于A,才将V的值更新为B。</p><p><strong>ABA问题</strong></p><p>如果一个变量初次读取的时候是A值，它的值被改成了B，后来又被改回A,那CAS操作会误认为它从来没有被改变过。通过原子引用类AtomicStampedReference来控制变量值的版本来解决这个问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java多线程基础&quot;&gt;&lt;a href=&quot;#Java多线程基础&quot; class=&quot;headerlink&quot; title=&quot;Java多线程基础&quot;&gt;&lt;/a&gt;Java多线程基础&lt;/h1&gt;&lt;h2 id=&quot;创建线程的方式&quot;&gt;&lt;a href=&quot;#创建线程的方式&quot; class=&quot;he
      
    
    </summary>
    
      <category term="Java多线程" scheme="http://yoursite.com/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="Java多线程基础" scheme="http://yoursite.com/tags/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java方法参数按值传递</title>
    <link href="http://yoursite.com/2018/08/26/zhuan-java5/"/>
    <id>http://yoursite.com/2018/08/26/zhuan-java5/</id>
    <published>2018-08-26T05:00:12.000Z</published>
    <updated>2019-03-10T05:36:43.159Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java方法参数按值传递"><a href="#Java方法参数按值传递" class="headerlink" title="Java方法参数按值传递"></a>Java方法参数按值传递</h1><p>程序设计语言中往往分成按值调用和按引用调用。按值调用(call by value)表示方法接收的是调用者提供的值。而按引用调用(call by reference)表示方法接收的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。</p><p>在Java程序设计语言中，方法参数总是按值调用。方法得到的是参数值的一个拷贝。特别需要注意的是，方法不能修改传递给它的任何参数变量的内容(这句话下文会通过三个例子来进行分析)</p><p>首先需要知道的是，Java的方法参数共有两种类型:</p><ol><li>基本数据类型</li><li>对象引用</li></ol><p>例子代码1:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassA</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">testCallByValue</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        x++;</span><br><span class="line">        System.out.println(<span class="string">"testCallByValue: "</span>+x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] arg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> y=<span class="number">1</span>;</span><br><span class="line">        testCallByValue(y);</span><br><span class="line">        System.out.println(<span class="string">"main: "</span>+y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">testCallByValue: <span class="number">2</span></span><br><span class="line">main: <span class="number">1</span></span><br></pre></td></tr></table></figure><p>可以看到，y被传入<code>testCallByValue(int x)</code>方法，参数x的值变为2，y本身的值依然为1，没有变化。</p><p>执行的具体过程如下:</p><ol><li>x被初始化为y值的拷贝(也就是1)</li><li>x++,x的值变为2，y依然为1</li><li>方法结束，参数x不再使用</li></ol><p>例子代码2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassA</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">testCallByReference</span><span class="params">(List arrayListX)</span></span>&#123;</span><br><span class="line">        arrayListX.add(<span class="number">10000</span>);</span><br><span class="line">        arrayListX.add(<span class="number">10010</span>);</span><br><span class="line">        arrayListX.forEach(array-&gt;System.out.println(<span class="string">"testCallByReference: "</span>+array));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] arg)</span></span>&#123;</span><br><span class="line">        List&lt;Integer&gt; arrayListY = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        arrayListY.add(<span class="number">10086</span>);</span><br><span class="line">        testCallByReference(arrayListY);</span><br><span class="line">        arrayListY.forEach(array-&gt;System.out.println(<span class="string">"main: "</span>+array));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">testCallByReference: <span class="number">10086</span></span><br><span class="line">testCallByReference: <span class="number">10000</span></span><br><span class="line">testCallByReference: <span class="number">10010</span></span><br><span class="line">main: <span class="number">10086</span></span><br><span class="line">main: <span class="number">10000</span></span><br><span class="line">main: <span class="number">10010</span></span><br></pre></td></tr></table></figure><p>可以看到arrayListY被传入<code>testCallByReference(List arrayListX)</code>方法后，自身的值也发生了改变。</p><p>执行的具体过程如下:</p><ol><li>arrayListX被初始化为arrayListY值的拷贝,这里是一个对象的引用(即arrayListX和arrayListY引用的同一个对象)</li><li><code>testCallByReference(List arrayListX)</code>方法应用于这个对象的引用，add成功</li><li>方法结束，参数arrayListX不再使用，arrayListY仍然引用着这个对象</li></ol><p>例子代码3：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassA</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">testCallByReference</span><span class="params">(String strX)</span></span>&#123;</span><br><span class="line">        strX = <span class="string">"strX"</span>;</span><br><span class="line">        System.out.println(<span class="string">"testCallByReference: "</span>+strX);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] arg)</span></span>&#123;</span><br><span class="line">        String strY = <span class="string">"strY"</span>;</span><br><span class="line">        testCallByReference(strY);</span><br><span class="line">        System.out.println(<span class="string">"main: "</span>+strY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">testCallByReference: strX</span><br><span class="line">main: strY</span><br></pre></td></tr></table></figure><p>可以看到strY被传入<code>testCallByReference(String strX)</code>方法后，自身的值没有改变。</p><p>执行的具体过程如下:</p><ol><li>strX被初始化为strY值的拷贝,这里是一个对象的引用(即strX和strY引用的同一个对象)</li><li><code>testCallByReference(String strX)</code>方法使strX引用了一个新的字符串对象，strY不会改变自身的引用</li><li>方法结束，参数strX不再使用，strY依然引用着<code>&quot;strY&quot;</code>这个对象</li></ol><p>上面三个例子各做一个结论说明，分别是:</p><ol><li>一个方法不能修改一个基本数据类型参数的值</li><li>一个方法可以改变一个对象参数的状态</li><li>一个方法不能让对象参数引用一个新的对象</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java方法参数按值传递&quot;&gt;&lt;a href=&quot;#Java方法参数按值传递&quot; class=&quot;headerlink&quot; title=&quot;Java方法参数按值传递&quot;&gt;&lt;/a&gt;Java方法参数按值传递&lt;/h1&gt;&lt;p&gt;程序设计语言中往往分成按值调用和按引用调用。按值调用(cal
      
    
    </summary>
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java方法参数按值传递" scheme="http://yoursite.com/tags/Java%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E6%8C%89%E5%80%BC%E4%BC%A0%E9%80%92/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络基础</title>
    <link href="http://yoursite.com/2018/08/20/zhuan-java10/"/>
    <id>http://yoursite.com/2018/08/20/zhuan-java10/</id>
    <published>2018-08-20T05:22:46.000Z</published>
    <updated>2019-03-10T05:23:34.740Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络基础"><a href="#计算机网络基础" class="headerlink" title="计算机网络基础"></a>计算机网络基础</h1><h3 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h3><ol><li>首先服务器处于监听状态，等待连接请求。</li><li>客户端向服务器发送请求报文，SYN=1,seq=x。</li><li>服务器收到连接请求报文，如果同意连接，会向客户端发送确认报文SYN=1,ACK=1,ack=x+1,seq=y。</li><li>客户端收到服务器的确认报文之后，还要发送确认报文ACK=1，ack=y+1,seq=x+1。</li><li>服务器收到确认报文，连接建立。</li></ol><h5 id="为什么需要三次握手"><a href="#为什么需要三次握手" class="headerlink" title="为什么需要三次握手?"></a>为什么需要三次握手?</h5><p>如果网络阻塞，客户端发送的连接请求会需要很长时间才能到达服务器。客户端等待一个超时重传时间后，就会重新发起连接请求。但是迟到的连接请求最后还是会到达服务器，如果不进行三次握手，服务器会打开两个连接。如果有三次握手，客户端则会忽略服务器对于迟到连接请求的确认。</p><h3 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h3><ol><li>客户端发送连接释放报文，FIN=1,seq=u。</li><li>服务器收到之后发送确认ACK=1,seq=v,ack=u+1，此时服务器进入CLOSE-WAIT状态，服务器可以向客户端发送数据但是客户端不能向服务器发送数据。</li><li>当服务器发送完传送的数据之后，服务器会发送连接释放报文FIN=1,ACK=1,seq=w,ack=u+1。</li><li>客户端收到后发送确认ACK=1,seq=u+1,ack=w+1，客户端进入TIME-WAIT状态，等待2MSL(最大报文存活时间)后释放连接。</li><li>服务器收到客户端的确认后释放连接。</li></ol><h5 id="为什么需要四次挥手"><a href="#为什么需要四次挥手" class="headerlink" title="为什么需要四次挥手?"></a>为什么需要四次挥手?</h5><p>CLOSE-WAIT:为了让服务器发送完还未传送完毕的数据。</p><p>TIME-WAIT:</p><p>a.确保最后一个确认报文能够达到。如果服务器没收到客户端发送来的确认报文，就会重新发送连接释放请求报文，客户端等待一段时间就是为了处理这种情况的发生。</p><p>b.等待一段时间是为了让本次连接内产生的所有报文在网络中消失，使得下一个新的连接不会出现旧的连接请求报文。</p><h3 id="Cookie与Session"><a href="#Cookie与Session" class="headerlink" title="Cookie与Session"></a>Cookie与Session</h3><p>HTTP是超文本传输协议，无状态。</p><p><strong>Cookie</strong></p><p>Cookie是客户端保持状态的解决方案。从定义上来讲，Cookie就是服务器发送给客户端的特殊信息，而这些信息以文本的形式存放在客户端，然后客户端每次请求的时候都会带上这些特殊信息。</p><p><strong>Session</strong></p><p>Session是通过服务器来保持状态，在创建Session的同时，服务器会为该Session生成唯一的SessionId，SessionId创建之后，就可以调用Session相关的方法往Session增加内容了。并且这些内容只会存放在服务器中，发送到客户端的只有SessionId。当客户端再次发送请求的时候会将SessionId带上，服务器收到请求之后，根据SessionId找到对应的Session，从而再次使用。如果请求中没有SessionId，服务器会生成一个新的SessionId。</p><p>在Java Web项目中，这里的session特指HttpSession，查看tomcat源码可知，HttpSession提供了一些方法，来控制session或者获取session的状态，如获取session的id，获取session的创建时间，使session失效等。</p><p>Session的存放方式有两种:</p><p>a.通过URL存取，URL会带上一个jSessionId=XXXX。</p><p>b.通过Cookie存取(tomcat默认如此)。</p><p>在大型互联网系统中，单独使用Cookie或者Session都是不可行的(通过分布式Session可解决)。</p><p>Cookie的不足:</p><p>a.随着访问量和Cookie的增多，它占用的带宽会很大。</p><p>b.Cookie因为存放在客户端中，可以被修改，不安全。</p><p>Session的不足:</p><p>a.不容易在多台服务器中共享。</p><p>b.Session太多非常消耗服务器性能。</p><h3 id="HTTP中GET与POST的比较"><a href="#HTTP中GET与POST的比较" class="headerlink" title="HTTP中GET与POST的比较"></a>HTTP中GET与POST的比较</h3><p><strong>作用</strong>:GET主要用于获取资源;POST主要用于传输实体主体。</p><p><strong>参数</strong>:GET是出现在URL中，POST存储在实体主体中。</p><p><strong>安全</strong>:安全的HTTP方法是不会改变服务器状态的，也就是只可读。GET方法是安全的，而POST不是，因为POST的目的是传输实体主体，这其中的数据通常会改变服务器中的数据。</p><p><strong>XMLHttpRequest</strong>:是一个API,它为客户端提供与服务器之间传输数据的功能，在Ajax应用程序中，XMLHttpRequest对象负责将用户信息以异步通信的方式发送到服务器，并接收到服务器返回的响应信息和数据。</p><p>a.在使用XMLHttpRequest的POST的方法时，浏览器会先发送Header在发送Data。但并不是所有浏览器都这么做，火狐浏览器就是一个例外。</p><p>b.XMLHttpRequest的GET方法是Header和Data一起发送。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;计算机网络基础&quot;&gt;&lt;a href=&quot;#计算机网络基础&quot; class=&quot;headerlink&quot; title=&quot;计算机网络基础&quot;&gt;&lt;/a&gt;计算机网络基础&lt;/h1&gt;&lt;h3 id=&quot;TCP三次握手&quot;&gt;&lt;a href=&quot;#TCP三次握手&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="网络" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络基础" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>String</title>
    <link href="http://yoursite.com/2018/08/13/zhuan-java4/"/>
    <id>http://yoursite.com/2018/08/13/zhuan-java4/</id>
    <published>2018-08-13T05:00:05.000Z</published>
    <updated>2019-03-10T05:11:53.059Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面试常见的String问题"><a href="#面试常见的String问题" class="headerlink" title="面试常见的String问题"></a>面试常见的String问题</h1><p>String的intern方法以及new String(“Hello”)创建几个对象是经常出现的问题。</p><h3 id="String-s-new-String-“Hello”-创建了几个对象"><a href="#String-s-new-String-“Hello”-创建了几个对象" class="headerlink" title="String s = new String(“Hello”)创建了几个对象"></a>String s = new String(“Hello”)创建了几个对象</h3><p>符号引用s,字面量”Hello”在编译期间会加载到Class文件的常量池中,然后类加载阶段进入方法区的运行时常量池中(<a href="https://www.zhihu.com/question/55994121" target="_blank" rel="noopener">Java 中new String(“字面量”) 中 “字面量” 是何时进入字符串常量池的?</a>)</p><p>常量池中的“对象”是在编译期就确定了的，在类被加载的时候创建，如果类加载时，该字符串常量在常量池中已经有了，那这一步就省略了。堆中的对象是在运行期才确定的，在代码执行到new的时候创建的。对象的符号引用s是保存在Java虚拟机栈上的，他保存的是堆中刚刚创建出来的的字符串对象的引用。 所以，若常量池中已经存在”Hello”，则直接引用，也就是此时只会创建一个对象，如果常量池中不存在”Hello”，则先创建后引用，也就是有两个。</p><h3 id="String的intern-方法"><a href="#String的intern-方法" class="headerlink" title="String的intern()方法"></a>String的intern()方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String s1 = <span class="string">"Hollis"</span>;</span><br><span class="line">    String s2 = <span class="keyword">new</span> String(<span class="string">"Hollis"</span>);</span><br><span class="line">    String s3 = <span class="keyword">new</span> String(<span class="string">"Hollis"</span>).intern();</span><br><span class="line">    System.out.println(s1==s2);</span><br><span class="line">    System.out.println(s1==s3);</span><br><span class="line">    System.out.println(s2==s3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">false</span></span><br></pre></td></tr></table></figure><p>intern()有两个作用，第一个是将字符串字面量放入常量池（如果池没有的话），第二个是返回这个常量的引用。</p><p>intern中说的“如果常量池中有该字面量的话就直接返回其引用”，指的是会直接返回字面量对象的引用。这个过程是不会在Java堆中再创建一个String对象的。</p><h3 id="String-StringBuffer-StringBuilder的区别"><a href="#String-StringBuffer-StringBuilder的区别" class="headerlink" title="String,StringBuffer,StringBuilder的区别"></a>String,StringBuffer,StringBuilder的区别</h3><p>String具有不可变性。对String对象的任何改变都不影响到原对象，相关的任何change操作都会生成新的对象。不可变可提高多线程情况下的性能。针对常量池的优化。当两个String对象拥有相同的值，他们都只是引用常量池中的同一个拷贝。当一个字符串反复出现，可大幅度节省内存空间。</p><p>而StringBuffer和StringBuilder的对象是变量，对变量进行操作就是直接对该对象进行更改(其值改变后，对象的引用不会改变)，而不进行创建和回收的操作，所以速度要比String快很多。只不过StringBuffer线程安全，StringBuilder线程不安全。所以性能上，StringBuilder最好。</p><p>应用场景:在字符串不经常改变的场景下，优先使用String。在频繁改变字符串，并且在多线程环境下，优先使用StringBuffer。在频繁改变字符串，并且在单线程环境下，优先使用StringBuilder.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;面试常见的String问题&quot;&gt;&lt;a href=&quot;#面试常见的String问题&quot; class=&quot;headerlink&quot; title=&quot;面试常见的String问题&quot;&gt;&lt;/a&gt;面试常见的String问题&lt;/h1&gt;&lt;p&gt;String的intern方法以及new Strin
      
    
    </summary>
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>HTTPS的简单认识</title>
    <link href="http://yoursite.com/2018/08/03/zhuan-java11/"/>
    <id>http://yoursite.com/2018/08/03/zhuan-java11/</id>
    <published>2018-08-03T05:22:53.000Z</published>
    <updated>2019-03-10T05:24:35.599Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTTPS的简单认识"><a href="#HTTPS的简单认识" class="headerlink" title="HTTPS的简单认识"></a>HTTPS的简单认识</h1><p>由于HTTP有使用明文通信，内容可能会被窃听；不验证通信方身份，通信方可能会遭遇伪装；无法证明报文完整性，报文有可能被篡改等问题。于是通过HTTPS来解决避免这些问题。</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>HTTPS不是一个全新的协议。而是HTTP先和SSL(Secure Socket Layer)通信，再由SSL和TCP通信，也就是说HTTPS使用了隧道通信。也因为使用了SSL，HTTPS具备加密(放窃听)、认证(放伪装)和完整性保护(放篡改)的特性。</p><h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><h4 id="加密的分类"><a href="#加密的分类" class="headerlink" title="加密的分类"></a><strong>加密的分类</strong></h4><ol><li>对称密钥加密(Symmetric-Key Encryption)，加密和解密使用同一密钥。</li></ol><ul><li>优点:运算速度快。</li><li>缺点:无法安全的将密钥传输给通信方</li></ul><ol><li>非对称密钥加密，有称为公开密钥加密(Public-Key Encryption)，加密和解密使用不同的密钥。公开密钥所有人都可以获取，通信发送方获得接收方的公开密钥之后，就使用公开密钥进行加密，接收方收到通信内容之后使用私有密钥进行解密。非对称密钥出了用来加密，还可以用来进行签名。因为私有密钥无法被其他人获取，因此通信发送方使用其私有密钥进行签名，通信接收方使用发送方的公开密钥对签名进行解密，来判断这个签名是否正确</li></ol><ul><li>优点:更加安全地将公开密钥传输给通信的发送方</li><li>缺点:运行速度慢。</li></ul><h4 id="HTTPS-采用的加密方式"><a href="#HTTPS-采用的加密方式" class="headerlink" title="HTTPS 采用的加密方式"></a>HTTPS 采用的加密方式</h4><p>HTTPS 采用混合的加密机制，使用非对称密钥加密用于传输对称密钥来保证传输过程的安全性，之后使用对称密钥加密进行通信来保证通信过程的效率。</p><h3 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h3><p>通过使用 <strong>证书</strong> 来对通信方进行认证。数字证书认证机构（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。进行 HTTPS 通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过，就可以开始通信了。通信开始时，客户端需要使用服务器的公开密钥将自己的私有密钥传输给服务器，之后再进行对称密钥加密。</p><h3 id="完整性保护"><a href="#完整性保护" class="headerlink" title="完整性保护"></a>完整性保护</h3><p>SSL 提供报文摘要功能来进行完整性保护。HTTP 也提供了 MD5 报文摘要功能，但不是安全的。例如报文内容被篡改之后，同时重新计算 MD5 的值，通信接收方是无法意识到发生了篡改。</p><p>HTTPS 的报文摘要功能之所以安全，是因为它结合了加密和认证这两个操作。试想一下，如果加密之后的报文，遭到篡改之后，也很难重新计算报文摘要，因为无法轻易获取明文。</p><h3 id="HTTPS的缺点"><a href="#HTTPS的缺点" class="headerlink" title="HTTPS的缺点"></a>HTTPS的缺点</h3><ul><li>因为需要进行加密解密等过程，因此速度会更慢。</li><li>需要支付证书授权的额外费用。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;HTTPS的简单认识&quot;&gt;&lt;a href=&quot;#HTTPS的简单认识&quot; class=&quot;headerlink&quot; title=&quot;HTTPS的简单认识&quot;&gt;&lt;/a&gt;HTTPS的简单认识&lt;/h1&gt;&lt;p&gt;由于HTTP有使用明文通信，内容可能会被窃听；不验证通信方身份，通信方可能会
      
    
    </summary>
    
      <category term="网络" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="HTTPS" scheme="http://yoursite.com/tags/HTTPS/"/>
    
  </entry>
  
  <entry>
    <title>Java基础</title>
    <link href="http://yoursite.com/2018/07/03/zhuan-java3/"/>
    <id>http://yoursite.com/2018/07/03/zhuan-java3/</id>
    <published>2018-07-03T04:59:58.000Z</published>
    <updated>2019-03-10T05:10:17.016Z</updated>
    
    <content type="html"><![CDATA[<h2 id="final、finally、finalize的区别"><a href="#final、finally、finalize的区别" class="headerlink" title="final、finally、finalize的区别"></a>final、finally、finalize的区别</h2><p><strong>final</strong>:</p><ol><li>final修饰的类不可以被继承。</li><li>final修饰的方法不可以被重写。</li><li>final修饰的变量引用不可以改变。</li></ol><p><strong>finally</strong>:finally是Java保证重点代码一定要被执行的一种机制。我们可以使用try-finally或者try-catch-finally来进行类似关闭JDBC连接、保证unlock锁等动作。</p><p><strong>finalize</strong>:finalize是基础类java.lang.Oject的一个方法。当一个对象可以被回收的时候，如果需要执行该对象的finalize()方法，那么就有可能在该方法中让对象重新被引用，从而实现自救。finalize()方法只能执行一次，如果回收的对象在之前调用了finalize()方法，后面回收时不会调用finalize()方法。finalize机制已经不推荐使用了，并且在JDK9开始被标记为deprecated。</p><h2 id="int与Integer"><a href="#int与Integer" class="headerlink" title="int与Integer"></a>int与Integer</h2><p>Integer的默认值为null,int默认值为0；</p><p>Integer是int的包装类,int是Java中的基本数据类型。Java中一共有8种基本数据类型。其中4种为整型，2种浮点类型，1种用于表示Unicode编码字符单元的字符类型char,1种用于表示真值的boolean。</p><p><strong>整型</strong></p><table><thead><tr><th>类型</th><th>存储大小</th><th>取值范围</th></tr></thead><tbody><tr><td>byte</td><td>1字节</td><td>-128~127</td></tr><tr><td>short</td><td>2字节</td><td>-32768~32767</td></tr><tr><td>int</td><td>4字节</td><td>-2147483648~2147483647(正好超过20亿)</td></tr><tr><td>long</td><td>8字节</td><td>-9223372036854775808~9223372036854775807</td></tr></tbody></table><p><strong>浮点类型</strong></p><table><thead><tr><th>类型</th><th>存储大小</th><th>取值范围</th></tr></thead><tbody><tr><td>float</td><td>4字节</td><td>约±3.40282347E+38F(有效位数6~7位)</td></tr><tr><td>double</td><td>8字节</td><td>约±1.79769313486231570E+308(有效位数15位)</td></tr></tbody></table><p>double的数值精度是float类型的两倍，所以double又称为双精度数值。float类型的数值需要有后缀F(例如，3.14F)。若没有后缀，默认为double类型，也可以加后缀D(例如，3.14D)</p><p><strong>字符类型</strong></p><table><thead><tr><th>类型</th><th>存储大小</th></tr></thead><tbody><tr><td>char</td><td>2字节</td></tr></tbody></table><p>char通常表示字符常量。例如‘A’是编码65所对应的字符常量。</p><p><strong>boolean类型</strong></p><table><thead><tr><th>类型</th><th>存储大小</th></tr></thead><tbody><tr><td>boolean</td><td>1bit</td></tr></tbody></table><p>boolean类型有两个值:false和true。原来判断逻辑条件。</p><h2 id="重载与重写"><a href="#重载与重写" class="headerlink" title="重载与重写"></a>重载与重写</h2><h4 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h4><p>重载存在于同一个类中，指的是一个方法与已经存在的方法名称上相同，但是参数列表(参数类型、个数、顺序至少一个)不同。需要注意的是，返回值类型不同，其他都相同不算重载。</p><h4 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h4><p>重写存在于继承中，指的是子类实现了一个与父类在方法声明上完全相同的一个方法。</p><p>为了满足里式替换原则，重写有两个限制:</p><ol><li>子类方法的访问权限必须大于等于父类方法。</li><li>子类方法的返回类型必须是父类方法返回类型或者是其子类。</li></ol><p>使用@Override注解，可以让编译器帮忙检查是否满足以上两个条件。</p><h2 id="抽象类与接口"><a href="#抽象类与接口" class="headerlink" title="抽象类与接口"></a>抽象类与接口</h2><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>接口是抽象方法的一个集合，通过接口达到了API定义与实现分离的目的。接口无法被实例化，接口中的变量都隐含着public static final的意义。在Java 8之前，接口中的方法必须是抽象方法。Java 8开始，接口可以有default方法和static方法。常用的一些接口如Callable、Runnable、Comparator等在Java 8中添加了@FunctionalInterface注解，简单来说就是只有一个抽象方法的接口，通常建议使用@FunctionalInterface注解来标记。Lambda本身也可以看作是一类Function Inerface。</p><h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p>抽象类是无法被实例化的类，用abstract关键字修饰class，它的主要作用是代码重用。抽象类可以有0个或者多个抽象方法。抽象类大多抽取相关类的共用方法实现或者共同成员变量。然后通过继承的方式达到代码复用的目的。除了无法被实例化，形式上和普通类没有什么太多区别。</p><h2 id="反射的用途与实现"><a href="#反射的用途与实现" class="headerlink" title="反射的用途与实现"></a>反射的用途与实现</h2><h4 id="反射的作用"><a href="#反射的作用" class="headerlink" title="反射的作用"></a>反射的作用</h4><ol><li>在运行时判断任意一个对象所属的类。</li><li>在运行时构造任意一个类的对象。</li><li>在运行时判断一个类所具有的成员变量和方法。</li><li>在运行时调用任何一个对象的方法。</li></ol><h4 id="反射的用途"><a href="#反射的用途" class="headerlink" title="反射的用途"></a>反射的用途</h4><ol><li>使用IDE时，在一个类或者对象后输入”.”符号，编译器会自动列出属性和方法。</li><li>很多框架都是配置化的(例如Spring通过XML文件配置Java Bean)为了保证框架的通用性，他们会根据配置文件加载不同的对象或者类，调用不同的方法，这个时候必须用到反射—运行时动态加载所需对象。</li></ol><h4 id="反射的基本运用"><a href="#反射的基本运用" class="headerlink" title="反射的基本运用"></a>反射的基本运用</h4><ol><li><p>获取class对象(三种方式)</p><p>a.class.forName();</p><p>b.对象.class；</p><p>c.对象.getClass()；</p></li><li><p>获取类的实例</p><p>a.对于有空构造方法的类</p><p>Object o = class对象.newInstance();//会调用空构造器，如果没有会报错</p><p>b.对于没有空构造方法的，先获取他的构造对象。</p><p>Constroctor constroctor = class对象.getConstroctor(String class,Integer class);</p><p>Object obj = constroctor.newInstance(“yuanzhi”,1);//通过构造器对象的newInstance()方法进行对象的初始化。</p></li></ol><h2 id="equals与”-”"><a href="#equals与”-”" class="headerlink" title="equals与”==”"></a>equals与”==”</h2><p>由于所有类继承自Object类，如果没有重写equals方法的话，调用的仍是Object类的方法，而Object类的equals方法返回的是==的判断。==比较引用，equals通常比较内容。</p><h2 id="Exception-和Error，运行时异常与一般异常，检查异常-checked-与非检查异常-unchecked-的区别关系"><a href="#Exception-和Error，运行时异常与一般异常，检查异常-checked-与非检查异常-unchecked-的区别关系" class="headerlink" title="Exception 和Error，运行时异常与一般异常，检查异常(checked)与非检查异常(unchecked)的区别关系?"></a>Exception 和Error，运行时异常与一般异常，检查异常(checked)与非检查异常(unchecked)的区别关系?</h2><p>Java中只有<strong>Throwable</strong>类的实例才可以被抛出(throw)或者捕获(catch)，它是异常处理机制的基本组成类型。Exception和Error都是继承了Throwable类。</p><p><strong>Exception</strong>是程序在正常运行中，可以预料的意外情况，并且应该被捕获，进行相应的处理。</p><p><strong>Error</strong>是指正常情况下，不大可能出现的情况，绝大部分的Error都会导致程序(比如JVM)自身处于非正常、不可恢复的状态，所以也不需要去捕获。比如常见的OutOfMemoryError。</p><p>Exception有可分为可检查异常与非检查异常，<strong>检查异常</strong>必须在代码中进行异常捕获处理，这是编译期处理的一部分。<strong>非检查异常</strong>就是运行时异常，可以通过编码避免的逻辑错误，具体根据需要是否捕获，并不会在编译期强制要求，比如常见的NullPointerException，ArrayIndexOutOfBoundsException。</p><h4 id="try-catch-finally代码段"><a href="#try-catch-finally代码段" class="headerlink" title="try-catch-finally代码段"></a>try-catch-finally代码段</h4><ol><li>当一个try后面跟了多个catch的时候，必须要先捕获小的异常再捕获大的异常。</li><li>在finally中尽量不要使用return。</li><li>尽量只捕获有必要的代码段。</li><li>尽量不要捕获类似Exception这样的通用异常，而是应该捕获特定异常。</li></ol><h4 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h4><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvalidParamException</span> <span class="keyword">extends</span> <span class="title">Throwable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InvalidParamException</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在方法中可使用<code>throw new InvalidParamException(&quot;这是一个自定义异常&quot;);</code>来进行自定义异常的抛出。</p><h4 id="throws与throw"><a href="#throws与throw" class="headerlink" title="throws与throw"></a>throws与throw</h4><p>throws用在声明方法时，表示该方法可能要抛出异常 。throw一般是在代码块的内部，当程序出现某种逻辑错误时由开发人员主动抛出某种特定类型的异常 。</p><h4 id="从性能角度考虑，java异常处理"><a href="#从性能角度考虑，java异常处理" class="headerlink" title="从性能角度考虑，java异常处理"></a>从性能角度考虑，java异常处理</h4><ol><li>try-catch代码段会产生额外的开销，它会影响JVM对代码的优化，所以尽量只捕获有必要的代码段，不要一个try包住整段的代码。</li><li>Java每实例化一个Exception，都会对当时的栈进行快照，这是一个相对比较重的操作。如果异常发生的比较频繁，这个开销不能被忽略。</li></ol><h2 id="ArrayList与LinkedList"><a href="#ArrayList与LinkedList" class="headerlink" title="ArrayList与LinkedList"></a>ArrayList与LinkedList</h2><p>ArrayList:1.允许插入NULL值</p><p> 2.允许重复</p><p> 3.有序</p><p> 4.不是线程安全的</p><p>ArrayList底层是数组，所以需要连续的内存空间，在非末尾插入和删除，为了保证内存连续，需要使用System.arraycopy()进行数组数据的移动，每次扩容为原来的1.5倍，依然是使用System.arraycopy()方法进行扩容。</p><p>LinkedList:1.允许插入NULL值</p><p> 2.允许重复</p><p> 3.有序</p><p> 4.不是线程安全的</p><p>LinkedList是基于双向链表实现的，Node作为存储单元，next和prev分别保存着后一个以及前一个的存储单元的引用。</p><p>两者比较:</p><ol><li>ArrayList基于动态数组实现，LinkedList基于双向链表实现。</li><li>ArrayList支持随机访问，LinkedList不支持。</li><li>Linked在任意位置添加/删除元素更快。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;final、finally、finalize的区别&quot;&gt;&lt;a href=&quot;#final、finally、finalize的区别&quot; class=&quot;headerlink&quot; title=&quot;final、finally、finalize的区别&quot;&gt;&lt;/a&gt;final、final
      
    
    </summary>
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java基础" scheme="http://yoursite.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
