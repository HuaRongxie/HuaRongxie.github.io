<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HuaRongxie&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-03-05T11:51:43.034Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>HuaRongxie</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>函数</title>
    <link href="http://yoursite.com/2019/03/05/function/"/>
    <id>http://yoursite.com/2019/03/05/function/</id>
    <published>2019-03-05T11:50:16.000Z</published>
    <updated>2019-03-05T11:51:43.034Z</updated>
    
    <content type="html"><![CDATA[<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="函数基础"><a href="#函数基础" class="headerlink" title="函数基础"></a>函数基础</h2><p>函数的定义包括： 返回类型、函数名、形参列表、函数体。</p><p>通过调用运算符()来执行函数。</p><h4 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h4><p>函数的调用完成两项工作：</p><ol><li>用实参初始化函数对应的形参</li><li>将控制权转移给被调用函数。此时，主调函数的执行被暂时中断，被调函数开始执行。</li></ol><p>当遇到一条return语句时函数结束执行过程。return语句也完成两项工作：</p><ol><li>返回return语句中的值(有的话)</li><li>将控制权从被调函数转移回主调函数。继续完成主调函数剩余部分。</li></ol><h4 id="形参和实参"><a href="#形参和实参" class="headerlink" title="形参和实参"></a>形参和实参</h4><p>实参是形参的初始值。第一个实参初始化第一个形参，第二个实参初始化第二个形参，以此类推。</p><p>尽管实参与形参存在对应关系，但是没有规定实参的求值顺序。编译器能任意可行的顺序对实参求值。</p><p>实参类型必须与对应的形参匹配，且数量必须相等。两个形参的名字不能相同。    </p><h4 id="函数的形参列表"><a href="#函数的形参列表" class="headerlink" title="函数的形参列表"></a>函数的形参列表</h4><p>函数的形参列表可以为空，但是不能省略。要想定义一个不带形参的函数，最常用的办法是书写一个空的形参列表。为了与C语言兼容，也可以使用关键字void表示函数没有形参：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span><span class="comment">//隐式的定义空形参列表</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">void</span>)</span><span class="comment">//显示的定义空形参列表</span></span></span><br></pre></td></tr></table></figure><h4 id="函数返回类型"><a href="#函数返回类型" class="headerlink" title="函数返回类型"></a>函数返回类型</h4><p>大多数类型都能用作函数的返回类型。一种特殊的返回类型是void，它表示函数不返回任何值。</p><p>一种特殊的返回值是void：不返回任何值。</p><p>函数的返回类型不能是数组或者函数类型。可以是指针或者引用。</p><h3 id="局部对象"><a href="#局部对象" class="headerlink" title="局部对象"></a>局部对象</h3><p>在c++中，名字有作用域；对象有生命周期。</p><ul><li>名字的作用域是程序文本的一部分，名字在其中可见</li><li>对象的生命周期是程序执行过程中该对象存在的一段时间</li></ul><p>函数体是一个语句块。块构成一个新的作用域，我们可以再其中定义变量。形参和函数体内部定义的变量统称为局部变量。它们对函数而言是局部的，仅在函数的作用域内可见，同时局部变量还会隐藏在外层作用域中同名的其他所有声明中。</p><h4 id="自动对象"><a href="#自动对象" class="headerlink" title="自动对象"></a>自动对象</h4><p>对于普通局部变量对应的对象来说，当函数的控制路径经过变量定义语句时创建对象，到达定义所在的块末尾时销毁它。我们把只存在于块执行期间的对象称为自动对象。</p><p><strong>对于局部变量来说，如果没有初始化的值那就会执行默认初始化，意味着默认初始化内置变量将产生未定义的值。</strong></p><h4 id="局部静态对象"><a href="#局部静态对象" class="headerlink" title="局部静态对象"></a>局部静态对象</h4><p>某些时候，有必要令局部变量的生命周期贯穿函数调用及之后的时间。可以将局部变量定义成static类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">size_t</span> ctr = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p><strong>局部静态对象</strong>在程序第一次执行经过对象定义语句时初始化，并且直到程序终止才被销毁，期间就算函数结束执行也不会对它有影响。</p><p>内置类型局部静态变量默认初始化为0。</p><h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><p>类似于变量，函数只能定义一次，但是可以声明多次。</p><p>函数的声明与定义类似，只是声明无须函数体，用一个分号替代即可。</p><p>函数的三要素(<strong>返回类型、函数名、形参类型</strong>)描述了函数的接口，说明了调用该函数所需的信息。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator beg,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator end)</span></span>;</span><br></pre></td></tr></table></figure><p>函数声明也被称为函数原型。</p><p>函数通常在头文件中进行函数声明而在源文件中定义。</p><h3 id="分离式编译"><a href="#分离式编译" class="headerlink" title="分离式编译"></a>分离式编译</h3><p>随着程序越来越复杂，我们希望把程序的各个部分分别存储在不同文件中。</p><p>分离式编译(separate compilation)允许我们可以根据逻辑关系把程序分离成不同的文件中，每个文件独立编译。</p><h4 id="编译和链接"><a href="#编译和链接" class="headerlink" title="编译和链接"></a>编译和链接</h4><p>比如fact函数定义在一个fact.cc的文件中，它的声明在Chapter6.h的头文件中，在名为factMain.cc的文件中创建main函数调用fact函数。要生成可执行文件必须要告诉编译器需要用到的文件。</p><p>接下来编译器把对象文件(.obj(windows)或.o(unix))链接在一起形成可执行文件。</p><h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p>如前所述，每次调用函数都会重新创建它的形参，并用传入的实参对形参进行初始化。</p><p><strong>形参初始化的机理与变量初始化一样。</strong></p><ul><li>当形参是引用类型时，我们说它对应的实参被<strong>引用传递</strong>或者函数被传引用调用。它将绑定到对应实参上</li><li>当实参的值被拷贝给形参时，形参和实参是相互独立的两个对象。我们说这样的实参被<strong>值传递</strong>或者函数被传值调用</li></ul><h4 id="指针形参"><a href="#指针形参" class="headerlink" title="指针形参"></a>指针形参</h4><p>和其他非引用类型一样。执行指针拷贝操作时，拷贝的是指针的值。拷贝之后两个指针是不同的指针，但是指向的是同一个对象。因为指针使我们可以间接访问它所指的对象，所以通过指针可以修改它所指对象的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wrap</span><span class="params">(<span class="keyword">int</span> *p)</span></span>;</span><br><span class="line">wrap(&amp;a);<span class="comment">//调用</span></span><br></pre></td></tr></table></figure><p><strong>建议</strong>用引用类型的形参代替指针类型。</p><h4 id="传引用参数"><a href="#传引用参数" class="headerlink" title="传引用参数"></a>传引用参数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wrap</span><span class="params">(<span class="keyword">int</span> &amp;r)</span></span>;</span><br><span class="line"></span><br><span class="line">wrap(a);</span><br></pre></td></tr></table></figure><p>使用引用从而避免拷贝。</p><p>可以使用引用参数获得额外的信息：定义一个引用的形参用来获取值</p><h4 id="const形参和实参"><a href="#const形参和实参" class="headerlink" title="const形参和实参"></a><strong>const形参和实参</strong></h4><p>和其他初始化一样，当用实参初始化形参时会忽略顶层const(作用于对象本身)。当形参有const时，传给他常量或者非常量都是可以的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fcn</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> i)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fcn</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;&#125;<span class="comment">//错误：重复定义了fcn(int)</span></span><br></pre></td></tr></table></figure><p>因为上面两个方法传入的参数可以一样，所以是重复定义了。</p><h4 id="指针或引用形参与const"><a href="#指针或引用形参与const" class="headerlink" title="指针或引用形参与const"></a>指针或引用形参与const</h4><p>形参的初始化方式和变量是一样的。我们可以使用非常量初始化一个底层const对象，但是反过来不行：</p><p>也就是，形参参数是int <em>,那么实参不能是const int </em>;</p><p>如果形参参数是int &amp;那么实参不能是const int &amp;。</p><h4 id="数组形参"><a href="#数组形参" class="headerlink" title="数组形参"></a><strong>数组形参</strong></h4><p>数组的两个特殊性质会影响函数的使用：</p><ol><li>数组不能被拷贝（所以不能使用值传递）</li><li>使用数组时通常被转换成指针</li></ol><p>尽管不能以值传递的方式传递数组，但是我们可以把形参写成类似数组的形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>[<span class="number">10</span>])</span></span>;</span><br></pre></td></tr></table></figure><p>以上三个函数是等价的：每个函数的唯一形参都是const int *。定义的第一个维度会被忽略。</p><p><strong>因为不知道长度，所以需要管理形参：</strong></p><p>管理形参的三个方法：</p><ol><li>使用标记指定数组长度：使用c风格字符串，在字符数组中跟一个空字符，那么运行到空字符就停止</li><li>使用标准库规范：传递数组首指针和尾后指针。begin()、end()</li><li>显示传递一个表示数组大小的形参</li></ol><p><strong>数组形参和const</strong></p><p>当函数不需要执行写操作的时候定义为const的指针</p><p><strong>数组引用形参</strong></p><p>可以将引用形参绑定到数组上：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> (&amp;arr)[<span class="number">10</span>])</span></span>;</span><br></pre></td></tr></table></figure><p>括号不可少，这表明arr是具有10个整数的数组引用。这样在函数体内就能放心的使用数组，只要不超过维度。但是这样增加了局限性，这个函数只能作用于大小为10的数组。16.1.1介绍传递任意大小的数组。</p><h4 id="传递多维数组"><a href="#传递多维数组" class="headerlink" title="传递多维数组"></a>传递多维数组</h4><p>传递的就是指向一个数组的指针，数组第二维(以及后面所有的维度)的大小都是数组类型的一部分，不能省略：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> (*matrix)[<span class="number">10</span>], <span class="keyword">int</span> rowSize)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>同样可以用数组的语法定义函数，此时依然会忽略第一个维度：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等价定义</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> matrix[][<span class="number">10</span>, <span class="keyword">int</span> rowSize])</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="main：处理命令行选项"><a href="#main：处理命令行选项" class="headerlink" title="main：处理命令行选项"></a><strong>main：处理命令行选项</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br></pre></td></tr></table></figure><p>第二个参数是指向c风格字符串的指针的数组。第一个参数是数组内的数量。</p><p>比如可执行文件名：prog</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prog -d -o ofile data0</span><br></pre></td></tr></table></figure><p>那么数组argv就是：</p><p>argv[0] = “prog”;         //第0位是执行文件的名字</p><p>argv[1] = “-d”            //接下来就是命令行输入的字符串了</p><p>…</p><p>在vs中设置main()选项：</p><ol><li>右键项目-&gt;属性-&gt;调试</li><li>在命令参数里面写需要写的参数，用空格分开</li></ol><p><img src="/2019/03/05/function/main.png" alt=""></p><p>用cmd命令行则是：</p><p><img src="/2019/03/05/function/cmd.png" alt=""></p><h4 id="可变形参——initializer-list形参"><a href="#可变形参——initializer-list形参" class="headerlink" title="可变形参——initializer_list形参"></a>可变形参——initializer_list形参</h4><p>这是一个标准库类型，如果传入的参数数量是不定的但是类型都相同，那么可以用这个模板类型。</p><p><img src="/2019/03/05/function/initializer-list.png" alt="img"></p><p>像vector一样：</p><p>initializer_list<string> ls;</string></p><p><strong>initializer_list类型</strong>的元素都是常量，因此在用for循环时候不能设为普通引用，编译会报错。（？除非是类类型或者容器类型(比如string)才能将设为引用）。</p><h3 id="返回类型和return"><a href="#返回类型和return" class="headerlink" title="返回类型和return"></a>返回类型和return</h3><p>return语句终止当前正在执行的函数并将控制权返回到调用该函数的地方。</p><p>return语句有两种形式：</p><ol><li>return;</li><li>return expression</li></ol><h4 id="无返回值函数"><a href="#无返回值函数" class="headerlink" title="无返回值函数"></a>无返回值函数</h4><p>void函数可以不加return，函数的最后一句会隐式的地执行return。</p><p>void函数可以执行第二种return但是返回的必须是另一个void的函数</p><h4 id="有返回值函数"><a href="#有返回值函数" class="headerlink" title="有返回值函数"></a>有返回值函数</h4><p>除了void的函数必须要有返回值，不然会编译报错。但是如果某一条路径上没有返回值，则会在运行时报错。</p><p><strong>值的返回</strong></p><p>return一个值的方式和初始化一个变量和形参的方式完全一样。</p><p>但是不能返回一个局部变量的指针或者引用，因为局部变量在函数完成后它的存储空间也被释放掉，那么局部变量(字面值也算)的引用将指向不再有效的内存。</p><p><strong>返回类类型的函数和调用运算符</strong></p><p>调用运算符和点运算符箭头运算符优先级一样并且符合左结合律。因此能如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> sz = shortString(s1, s2).size();</span><br></pre></td></tr></table></figure><p><strong>引用返回左值</strong></p><p>函数的返回类型决定函数调用是否是左值。调用一个返回引用的函数是左值，其他返回类型是右值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> &amp;<span class="title">get_val</span><span class="params">()</span></span>;</span><br><span class="line">get_val(s, <span class="number">0</span>) = ‘A’;<span class="comment">//能给返回的引用赋值</span></span><br></pre></td></tr></table></figure><p><strong>列表初始化返回值</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; process()&#123;</span><br><span class="line"><span class="keyword">return</span> &#123;“a”,”b”,”c”&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>主函数main的返回值</strong></p><p>main函数会隐式在最后一行返回0，它的函数值看作是状态指示器，返回0表示执行成功，别的值则是执行失败。非0的值含义根据机器而定。</p><p>cstdlib头文件里面定义了两个预处理变量，可以用这两个变量表示成功(0)与失败。这样返回值与机器无关：</p><p>EXIT_FALLURE;</p><p>EXIT_SUCCESS;</p><p>main函数不能调用他自己。</p><h4 id="返回数组指针"><a href="#返回数组指针" class="headerlink" title="返回数组指针"></a>返回数组指针</h4><p>因为数组不能被拷贝所以能返回数组的引用或者指针。</p><p>声明一个返回指针的函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Type(*function(parameter _list))[dimension]</span><br></pre></td></tr></table></figure><p>Type表示元素类型，dimension是数组的大小，括号必须存在。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (*func(<span class="keyword">int</span> i))[<span class="number">10</span>];<span class="comment">//func返回一个10个int元素的数组的指针</span></span><br></pre></td></tr></table></figure><p><strong>尾置返回类型</strong></p><p>用于简化函数声明，这种形式对比较复杂的函数返回类型比较有用，上述可定义为：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto func(int i)-&gt;int (*)[10];</span><br></pre></td></tr></table></figure><p>在参数列表后面有一个箭头符号，后面代表返回类型，然后在前面加一个auto。</p><p>使用<strong>decltype</strong></p><p>如果我们知道指针指向哪个数组，就可以使用decltype，但是它返回的是数组，所以我们需要把它在声明时加一个*。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(odd) *func(<span class="keyword">int</span> i)&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>如果同一作用域内的几个函数的名字相同但形参列表不同，称之为重载函数。</p><p>定义：</p><ol><li>形参数量或者形参类型上有所不同。<br>注（以下不算函数重载）：</li><li>如果只是返回类型不同不算函数重载</li><li>省略了形参名字、或只是形参别名也不算</li><li>传入的是顶层const</li></ol><h4 id="重载和const形参"><a href="#重载和const形参" class="headerlink" title="重载和const形参"></a>重载和const形参</h4><p>顶层const不影响传入函数的对象，因此一个顶层const的函数和一个没有const的函数不能区分成两个函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Phone)</span></span>;</span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Phone)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Phone*)</span></span>;</span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Phone* <span class="keyword">const</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>这两组都是重复的声明，因为是顶层const</p><p>如果传入的是底层的const，区分指针或者引用指向的对象是否是const可以区分成<strong>两个</strong>函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Account&amp;)</span></span>;</span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Account&amp;)</span></span>;</span><br></pre></td></tr></table></figure><p>指针同上。</p><h4 id="const-cast-和重载"><a href="#const-cast-和重载" class="headerlink" title="const_cast 和重载"></a>const_cast 和重载</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="built_in">string</span> &amp;<span class="title">shorterString</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s1, <span class="keyword">const</span> <span class="built_in">string</span> &amp;s1)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> s1.size()&gt;s2.size()?s2:s1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传入和返回的都是const类型的string引用，我们想传入普通引用。那么可以用const_cast：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> &amp;<span class="title">shorterString</span><span class="params">(<span class="built_in">string</span> &amp;s1, <span class="built_in">string</span> &amp;s2)</span></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> &amp;r = shorterString(<span class="keyword">const_cast</span>&lt;<span class="keyword">const</span> <span class="built_in">string</span>&amp;&gt;(s1), </span><br><span class="line"><span class="keyword">const_cast</span>&lt;<span class="keyword">const</span> <span class="built_in">string</span>&amp;&gt;(s2));</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;<span class="built_in">string</span>&amp;&gt;(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样操作是安全的。</p><h3 id="重载与作用域"><a href="#重载与作用域" class="headerlink" title="重载与作用域"></a>重载与作用域</h3><p>一般来说函数声明置于全局而不是局部。如果将函数声明在局部，那么会将在外层作用域中同名的函数实体隐藏。在不同作用域中无法重载函数名：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fooBar</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">bool</span> read = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">string</span> s = read();<span class="comment">//错误：read变为bool值而非函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">print(“Value : ”);<span class="comment">//错误：print(const string&amp;)被隐藏了</span></span><br><span class="line">print(<span class="number">1</span>);</span><br><span class="line">print(<span class="number">3.14</span>);<span class="comment">//正确：调用print(int);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上可知，局部声明的函数会隐藏作用域外的同名函数。调用函数时，编译器首先寻找对该函数的声明，找到的是局部声明，就会忽略掉外层的同名实体。</p><h2 id="特殊用途语言特性"><a href="#特殊用途语言特性" class="headerlink" title="特殊用途语言特性"></a>特殊用途语言特性</h2><h3 id="默认实参"><a href="#默认实参" class="headerlink" title="默认实参"></a>默认实参</h3><p>如果一个函数多次调用，传入的参数是相同的那么我们可以设置一个默认参数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">string</span>::size sz;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">screen</span><span class="params">(sz ht = <span class="number">24</span>, sz wid = <span class="number">80</span>, <span class="keyword">char</span> backgrnd = ‘ ’)</span></span>;</span><br></pre></td></tr></table></figure><p>想使用默认实参只需要省略参数就可以了。</p><p>默认实参负责填补函数调用缺少的尾部实参，意思就是如果想要覆盖第三个参数，那么前面两个参数也要给定实参：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window = screen(, , ‘?’);<span class="comment">//错误：只能省略尾部的实参</span></span><br></pre></td></tr></table></figure><h4 id="默认实参声明"><a href="#默认实参声明" class="headerlink" title="默认实参声明"></a>默认实参声明</h4><p>在给定的作用域中一个形参只能被赋予一次默认实参。后续声明只能为没有默认值的形参添加实参，而且该形参的右侧必须都有默认值:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">screen</span><span class="params">(sz, sz, <span class="keyword">char</span> = ‘ ‘)</span></span>;<span class="comment">//char = ‘ ’等同于char c = ‘ ’。</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">screen</span><span class="params">(sz, sz, <span class="keyword">char</span> = ‘*’)</span></span>;<span class="comment">//错误：重复声明了char</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">screen</span><span class="params">(sz=<span class="number">24</span>, sz = <span class="number">80</span>, <span class="keyword">char</span>)</span></span>;<span class="comment">//正确：添加默认实参</span></span><br></pre></td></tr></table></figure><p>如果在局部内声明，那么会<strong>隐藏外层作用域的声明</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">make_plural</span><span class="params">(<span class="keyword">size_t</span>, <span class="keyword">const</span> <span class="built_in">string</span>&amp;, <span class="keyword">const</span> <span class="built_in">string</span>&amp; = <span class="string">"s"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; make_plural(<span class="number">1</span>, <span class="string">"success"</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; make_plural(<span class="number">2</span>, <span class="string">"success"</span>, <span class="string">"es"</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; make_plural(<span class="number">2</span>, <span class="string">"failure"</span>) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//输出failures</span></span><br><span class="line"><span class="comment">//隐藏了外层的声明</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">make_plural</span><span class="params">(<span class="keyword">size_t</span>, <span class="keyword">const</span> <span class="built_in">string</span>&amp; word = <span class="string">"dog"</span>, <span class="keyword">const</span> <span class="built_in">string</span>&amp; = <span class="string">"p"</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; make_plural(<span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//输出dogp</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">make_plural</span><span class="params">(<span class="keyword">size_t</span> c, <span class="keyword">const</span> <span class="built_in">string</span>&amp; word, <span class="keyword">const</span> <span class="built_in">string</span>&amp; ending)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (c &gt; <span class="number">1</span>) ? word + ending : word;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>局部变量不能作为默认实参。除此之外，只要表达式的类型能转换成形参所需的类型就能作为默认实参。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sz wd = <span class="number">80</span>;</span><br><span class="line"><span class="keyword">char</span> def = ‘ ’;</span><br><span class="line"><span class="function">sz <span class="title">ht</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">screen</span><span class="params">(sz=ht(), sz=wd, <span class="keyword">char</span>=def)</span></span>;</span><br></pre></td></tr></table></figure><p>用作默认实参的名字在函数声明所在的作用域内解析：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>&#123;</span><br><span class="line">def=’*’;<span class="comment">//改变默认实参的值</span></span><br><span class="line">sz wd = <span class="number">100</span>;</span><br><span class="line">window = screen();<span class="comment">//调用screen(ht(), 80, ‘*’) def实参被改变了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内联函数和constexpr函数"><a href="#内联函数和constexpr函数" class="headerlink" title="内联函数和constexpr函数"></a>内联函数和constexpr函数</h3><p>内联函数可以避免函数调用的开销：将函数指定为内联inline，通常就是将他在每个调用点上内联的展开。内联说明只是向编译器发出的一个请求，编译器可以忽略。一般用于优化规模小、流程直接、调用频繁的函数。</p><h4 id="constexpr函数"><a href="#constexpr函数" class="headerlink" title="constexpr函数"></a>constexpr函数</h4><p>constexpr函数是指能用于常量表达式的函数，它的函数返回类型以及所有的形参类型都得是<strong>字面值</strong>类型，而且只能有一条return语句。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">new_sz</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="number">42</span>;&#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> foo = new_sz();<span class="comment">//正确foo是一个常量表达式</span></span><br></pre></td></tr></table></figure><p>在初始化变量时候，编译器会验证new_sz函数返回值是否是常量表达式，如果是那么就能初始化成功。</p><p>为了能在编译过程中随时展开，constexpr函数被隐式的指定为内联函数。</p><p><strong>允许constexpr的返回值不是常量</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> size_t <span class="title">scale</span><span class="params">(<span class="keyword">size_t</span> cnt)</span></span>&#123;<span class="keyword">return</span> new_sz()*cnt;&#125;</span><br><span class="line"><span class="keyword">int</span> arr[scale(<span class="number">2</span>)];<span class="comment">//正确</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> a2[scale(i)];<span class="comment">//错误</span></span><br></pre></td></tr></table></figure><p>如上，数组初始化值只能是常量表达式，当传入一个字面值是2的常量表达式时scale函数返回的也是常量表达式，反之传入非常量表达式i返回的也是非常量表达式。那么编译器会发出错误信息。</p><p><strong>constexpr函数和内联函数放在头文件内</strong></p><p>和其他函数不一样，这两个函数能定义多次，但是它的多个定义必须一致。所以放在头文件中。</p><h3 id="assert预处理宏和NDEBUG预处理变量"><a href="#assert预处理宏和NDEBUG预处理变量" class="headerlink" title="assert预处理宏和NDEBUG预处理变量"></a>assert预处理宏和NDEBUG预处理变量</h3><p>assert是一个预处理宏，行为类似内联函数。使用一个表达式作为他的条件：</p><p>assert(expr)；</p><p>如果表达式为假(即0)，那么assert输出信息并且终止程序的运行。</p><p>assert定义在 cassert头文件中，预处理变量和宏名字在程序内都唯一不需要提供using声明。不能定义assert为名字的其他变量或者函数名。</p><p>NDEBUG：</p><p>如果定义了NDEBUG预处理变量，那么assert就不会被检查。也就是失效</p><p>预处理定义了几个对程序调试很有用的名字：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func__<span class="comment">//存放函数名的const char数组</span></span><br><span class="line"></span><br><span class="line">__FILE__<span class="comment">//存放文件名的字符串字面值</span></span><br><span class="line"></span><br><span class="line">__LINE__<span class="comment">//存放当前行号的整型字面值</span></span><br><span class="line"></span><br><span class="line">__TIME__<span class="comment">//存放编译时间的字符串字面值</span></span><br><span class="line"></span><br><span class="line">__DATE__<span class="comment">//存放文件编译日期的字符串字面值</span></span><br></pre></td></tr></table></figure><h2 id="函数匹配"><a href="#函数匹配" class="headerlink" title="函数匹配"></a>函数匹配</h2><p>当几个重载函数的形参数量相等以及某些形参的类型可以由其他类型转换得来时，进行函数匹配的流程如下：</p><ol><li>选定本次调用的<strong>候选函数</strong>：<ol><li>与被调用函数同名</li><li>其声明在调用点可</li></ol></li><li>选出<strong>可行函数</strong>：<ol><li>其形参数量跟本次调用实参数量相等</li><li>每个实参对应的类型相同或者能转换成形参类型</li></ol></li><li>寻找最佳匹配：基本思想是实参类型与形参类型越接近，它们<strong>匹配的越好（实参类型转换）</strong>。满足下面两个条件才算匹配成功：<ol><li>该函数每个实参的匹配的都不劣于其他可行函数需要的匹配</li><li>至少有一个实参的匹配优于其他可行函数提供的匹配</li></ol></li></ol><p>例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> , <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">double</span>, <span class="keyword">double</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">f(<span class="number">5</span>,<span class="number">2.3</span>);</span><br></pre></td></tr></table></figure><p>上面这个调用会产生二义性，因为在第一个参数上匹配int精确匹配，但是在第二个参数上需要转成int；或者匹配double，第一个参数需要转。</p><p>调用重载函数尽量避免强制转换。如果需要则说明设计不合理。</p><h4 id="实参类型转换"><a href="#实参类型转换" class="headerlink" title="实参类型转换"></a>实参类型转换</h4><p>为了确定最佳匹配，编译器将实参类型到形参类型的转换划分为几个等级如下：</p><ol><li><p>精确匹配：</p><p>(1) 实参类型和形参类型相同</p><p>(2) 实参从数组类型或函数类型转换成对应的指针类型</p><p>(3) 向实参添加顶层const或者从实参中删除顶层const</p></li><li><p>通过const转换实现的匹配</p></li><li><p>通过类型提升(char-&gt;int)</p></li><li><p>通过算数类型转换(int -&gt; long)</p></li><li><p>通过类类型转换实现的匹配</p></li></ol><p>第4点：所有算术类型转换的级别都一样。比如从int到unsigned int或者double的级别是一样的。一个double如果能转到long跟float那么存在二义性</p><p>第2点：函数匹配和const实参：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Account&amp;)</span></span>;</span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Account&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Account a;</span><br><span class="line">Account b;</span><br><span class="line"></span><br><span class="line">lookup(a);<span class="comment">//调用lookup(const Account&amp;)</span></span><br><span class="line">lookup(b);<span class="comment">//调用lookup(Account&amp;)</span></span><br></pre></td></tr></table></figure><p>第二个调用中传入b。对于这个调用来说两个函数都是可行的，我们可以用b初始化常量引用。但是需要转换。所以精确匹配到了非常量引用的函数</p><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>函数指针指向的是函数而非对象。函数的类型由返回类型和形参类型决定：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> (*pf) (<span class="keyword">const</span> <span class="built_in">string</span>&amp;, <span class="keyword">const</span> <span class="built_in">string</span>&amp;);</span><br></pre></td></tr></table></figure><p>pf是一个指向函数的指针，这个函数返回bool并且参数列表是两个const string &amp;</p><p>把函数名作为值使用时，自动转成指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pf = lengthCompare;</span><br><span class="line">pf = &amp; lengthCompare;<span class="comment">//等价的赋值</span></span><br></pre></td></tr></table></figure><p>在使用指针的时候也可以不需要解引用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> b1 = pf();</span><br><span class="line"><span class="keyword">bool</span> b2 = (*pf)();<span class="comment">//等价的调用函数</span></span><br></pre></td></tr></table></figure><p>在指向不同函数类型间不存在转换规则，但是可以指向nullptr。</p><p>使用重载函数时，必须清晰的界定选用那个函数，必须精确匹配。</p><h4 id="函数形参"><a href="#函数形参" class="headerlink" title="函数形参"></a>函数形参</h4><p>和数组类似，函数不能定义成形参，但是形参可以是指向函数的指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">useBigger</span><span class="params">(<span class="keyword">bool</span> pf(<span class="keyword">const</span> <span class="built_in">string</span>&amp;,<span class="keyword">const</span> <span class="built_in">string</span>&amp;))</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">useBigger</span><span class="params">(<span class="keyword">bool</span> (*pf)(<span class="keyword">const</span> <span class="built_in">string</span>&amp;,<span class="keyword">const</span> <span class="built_in">string</span>&amp;))</span></span>;<span class="comment">//等价的声明</span></span><br></pre></td></tr></table></figure><p>我们可以直接把函数当成实参使用，他会自动转成指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useBigger(lengthCompare);</span><br></pre></td></tr></table></figure><p>使用typedef别名能简化函数名：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">bool</span> <span class="title">Func</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;,<span class="keyword">const</span> <span class="built_in">string</span>&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(lengthCompare)</span> Func2</span>;<span class="comment">//同上，func2是函数类型</span></span><br></pre></td></tr></table></figure><p>在上述func前加*就是函数指针。</p><h4 id="返回函数的指针"><a href="#返回函数的指针" class="headerlink" title="返回函数的指针"></a>返回函数的指针</h4><p>和数组一样，不能直接返回一个函数但是可以返回函数指针。</p><p>使用类型别名显得方便：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> F = <span class="keyword">int</span>(<span class="keyword">int</span>*, <span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">using</span> PF = <span class="keyword">int</span>(*)(<span class="keyword">int</span>*, <span class="keyword">int</span>);<span class="comment">//PF是指针类型</span></span><br><span class="line"></span><br><span class="line"><span class="function">PF <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span></span>;<span class="comment">//正确：PF是指向函数的指针</span></span><br><span class="line"><span class="function">F <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span></span>;<span class="comment">//错误：不能返回函数</span></span><br><span class="line"><span class="function">F *<span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span></span>;<span class="comment">//正确：显示声明指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> (*f1(<span class="keyword">int</span>))(<span class="keyword">int</span>*, <span class="keyword">int</span>);<span class="comment">//同上声明</span></span><br></pre></td></tr></table></figure><p>由内向外阅读：f1是一个函数，返回的是一个指针类型。指针类型指向的是返回int的函数，参数列表是(int *，int)</p><p><strong>使用尾置返回类型的方式显得更加完整</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto f1(int) -&gt; int (*)(int*, int);</span><br></pre></td></tr></table></figure><p>同时如果知道返回类型指向的是哪个函数就可以使用decltype:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(sunLength) *getFcn(<span class="keyword">const</span> <span class="built_in">string</span>&amp;);<span class="comment">//注意需要加*</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;函数&quot;&gt;&lt;a href=&quot;#函数&quot; class=&quot;headerlink&quot; title=&quot;函数&quot;&gt;&lt;/a&gt;函数&lt;/h1&gt;&lt;h2 id=&quot;函数基础&quot;&gt;&lt;a href=&quot;#函数基础&quot; class=&quot;headerlink&quot; title=&quot;函数基础&quot;&gt;&lt;/a&gt;函数基础&lt;/h
      
    
    </summary>
    
      <category term="C++Primer笔记" scheme="http://yoursite.com/categories/C-Primer%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="function" scheme="http://yoursite.com/tags/function/"/>
    
      <category term="函数" scheme="http://yoursite.com/tags/%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>语句</title>
    <link href="http://yoursite.com/2019/03/04/statement/"/>
    <id>http://yoursite.com/2019/03/04/statement/</id>
    <published>2019-03-04T13:26:46.000Z</published>
    <updated>2019-03-04T13:32:24.547Z</updated>
    
    <content type="html"><![CDATA[<h1 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h1><h3 id="简单语句"><a href="#简单语句" class="headerlink" title="简单语句"></a>简单语句</h3><p>c++中大多数语句都以分号结束，一个表达式，比如<code>ival + 5</code>，末尾加上分号就变成了<strong>表达式语句</strong>。</p><p>表达式语句的作用是执行表达式并丢弃掉求值结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ival + <span class="number">5</span>;<span class="comment">//一条没什么用的表达式</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ival;<span class="comment">//一条输出表达式</span></span><br></pre></td></tr></table></figure><h4 id="空语句"><a href="#空语句" class="headerlink" title="空语句"></a>空语句</h4><p>最简单的语句是<strong>空语句(null statement)</strong>，只有一个单独的分号:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;<span class="comment">//空语句</span></span><br></pre></td></tr></table></figure><p>如果在某个地方，语法上需要一条空语句而逻辑上不需要，此时应该使用空语句。</p><p>例：当循环的全部工作在条件部分完成时，通常用到空语句。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重复读入数据直至到达文件末尾或依次输入的值等于sought</span></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span>&gt;&gt;s &amp;&amp; s!=sought)</span><br><span class="line">;<span class="comment">//空语句</span></span><br></pre></td></tr></table></figure><p>需要注意的是，因为空语句也是一条语句，所以可用在任何需要语句的地方。所以，要是多了个分号有可能会造成严重错误，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//出现糟糕的情况：额外的分号，循环体是空语句</span></span><br><span class="line"><span class="keyword">while</span>( iter!=sevc.end()) ;</span><br><span class="line">++iter;</span><br></pre></td></tr></table></figure><p>虽然while下面那行有缩进，但是他的循环体是后面的空语句，会造成死循环。</p><h4 id="复合语句-块"><a href="#复合语句-块" class="headerlink" title="复合语句(块)"></a>复合语句(块)</h4><p>复合语句(compound statement)是指用花括号{}括起来(可能是空的)的语句和声明的序列，也被称作块(block)。同样的在块中定义的名字只能在块内部以及嵌套在块中的子块访问。</p><p>如果在程序的某个地方，语法上需要一条语句，但是逻辑上需要多条语句，则应该使用复合语句。</p><p><strong>例如while和for的循环体必须是一条语句</strong>，但是我们常常需要做很多事情，因此需要将多条语句用花括号括起来变成复合语句，<strong>将语句序列变成块</strong>。</p><h3 id="语句作用域"><a href="#语句作用域" class="headerlink" title="语句作用域"></a>语句作用域</h3><p>可以在if、switch、while、for语句的控制结构内定义变量，这些变量只有在语句的内部可见，一旦语句结束，会自动销毁。</p><p>如果其他代码也需要访问控制变量，则变量必须定义在语句的外部。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">int</span> i = get_num())<span class="comment">//每次迭代创建并初始化i</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">i = <span class="number">0</span>;<span class="comment">//错误，外部无法访问i</span></span><br></pre></td></tr></table></figure><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><p>c++提供了两种按条件执行的语句。</p><ul><li>一种是if语句，他根据条件决定控制流；</li><li>第二种是switch语句，它计算一个整型表达式的值，然后根据这个值从几条执行路径中选择一条。</li></ul><h4 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h4><p>if语句的作用：判断一个条件是否为真，根据判断结果决定是否执行另一条。</p><p>它有两种形式，一种有else，另一种没有：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition)</span><br><span class="line">statement</span><br></pre></td></tr></table></figure><p><strong>if else</strong>语句的形式是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition)</span><br><span class="line">statement1</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">statement2</span><br></pre></td></tr></table></figure><p>如果condition为真，执行statement1；如果为假，执行statement2。</p><p><strong>悬垂else</strong></p><p>当一个if语句嵌套在另一个if语句内部时，很可能if比else多，那么如何对应else是哪个if的呢，这个问题叫做悬垂else。</p><p><strong>c++规定else与离它最近尚未匹配的if匹配，从而消除了二义性。</strong></p><p><strong>使用花括号控制执行路径</strong></p><p>通常使用花括号来控制if与else匹配以达到我们想要的结果。例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (condition1)&#123;</span><br><span class="line">    if(condition2)</span><br><span class="line">    statement1</span><br><span class="line">&#125;else//这个花括号让else与最外层if匹配。</span><br><span class="line">statement2</span><br></pre></td></tr></table></figure><h4 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h4><p>switch语句适用于在若干固定选项中做出选择。例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(ch)&#123;</span><br><span class="line"><span class="keyword">case</span> ‘a’:</span><br><span class="line">++aCnt;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> ‘b’:</span><br><span class="line">++bCnt;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> ‘c’:</span><br><span class="line">++cCnt;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">++count;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>switch的执行流程：</p><ol><li>首先对括号里的表达式进行求值，该表达式紧跟在关键字switch后面，可以是初始化的变量声明，如: int ch = get_char()</li><li>表达式的值转换成整数类型，然后与每个case标签的值比较</li><li>如果匹配成功，程序从该标签之后的第一条语句开始执行，直到break或者switch结尾。</li><li>如果没有匹配上，则跳到switch之后的第一条语句。</li></ol><p>case关键字和它对应的值一起被称为case标签(case label)。</p><ul><li>case标签的值必须是<strong>整型常量表达式</strong></li><li>任意两个case标签的值不能相同</li></ul><p><strong>default</strong></p><p>如果没有任何一个case标签能够匹配上switch表达式的值，程序将执行default标签后面的语句。</p><p>即时不准备在default标签下 做任何工作，定义一个default标签也是有用的。如果switch结构以一个空的default标签作为结束，则该default标签后面必须跟上一条空语句或一个空块。</p><p><strong>switch内部的变量定义</strong></p><p>switch的执行流程有可能会跨过某些case标签。如果跳转到了某个特定的case，而在之前忽略的case里面有变量的初始化，那么是非法行为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="literal">true</span>:</span><br><span class="line"><span class="built_in">string</span> file_name;<span class="comment">//错误，控制流绕过一个隐式初始化的变量</span></span><br><span class="line"><span class="keyword">int</span> ival = <span class="number">0</span>;<span class="comment">//错误，控制流绕过一个显示初始化的变量</span></span><br><span class="line"><span class="keyword">int</span> jval;<span class="comment">//正确：jval没有被初始化</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="literal">false</span>:</span><br><span class="line"><span class="comment">//变量jval在作用域内 但是没有被初始化。</span></span><br><span class="line">jval = next_num();</span><br><span class="line"><span class="keyword">if</span>(file_name.empty());</span><br></pre></td></tr></table></figure><p><strong>所以我们应该把变量的定义放在块内，这样保证了每个case里的变量有自己的作用域 。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="literal">true</span>:</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">string</span> file_name = get_file_name();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="迭代语句"><a href="#迭代语句" class="headerlink" title="迭代语句"></a>迭代语句</h3><p>迭代语句通常称为循环，它重复执行操作直到满足某个条件才停止。</p><p>while循环特别适用于条件保持不变。反复执行操作的情况，例如，当未达到文件末尾时不断读取下一个值。</p><p>for循环更像在按步骤迭代，它的索引值在某个范围内依次变化，<strong>结构严谨</strong>。</p><h4 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h4><p>只要条件为真，while语句就一直执行，语法形式如下：</p><p>while(condition){<br>    statement<br>}</p><p><strong>定义在while条件部分或者循环体内的变量每次迭代都经历从创建到销毁的过程。</strong></p><p><strong>不定数量的输入：</strong></p><p>while(cin&gt;&gt;value) : 当使用一个istream作为条件时其效果检测流的状态。当遇到end-if-file，或无效输入(值不为整数),istream状态会变为无效。则条件为假.<br>文件结束符end-of-file: windows 为Ctrl+Z，unix为Ctrl+D</p><h4 id="传统的for语句"><a href="#传统的for语句" class="headerlink" title="传统的for语句"></a>传统的for语句</h4><p>for语句的语法形式是</p><p>for(init-statement;condition;expression)</p><p>​    statement</p><p><strong>传统for循环的执行流程</strong></p><ol><li>循环开始时，执行一次init-statement。</li><li>接下来判断condition。如果为真则执行，否则终止循环。</li><li>最后执行expression。</li></ol><p><strong>for语句头中的多重定义</strong></p><p>init-statement可以定义多个对象。但是它只能有一条声明语句，因此所有变量的基本类型必须相同。</p><p><strong>省略for语句头中的某些部分</strong></p><p>for 语句能省略三个里面的任何一个或者全部：</p><ol><li>如果无需初始化，我们可以使用一条空语句作为init-statement</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> beg = v.begin();</span><br><span class="line"><span class="keyword">for</span>( ; beg!=v.end() &amp;&amp; *beg&gt;<span class="number">0</span>; ++beg)</span><br><span class="line">;</span><br></pre></td></tr></table></figure><ol start="2"><li>省略condition相当于在条件部分写了一个true。所以我们必须在循环体内有语句负责退出循环。</li><li>省略掉expression，就要求在条件部分或者循环体内改变迭代变量的值。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i; <span class="built_in">cin</span>&gt;&gt;i ; )</span><br><span class="line">v.push_back(i);</span><br></pre></td></tr></table></figure><h4 id="范围for语句"><a href="#范围for语句" class="headerlink" title="范围for语句"></a>范围for语句</h4><p>这种语句可以遍历容器或其他序列的所有元素。语法形式如下：</p><p>for (declaration : expression)</p><p>​    statement</p><p>expression表示的必须是一个序列，比如用花括号括起来的初始值列表、数组、vector或string等类型的对象，这些类型的共同特点是拥有能返回<strong>迭代器的begin和end</strong>成员。</p><p>declaration 定义一个变量，序列中每个元素都能转换成该变量的类型。</p><p>如果需要对序列中元素执行写操作，循环变量必须声明成引用类型。</p><p>例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;r : v)</span><br><span class="line">r*=<span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>在范围for中预存了end()的值，如果在序列中添加或删除元素，end函数的值就可能变的无效了。</p><h4 id="do-while语句"><a href="#do-while语句" class="headerlink" title="do while语句"></a>do while语句</h4><p>do while语句和while语句非常相似，唯一的区别是do while语句先执行循环体后检查条件。不管条件的值如何，我们都至少执行一次。do while的语法形式如下：</p><p>do</p><p>​    statement</p><p>while(condition);</p><p>对于do while语句来说限制性语句块，后判断条件。<strong>所以不允许在条件部分定义变量。</strong></p><p>例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ival = <span class="number">1</span>;<span class="comment">//condition中的变量只能定义在do while之外。</span></span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">ival = get_num();</span><br><span class="line">&#125;<span class="keyword">while</span>(ival);</span><br></pre></td></tr></table></figure><h3 id="跳转语句"><a href="#跳转语句" class="headerlink" title="跳转语句"></a>跳转语句</h3><p>跳转语句中断当前的执行过程。c++语言提供了4种跳转语句：break、continue、goto和return。</p><h4 id="break语句"><a href="#break语句" class="headerlink" title="break语句"></a>break语句</h4><p>break语句负责终止离他最近的while、do while、for或switch语句。</p><h4 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h4><p>终止最近的循环中的当前迭代并开始下一次迭代，只能出现在for、while和do while循环的内部。</p><p>对于while 和 do while来说，继续判断条件的值;对于传统for，继续执行expression；对于范围for则是用序列中的下一个元素循环控制变量。</p><h4 id="goto-不要使用"><a href="#goto-不要使用" class="headerlink" title="goto(不要使用)"></a>goto(不要使用)</h4><p>goto语句的作用是从goto语句无条件跳转到同一函数内的另一条语句。</p><p><strong><u>注意：不要在程序中使用goto语句，因为它使得程序既难理解又难修改。</u></strong></p><p>语法形式如下：</p><p>goto label;    </p><p>label是用于标识一条语句的标识符。    带标签语句是一种特殊的语句，在它之前有一个标示符以及一个冒号：</p><p>end: return;        //end是标签后面跟语句</p><p>和switch一样他也不能将程序的控制权冲变量的作用域之外转移到作用域之内：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">goto</span> end;</span><br><span class="line"><span class="keyword">int</span> ix = <span class="number">10</span>;<span class="comment">//错误：goto语句桡骨了一个带初始化的变量定义</span></span><br><span class="line">end:</span><br><span class="line">ix = <span class="number">42</span>;<span class="comment">//错误：此处需要用到ix 但是goto跳过了声明</span></span><br></pre></td></tr></table></figure><p>goto跳回到定义变量之前是合法的，相当于销毁后重新定义。</p><h3 id="try语句块和异常处理"><a href="#try语句块和异常处理" class="headerlink" title="try语句块和异常处理"></a><strong>try语句块和异常处理</strong></h3><p>异常是指存在于运行时的反常行为，这些行为超出了函数正常功能的范围。典型的异常包括失去数据库连接以及遇到意外输入等。</p><p>异常处理机制为程序中<strong>异常检测和异常处理</strong>这两部分的协作提供支持。</p><p>异常处理机制包括：</p><ul><li><strong>throw表达式</strong>，异常检测部分用throw表达式来表示它遇到了无法处理的问题。我们说throw引发了异常。</li><li><strong>try语句块</strong>，异常处理部分使用try语句块处理异常，try语句块以关键字try开始，并以一个或多个catch子句结束。try语句块中抛出的异常通常会被某个catch子句处理。因为catch子句处理异常，所以它们也被称作<strong>异常处理代码</strong></li><li>一套<strong>异常类</strong>，用于在throw表达式和相关的catch子句之间传递异常的具体信息。</li></ul><h4 id="throw表达式"><a href="#throw表达式" class="headerlink" title="throw表达式"></a>throw表达式</h4><p>检测部分用throw表达式引发一个异常。throw表达式包含关键字throw和紧随其后的一个表达式，其中表达式的类型就是抛出的异常类型。</p><p>例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> runtime_error(“Data must refer to same ISBN”);</span><br></pre></td></tr></table></figure><h4 id="try语句块"><a href="#try语句块" class="headerlink" title="try语句块"></a><strong>try语句块</strong></h4><p>try语句块的语法形式：</p><p><strong>try{</strong></p><p>​    program-statement</p><p><strong>} catch (exception-declaration){</strong></p><p>​    handler-statement</p><p><strong>} catch (exception-declaration){</strong></p><p>​    handler-statement</p><p><strong>}</strong>//…</p><p>try后面跟一个或多个catch，try语句块内有检测异常的代码。catch后面的括号是一个异常声明，捕获到之后执行所在的语句块来处理异常。</p><p>寻找处理代码的过程跟函数调用链刚好相反。当异常被抛出时，首先搜索抛出该异常的函数。如果没有匹配到catch子句，终止该函数，并且在调用该函数的函数中寻找。如果找不到则转到名为 terminate的标准库函数。</p><h4 id="标准异常"><a href="#标准异常" class="headerlink" title="标准异常"></a><strong>标准异常</strong></h4><p>c++标准库定义了一组异常类，分别定义在4个头文件中：</p><ol><li>exception头文件定义了最通用的异常类exception。它至报告异常发生，不提供任何额外信息。</li><li>stdexcept头文件定义了下表的几种异常类。</li><li>new头文件定义了bad_alloc异常类型12.1.2</li><li>type_info 定义了bad_cast异常类型19.2</li></ol><p><img src="/2019/03/04/statement/stdexcept.png" alt=""></p><p>exception、bad_alloc和bad_cast对象只能以默认初始化方式进行初始化；</p><p>而其他异常类型洽洽相反，因使用string对象或者c风格字符串初始化，并且不允许默认初始化方式。创建此类对象必须提供<strong>初始值</strong>，这个对象初始值是用于提示异常的文本信息。</p><p>异常类型值定义了一个名为what的成员函数，该函数没有任何参数，返回值是一个C风格字符串的const char*。对于其他无初始值的异常类型 what返回的内容由编译器决定。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;语句&quot;&gt;&lt;a href=&quot;#语句&quot; class=&quot;headerlink&quot; title=&quot;语句&quot;&gt;&lt;/a&gt;语句&lt;/h1&gt;&lt;h3 id=&quot;简单语句&quot;&gt;&lt;a href=&quot;#简单语句&quot; class=&quot;headerlink&quot; title=&quot;简单语句&quot;&gt;&lt;/a&gt;简单语句&lt;/h
      
    
    </summary>
    
      <category term="C++Primer笔记" scheme="http://yoursite.com/categories/C-Primer%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="statement" scheme="http://yoursite.com/tags/statement/"/>
    
      <category term="语句" scheme="http://yoursite.com/tags/%E8%AF%AD%E5%8F%A5/"/>
    
  </entry>
  
  <entry>
    <title>表达式与运算符</title>
    <link href="http://yoursite.com/2019/03/01/expression-operate/"/>
    <id>http://yoursite.com/2019/03/01/expression-operate/</id>
    <published>2019-03-01T11:57:07.000Z</published>
    <updated>2019-03-04T14:00:14.749Z</updated>
    
    <content type="html"><![CDATA[<h1 id="表达式与运算符-附表"><a href="#表达式与运算符-附表" class="headerlink" title="表达式与运算符(附表)"></a>表达式与运算符(附表)</h1><p>表达式由一个或多个运算对象组成，对表达式求值将得到一个结果。</p><p><strong>字面值</strong>和<strong>变量</strong>是最简单的表达式，其结果就是它们的值。</p><p>把一个运算符和一个或多个运算对象组合起来可以生成较复杂的表达式。</p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>c++定义了一元运算符和二元运算符，作用于一个运算对象的运算符是一元比如说取地址符(&amp;)和解引用符(*)。</p><p>作用于两个对象的是二元比如乘法运算符(*)。</p><p>此外还有作用于三个运算对象的三元运算符。</p><p>函数调用也是一种特殊的运算符，它对运算对象的数量没有限制。</p><h4 id="组合运算符和运算对象"><a href="#组合运算符和运算对象" class="headerlink" title="组合运算符和运算对象"></a>组合运算符和运算对象</h4><p><strong>对于含有多个运算符和运算对象的复杂表达式来说，得先理解运算符的优先级、结合律以及求值顺序</strong>。</p><h4 id="运算对象转换"><a href="#运算对象转换" class="headerlink" title="运算对象转换"></a>运算对象转换</h4><p>在表达时求值中，运算对象常常由一种类型转换成另一种类型。例如：</p><p>整数和浮点数能互相转换，而通常小整数(bool、char、short等)会被提升成较大的整数类型，主要是int。更多了解——<strong><a href="../type-conversion.md">类型转换</a></strong></p><h4 id="重载运算符"><a href="#重载运算符" class="headerlink" title="重载运算符"></a>重载运算符</h4><p>当运算符作用于类类型的对象时用户可以自行定义其含义。称之为重载运算符，比如IO库的&gt;&gt;和&lt;&lt;运算符以及string、vector对象和迭代器使用的运算符都是。</p><p>重载运算符时，其包括运算对象的类型和返回值的类型，都是由该运算符定义的；<strong>但是运算对象的个数、运算符的优先级和结合律都是无法改变的</strong>。</p><h4 id="求值顺序"><a href="#求值顺序" class="headerlink" title="求值顺序"></a>求值顺序</h4><p>优先级规定了运算对象的组合方式，但是没有说明运算对象按照什么顺序求值。在大多数情况下不会明确求值顺序。对于如下表达式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = f1() * f2();</span><br></pre></td></tr></table></figure><p>我们不知道f1()和f2()哪个先调用。</p><p>对于那些没有指定执行顺序的运算符来说，如果表达式指向了同一个对象，将会引发错误并产生未定义的行为。例如&lt;&lt;:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; i &lt;&lt; “ ”&lt;&lt; ++i &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>我们不知道是先++i还是先输出i再++。编译器可能先求++i的值那么结果是1 1，也可能先输出i那么结果是0 1。因为此表达式的行为不可预知，因此编译器生成什么样的代码程序都是错误的。</p><p><strong>但是有四种运算符明确规定了运算对象的求值顺序。 逻辑与(&amp;&amp;)、逻辑或(||)、条件(?:)、逗号(,)。</strong></p><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p><img src="/2019/03/01/expression-operate/arithmetic.png" alt=""></p><p>按照运算符的优先级分组，一元运算符最高。上面所有运算符都满足左结合律。</p><p>取余：如果m和n是整数且n非0，则表达式(m/n)*n+m%n的求值结果与m相等:</p><p>m%(-n) 就是 m%n、 -m%n 就是-(m%n)。</p><h4 id="逻辑-和-关系运算符"><a href="#逻辑-和-关系运算符" class="headerlink" title="逻辑 和 关系运算符"></a>逻辑 和 关系运算符</h4><p><img src="/2019/03/01/expression-operate/logic.png" alt=""></p><p>逻辑与(&amp;&amp;)：当且仅当两个运算对象都为真适才为真；逻辑或(||)：只要有一个为真结果就为真。</p><p>逻辑与和逻辑或都是先算左边运算对象值，如果无法确定表达式结果才算右侧运算对象的值。—称为短路求值</p><ul><li>对于逻辑与(&amp;&amp;)运算符来说，当且仅当左侧运算对象为真时才对右侧对象求值</li><li>对于逻辑或(||)运算符来说，当且仅当左侧运算对象为假时才对右侧对象求值</li></ul><h4 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h4><p><strong>赋值运算符的左侧对象必须是一个可修改的左值(更多了解——<a href="">左值与右值</a>)。</strong></p><p>下面的赋值语句都是非法的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>,k=<span class="number">0</span>; <span class="comment">//初始化非赋值</span></span><br><span class="line"><span class="number">1024</span> = k;<span class="comment">//错误：字面值是右值</span></span><br><span class="line">(<span class="keyword">const</span>类型)ci = k;   <span class="comment">//错误：ci是常量不可修改的左值</span></span><br></pre></td></tr></table></figure><p>也允许用花括号括起来的初始值列表来赋值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">k=&#123;<span class="number">3.14</span>&#125;<span class="comment">//错误：窄化转换</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line">vi = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;<span class="comment">//vi现在有10个元素了</span></span><br></pre></td></tr></table></figure><p><strong>赋值运算满足右结合律:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line">a = b = <span class="number">0</span>;<span class="comment">//正确：都被赋值为0</span></span><br></pre></td></tr></table></figure><p>对于多重赋值运算，必须是可以由右边对象的类型转换得到：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ival, *pval;</span><br><span class="line">ival = pval = <span class="number">0</span>; <span class="comment">//错误：不能把指针的值赋给int</span></span><br></pre></td></tr></table></figure><h4 id="递增和递减运算符-–"><a href="#递增和递减运算符-–" class="headerlink" title="递增和递减运算符(++/–)"></a>递增和递减运算符(++/–)</h4><p>递增和递减运算符有两种形式：前置版本和后置版本。</p><p>这两种运算符必须作用于左值运算对象。</p><p>前置版本将运算对象加减1然后将<strong>改变后的运算对象</strong>作为求值结果(左值)，而后置版本则返回运算对象<strong>改变之前的值</strong>的副本(右值)。</p><p><strong><u>建议</u></strong>：使用前置版本可以避免了拷贝对象的额外开销。</p><p>例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span>&lt;&lt;*iter++&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>由于递增运算符高于解引用运算符，所以上述代码等于*(iter++)。先将iter的值加1但是返回的是iter原来的值。等同于：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span>&lt;&lt;*iter&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">++iter;</span><br></pre></td></tr></table></figure><p>如果使用的是++iter 那么是先将iter+1再参与运算。</p><p><strong>运算对象可按任意顺序求值：</strong></p><p>一般情况没影响。然而如果一条子表达式改变了某个运算对象的值，另一条子表达式又要用该值的话，那就要提防在复合表达式中错用这两个运算符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it = s.begin();it!=s.end()&amp;&amp;!<span class="built_in">isspace</span>(*it);++it)&#123;</span><br><span class="line">*it = <span class="built_in">toupper</span>(*it);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果将上述代码改为下面这条，则会有问题：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(it!=s.end()&amp;&amp;!<span class="built_in">isspace</span>(*it))&#123;</span><br><span class="line">*it = <span class="built_in">toupper</span>(*it++);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这将产生未定义的行为，问题在于：赋值运算左右两端的运算对象都用到了it，并且右侧运算对象还改变了it的值，编译器可能按照任意一种思路处理该表达式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*it = <span class="built_in">toupper</span>(*it);<span class="comment">//如果先求左侧的值</span></span><br><span class="line">*(it+<span class="number">1</span>) = <span class="built_in">toupper</span>(*it);<span class="comment">//如果先求右侧的值</span></span><br></pre></td></tr></table></figure><h4 id="成员访问运算符"><a href="#成员访问运算符" class="headerlink" title="成员访问运算符"></a><strong>成员访问运算符</strong></h4><p>点运算符(.) 和 箭头运算符(-&gt;)都可以用于访问成员，其中点运算符是获取类对象的一个成员；箭头运算符和点运算符有关  :  <strong>prt-&gt;mem</strong> 等价于 <strong>(*ptr).mem</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s1 = “a <span class="built_in">string</span>”, *p=&amp;s1;</span><br><span class="line"><span class="keyword">auto</span> n = s1.size();</span><br><span class="line">n = (*p).size();<span class="comment">//运行p所指对象的size成员</span></span><br><span class="line">n = p-&gt;size();<span class="comment">//等价于(*p).size()</span></span><br></pre></td></tr></table></figure><p>点运算符优先于解引用运算符，所以当*p.size()需要括号 (*p).size。</p><p>箭头运算符作用于一个指针类型的运算对象，结果是一个左值。</p><p>点运算符分情况：如果成员所属的对象是左值，那么结果是左值；反之，结果是右值。</p><h4 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符(?:)"></a>条件运算符(?:)</h4><p>条件运算符允许我们把简单的if-else逻辑嵌入到单个表达式中，条件运算符按照如下形式使用：</p><p>cond? expr1 : expr2;</p><p>cond是判断条件的表达式，而expr1和expr2是两个类型相同或可能转换为某个公共类型的表达式。当这两个表达式都是左值或者能转换成同一种左值类型时，运算的结果是左值；否则运算的结果是右值。</p><p>例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> finalgrade = (grade&lt;<span class="number">60</span>) ?<span class="string">"fail"</span> : <span class="string">"pass"</span>;</span><br></pre></td></tr></table></figure><p>条件运算符的优先级很低，比cout还低，所以最好加括号。</p><h4 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h4><p><img src="/2019/03/01/expression-operate/bit.png" alt=""></p><p><strong>移位运算符(&lt;&lt; 、&gt;&gt;)：</strong></p><p>一般来说，运算对象是小整型会被提升成大整型，左移运算符在右侧插入值为0的二进制位。右移行为依赖左侧运算对象的类型:如果对象是无符号类型，在左侧插入0；如果带符号，在左侧插入符号位的副本或值为0的二进制位。</p><p>移位超出的直接被舍弃。</p><p><strong>位与、位或、异或：</strong></p><p>位与运算符(&amp;): 两个对象都为1则结果为1，否则为0</p><p>位或运算符(|): 其中有一个对象为1则结果就为1，否则为0</p><p>异或运算符(^): 有且只有一个对象为1，这结果为1，否则为0</p><p>例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">quizl |= <span class="number">1U</span>L &lt;&lt; <span class="number">27</span>；<span class="comment">//第27个人的值赋为1</span></span><br><span class="line">quizl &amp;= `(<span class="number">1U</span>L&lt;&lt;<span class="number">27</span>);<span class="comment">//除了27别的值都不变</span></span><br><span class="line"><span class="keyword">bool</span> status = quizl&amp;(<span class="number">1U</span>L&lt;&lt;<span class="number">27</span>);  <span class="comment">//然后返回的值是0或者1，那么可以用bool接收</span></span><br></pre></td></tr></table></figure><h4 id="sizeof运算符"><a href="#sizeof运算符" class="headerlink" title="sizeof运算符"></a>sizeof运算符</h4><p>sizeof运算符返回一条表达式或一个类型名字所占的字节数。满足右结合律，返回size_t类型的常量表达式。运算符的运算对象有两种表达形式：</p><p>sizeof (type)</p><p>sizeof expr            </p><p>第二种形式中，返回表达式结果 类型的大小。sizeof并不实际计算其运算对象的值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Sales_data data, *p;</span><br><span class="line"><span class="keyword">sizeof</span>(Sales_data);<span class="comment">//Sales_data类型的对象所占空间的大小</span></span><br><span class="line"><span class="keyword">sizeof</span> data;<span class="comment">//同上</span></span><br><span class="line"><span class="keyword">sizeof</span> p;<span class="comment">//指针所占空间的大小</span></span><br><span class="line"><span class="keyword">sizeof</span> *p;<span class="comment">//p所指类型空间大小，也就是Sales_data</span></span><br></pre></td></tr></table></figure><p>sizeof运算符的结果部分的依赖于其作用的类型：</p><ul><li>对char或者类型为char的表达式执行sizeof运算，结果得1</li><li>对引用类型执行sizeof运算得到被引用对象所占空间的大小</li><li>对指针执行sizeof运算得到指针指向的对象所占空间的大小</li><li>对解引用指针执行sizeof运算得到指针指向的对象所占空间大小，指针不需有效</li><li>对数组执行sizeof运算得到整个数组所占空间的大小。</li><li>对string或vector执行sizeof运算只会得到固定类型的大小，不会计算元素所占空间大小。</li></ul><h4 id="逗号运算符"><a href="#逗号运算符" class="headerlink" title="逗号运算符"></a>逗号运算符</h4><p>含有两个运算对象，求值左侧表达式然后将结果丢掉，真正结果是右侧表达式，如果值是左值那结果也是左值。</p><h3 id="运算符优先级表"><a href="#运算符优先级表" class="headerlink" title="运算符优先级表"></a>运算符优先级表</h3><table><thead><tr><th>结合律</th><th>运算符</th><th>功能</th><th>用法</th></tr></thead><tbody><tr><td>左</td><td>::</td><td>全局作用域</td><td>::name</td></tr><tr><td>左</td><td>::</td><td>类作用域</td><td>class::name</td></tr><tr><td>左</td><td>::</td><td>命名空间作用域</td><td>namespace::name</td></tr><tr><td>左</td><td>.</td><td>成员选择</td><td>object.member</td></tr><tr><td>左</td><td>-&gt;</td><td>成员选择</td><td>point-&gt;member</td></tr><tr><td>左</td><td>[]</td><td>下标</td><td>expr[expr]</td></tr><tr><td>左</td><td>()</td><td>函数调用</td><td>name(expr_list)</td></tr><tr><td>左</td><td>()</td><td>类型构造</td><td>type(expr_list)</td></tr><tr><td>右</td><td>++</td><td>后置递增运算</td><td>lvalue++</td></tr><tr><td>右</td><td>–</td><td>后置递减运算</td><td>lvalue–</td></tr><tr><td>右</td><td>typeid</td><td>类型ID</td><td>typeid(type)</td></tr><tr><td>右</td><td>typeid</td><td>运行时类型ID</td><td>typeid(expr)</td></tr><tr><td>右</td><td>explicit cast</td><td>类型转换</td><td>cast_name&lt; type&gt;(expr)</td></tr><tr><td>右</td><td>++</td><td>前置递增运算</td><td>++lvalue</td></tr><tr><td>右</td><td>–</td><td>前置递减运算</td><td>–lvalue</td></tr><tr><td>右</td><td>~</td><td>位求反</td><td>~expr</td></tr><tr><td>右</td><td>!</td><td>逻辑非</td><td>!expr</td></tr><tr><td>右</td><td>-</td><td>一元负号</td><td>-expr</td></tr><tr><td>右</td><td>+</td><td>一元正号</td><td>+expr</td></tr><tr><td>右</td><td>*</td><td>解引用</td><td>*expr</td></tr><tr><td>右</td><td>&amp;</td><td>取地址</td><td>&amp;expr</td></tr><tr><td>右</td><td>()</td><td>类型转换</td><td>(type)expr</td></tr><tr><td>右</td><td>sizeof</td><td>对象大小</td><td>sizeof expr</td></tr><tr><td>右</td><td>sizeof</td><td>类型的大小</td><td>sizeof（type)</td></tr><tr><td>右</td><td>Sizeof…</td><td>参数包的大小</td><td>sizeof…(name)</td></tr><tr><td>右</td><td>new</td><td>创建对象</td><td>new type</td></tr><tr><td>右</td><td>new[]</td><td>创建数组</td><td>new type[size]</td></tr><tr><td>右</td><td>delete</td><td>释放对象</td><td>delete expr</td></tr><tr><td>右</td><td>delete[]</td><td>释放数组</td><td>delete[] expr</td></tr><tr><td>右</td><td>noexcept</td><td>能否抛出异常</td><td>noexcept (expr)</td></tr><tr><td>左</td><td>-&gt;*</td><td>指向成员选择的指针</td><td>ptr-&gt;*ptr_to_member</td></tr><tr><td>左</td><td>.*</td><td>指向成员选择的指针</td><td>obj.*ptr_to_member</td></tr><tr><td>左</td><td>*</td><td>乘法</td><td>expr*expr</td></tr><tr><td>左</td><td>/</td><td>除法</td><td>expr/expr</td></tr><tr><td>左</td><td>%</td><td>取模(取余)</td><td>expr%expr</td></tr><tr><td>左</td><td>+</td><td>加法</td><td>expr+expr</td></tr><tr><td>左</td><td>-</td><td>减法</td><td>expr-expr</td></tr><tr><td>左</td><td>&lt;&lt;</td><td>向左移位</td><td>expr&lt;&lt;expr</td></tr><tr><td>左</td><td>&gt;&gt;</td><td>向右移位</td><td>expr&gt;&gt;expr</td></tr><tr><td>左</td><td>&lt;</td><td>小于</td><td>expr&lt;expr</td></tr><tr><td>左</td><td>&lt;=</td><td>小于等于</td><td>expr&lt;=expr</td></tr><tr><td>左</td><td>&gt;</td><td>大于</td><td>expr&gt;expr</td></tr><tr><td>左</td><td>&gt;=</td><td>大于等于</td><td>expr&gt;=expr</td></tr><tr><td>左</td><td>==</td><td>相等</td><td>expr==expr</td></tr><tr><td>左</td><td>!=</td><td>不相等</td><td>expr!=expr</td></tr><tr><td>左</td><td>&amp;</td><td>位与</td><td>expr&amp;expr</td></tr><tr><td>左</td><td>^</td><td>位异或</td><td>expr^expr</td></tr><tr><td>左</td><td>丨</td><td>位或</td><td>expr丨expr</td></tr><tr><td>左</td><td>&amp;&amp;</td><td>逻辑与</td><td>expr&amp;&amp;expr</td></tr><tr><td>左</td><td>丨丨</td><td>逻辑或</td><td>expr丨丨expr</td></tr><tr><td>左</td><td>?:</td><td>条件</td><td>expr ? expr : expr</td></tr><tr><td>右</td><td>=</td><td>赋值</td><td>lvalue=expr</td></tr><tr><td>右</td><td>*=, /=, %=</td><td>复合赋值</td><td>lvalue += expr等</td></tr><tr><td>右</td><td>+=, -=</td><td></td><td></td></tr><tr><td>右</td><td>&lt;&lt;=, &gt;&gt;=</td><td></td><td></td></tr><tr><td>右</td><td>&amp;=,丨 =, ^=</td><td></td><td></td></tr><tr><td>右</td><td>throw</td><td>抛出异常</td><td>throw</td></tr><tr><td>右</td><td>,</td><td>逗号</td><td>expr , expr</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;表达式与运算符-附表&quot;&gt;&lt;a href=&quot;#表达式与运算符-附表&quot; class=&quot;headerlink&quot; title=&quot;表达式与运算符(附表)&quot;&gt;&lt;/a&gt;表达式与运算符(附表)&lt;/h1&gt;&lt;p&gt;表达式由一个或多个运算对象组成，对表达式求值将得到一个结果。&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="C++Primer笔记" scheme="http://yoursite.com/categories/C-Primer%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="表达式" scheme="http://yoursite.com/tags/%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
      <category term="运算符" scheme="http://yoursite.com/tags/%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    
  </entry>
  
  <entry>
    <title>IO(流)</title>
    <link href="http://yoursite.com/2019/02/27/io/"/>
    <id>http://yoursite.com/2019/02/27/io/</id>
    <published>2019-02-27T13:04:42.000Z</published>
    <updated>2019-02-28T13:32:42.696Z</updated>
    
    <content type="html"><![CDATA[<p>ps：先是简单的介绍一下IO类、文件的输入输出以及string流。看到之后章节再记录拓展~</p><h1 id="IO库"><a href="#IO库" class="headerlink" title="IO库"></a>IO库</h1><h3 id="基本介绍："><a href="#基本介绍：" class="headerlink" title="基本介绍："></a>基本介绍：</h3><h4 id="include："><a href="#include：" class="headerlink" title="#include："></a><strong>#include：</strong></h4><p>#include指令用于添加头文件。通常情况下，它必须出现现在所有函数之外。一般将他放在源文件最开始的位置。</p><ul><li>#include &lt;&gt;:尖括号用于添加<strong>标准库头文件</strong></li><li>#include “”:双引号用于添加<strong>自己定义</strong>的头文件</li></ul><h4 id="lt-lt-、-gt-gt-左侧、右侧运算符"><a href="#lt-lt-、-gt-gt-左侧、右侧运算符" class="headerlink" title="&lt;&lt;、&gt;&gt;左侧、右侧运算符:"></a><strong>&lt;&lt;、&gt;&gt;左侧、右侧运算符:</strong></h4><p>&lt;&lt;左侧的对象必须是一个ostream对象，返回一个ostream对象。&gt;&gt;左侧的对象必须是一个istream对象，返回一个istream对象。</p><h4 id=""><a href="#" class="headerlink" title="::"></a><strong>::</strong></h4><p>作用域运算符::用来表示某个作用域。</p><h4 id="部分IO库设施："><a href="#部分IO库设施：" class="headerlink" title="部分IO库设施："></a>部分IO库设施：</h4><table><thead><tr><th>istream(输入流)</th><th>提供输入操作</th></tr></thead><tbody><tr><td>ostream(输出流)</td><td>提供输出操作</td></tr><tr><td>cin</td><td>从标准输入读取数据</td></tr><tr><td>cout</td><td>从标准输出写入数据</td></tr><tr><td>cerr</td><td>通常用于输出程序错误信息，写入到标准错误</td></tr><tr><td>运算符&gt;&gt;</td><td>用来从一个istream对象读取输入数据</td></tr><tr><td>运算符&lt;&lt;</td><td>用来从一个ostream对象写入输出数据</td></tr><tr><td>getline函数</td><td>从一个给定的istream读取一行数据存入一个给定的string对象中</td></tr></tbody></table><h3 id="IO类"><a href="#IO类" class="headerlink" title="IO类"></a>IO类</h3><p>为了继承不同种类的IO操作，标准库还定义了其他一些IO类型。分别定义在三个头文件中：</p><ol><li>iostream定义了用于读写流的基本类型。<ol><li>istream、wistream从流读取数据</li><li>ostream、wostream向流写入数据</li><li>iostream、wiostream读写流</li></ol></li><li><p>fstream定义了读写命名文件的类型</p><ol><li>ifstream、wifstream从文件读取数据</li><li>ofstream、wofstream向文件写入数据</li><li>iofstream、wiofstream读写文件</li></ol></li><li><p>sstream定义了读写内存string对象的类型</p><ol><li>istringstream、wistringstream从string读取数据</li><li>ostringstream、wostringstream向string写入数据</li><li>iostringstream、wiostringstream读写string</li></ol></li></ol><p>以上w开头是为了支持宽字符w_char类型的数据。wcin、wcout、wcerr对应cin、cout、cerr等等。</p><p><strong>而fstream和sstream都是继承iostream的</strong></p><h4 id="IO对象无法拷贝或赋值"><a href="#IO对象无法拷贝或赋值" class="headerlink" title="IO对象无法拷贝或赋值"></a>IO对象无法拷贝或赋值</h4><p>IO对象无法拷贝，因此不能将形参或者返回值定为流类型，但是可以定义为流的引用类型。</p><h4 id="流的条件状态"><a href="#流的条件状态" class="headerlink" title="流的条件状态"></a>流的条件状态</h4><p>IO操作有可能发生错误。有些是可以恢复的而有些是不可恢复的，因此下表列出了一些<strong>函数和标志</strong>来帮助我们访问和操纵 流的<strong>条件状态(condition state)</strong>：下表中strm是表示一种流类型(上表所列出的)，s表示一个流</p><table><thead><tr><th>strm:iostate</th><th>iostate是一种机器相关的类型，提供了表达条件状态的完整功能</th></tr></thead><tbody><tr><td>strm:badbit</td><td>用来指出流已崩溃/第四位</td></tr><tr><td>strm:failbit</td><td>用来指出一个IO操作失败/第三位</td></tr><tr><td>strm:eofbit</td><td>用来指出流到达了文件结束/第二位</td></tr><tr><td>strm:goodbit</td><td>用来指出流未处于错误状态/第1位(从右往左)</td></tr><tr><td>s.eof()</td><td>若流s的eofbit置位，则返回true</td></tr><tr><td>s.fail()</td><td>若failbit或badbit置位，则返回true</td></tr><tr><td>s.bad()</td><td>若badbit置位，返回true</td></tr><tr><td>s.good()</td><td>若s处于有效状态，则返回true</td></tr><tr><td>s.clear()</td><td>将流s中所有条件状态复位，将流状态置为有效。返回void</td></tr><tr><td>s.clear(flags)</td><td>根据给定flags标志位，将流s中对应状态置为有效。flags类型为strm::iostate，返回void</td></tr><tr><td>s.setstate(flags)</td><td>根据给定flags标志位，将流s中对应状态置位。flags类型为strm::iostate，返回void</td></tr><tr><td>s.rdstate()</td><td>返回流s的当前条件状态，返回类型为iostate</td></tr></tbody></table><p>例：如果在一个int类型中输入字符时，读操作就会失败。类似的输入一个文件结束符时。cin也会进入错误状态。</p><h4 id="查询流的状态"><a href="#查询流的状态" class="headerlink" title="查询流的状态"></a>查询流的状态</h4><p><strong>标准库定义的类型：</strong></p><p>上表中定义了4个iostate类型的constexpr值，表示特定的位模式。意思就是每一个值用一位二进制来表示，例如他们初始值为1110，右边第一位表示goodbit，第二位是eofbit…</p><p>badbit：表示系统级错误，不可恢复。</p><p>failbit：表示可以恢复的错误，例如期望读取int类型却读出了字符等错误。流可以被修正，能继续使用。</p><p>eofbit：如果达到文件结尾，eofbit和failbit都会被置位</p><p>goodbit：值为0表示流未发生错误</p><p>如果badbit、failbit、eofbit三个其中一个发生错误，则流检测状态的条件会失败。</p><p><strong>标准库定义的函数：</strong></p><p>good():在所有错误未置位的情况下返回true</p><p>bad、fail、eof 则在对应类型被置位下返回true。</p><p>此外在badbit被置位时fail也会返回true。因此使用good或fail是确定流总体状态的正确方法。实际上我们用的<strong>条件while(cin)就等于!fail()</strong></p><h4 id="管理条件状态"><a href="#管理条件状态" class="headerlink" title="管理条件状态"></a>管理条件状态</h4><p>clear() :将所有状态复位。</p><p>clear(flags)：将指定状态复位。flags是iostate类型。<strong>例：</strong></p><p>​    初始值1110.加入产生了错误导致failbit和badbit置位，iostate变成0010.如果想单独将failbit置位那么就需要传入0110。这时代码可写成clear(s.rdstate() &amp; ~s.failbit)</p><h4 id="管理输出缓冲"><a href="#管理输出缓冲" class="headerlink" title="管理输出缓冲"></a>管理输出缓冲</h4><p>每个输出流都管理一个缓冲区，用来保存程序读写的数据。有了缓冲机制，操作系统就可以将程序的多个输出操作组合成单一的系统级写操作。提升很大的性能。</p><p><strong>导致缓冲刷新的原因：</strong></p><ul><li>程序正常结束，作为main的return操作的一部分，缓冲刷新</li><li>缓冲区满的时候</li><li>可以使用操纵符endl来显式刷新</li><li>在每个输出操作之后，用操纵符unitbuf设置流的内部状态，来清空缓冲区。默认情况对cerr是设置unitbuf的。</li><li>一个输出流可以被关联到另一个流。在这种情况下，当读写被关联的流时，关联到的流缓冲区会被刷新。例如：cin和cerr都关联到cout。因此读cin或写cerr都会导致cout缓冲区被刷新。</li></ul><p><strong>刷新输出缓冲区：</strong></p><p>endl: 输出内容和一个换行，刷新缓冲区</p><p>flush:输出内容，刷新缓冲区</p><p>ends:出书内容和一个空字符，刷新缓冲区</p><p><strong>unitbuf操纵符：</strong></p><p>如果想每次输出后都刷新缓冲区可以使用unitbuf操纵符。它告诉流在每次写操作之后进行一次flush操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; unitbuf;<span class="comment">//所有输出操作后都会刷新缓冲区</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; nounitbuf;<span class="comment">//回到正常缓冲方式</span></span><br></pre></td></tr></table></figure><p><strong>关联输入输出流：</strong></p><p>一个输出流可以被关联到另一个流。在这种情况下，当读写被关联的流时，关联到的流缓冲区会被刷新。例如：cin和cerr都关联到cout。因此读cin或写cerr都会导致cout缓冲区被刷新。</p><p>NOTE:交互式系统通常关联输入流与输出流。这意味这所有输出都会在写入之前打印出来。</p><p><strong>tie：</strong>tie函数有两个版本：</p><ul><li>一个无参版本，返回指向输出流的指针。如果本对象关联一个输出流，返回的就是这个流的指针，否则未关联则返回空指针；</li><li>tie的第二个版本接受一个<strong>指向ostream</strong>的指针，将自己关联到此ostream，即：x.tie(&amp;o)将流x关联到o</li></ul><p>我们可以将istream关联到ostream也可以将ostream关联到ostream。每个流只能关联一个流，但是一个流可以被多个流关联。</p><h3 id="文件输入输出"><a href="#文件输入输出" class="headerlink" title="文件输入输出"></a>文件输入输出</h3><p>之前有说到，头文件<strong>fstream</strong>定义了三个类型来支持文件IO：ifstream从一个给定文件读取数据；ofstream向一个给定文件写入数据； fstream能读写文件。这三个类型的操作与之前一样，能用IO运算符(&lt;&lt;和&gt;&gt;)来读写文件，可用getline()来获取行数据。</p><p>除了继承自iostream类型的行为之外，它还定义了新的成员来管理文件流。如下：fstream是头文件fstream中定义的一个类型</p><table><thead><tr><th>fstream fstrm;</th><th>创建一个未绑定的文件流</th></tr></thead><tbody><tr><td>fstream fstrm(s);</td><td>创建一个fstream并打开名为s的文件(加后缀)。s可以是string或指向c风格字符串的指针。这些构造函数都是explicit的。默认文件模式mode依赖于fstream的类型</td></tr><tr><td>fstream fstrm(s, mode);</td><td>与前一个<strong>构造函数</strong>相似，但指定了mode</td></tr><tr><td>fstrm.open(s)</td><td>打开名为s的文件，并将文件与fstrm绑定。返回void</td></tr><tr><td>fstrm.close()</td><td>关闭与fstrm绑定的文件。返回void</td></tr><tr><td>fstrm.is_open()</td><td>返回一个bool值，指出与fstrm关联的文件是否成功打开并且未关闭</td></tr></tbody></table><p>上表中前三个是构造函数，用于创建一个文件流并且可以选择<strong>是否绑定文件</strong>以及打开文件的<strong>模式</strong>。</p><h4 id="使用文件流对象"><a href="#使用文件流对象" class="headerlink" title="使用文件流对象"></a>使用文件流对象</h4><p><strong>创建文件流：</strong></p><p>我们可以先定义一个文件流并且与文件相关联，也可以只先定义一个文件流对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">in</span><span class="params">(file.txt)</span></span>;<span class="comment">//构造一个ifstream并打开文件</span></span><br><span class="line">ofstream out;<span class="comment">//定义一个输出文件流未关联文件</span></span><br></pre></td></tr></table></figure><p>文件名可以是string对象，也可以是C风格字符数组。</p><p><strong>函数open和close：</strong></p><p>如果定义了一个空文件流对象，可以随后调用open来将它与文件相关联。比如上述输出文件流out：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">out.open(<span class="string">"file.txt"</span>);<span class="comment">//打开指定文件</span></span><br></pre></td></tr></table></figure><p>如果调用open失败，failbit会置位。</p><p><strong><u>自动构造和析构:</u></strong>如果将创建流定义在while里面，那么while的每一步都会创建与销毁文件流，当一个fstream对象被销毁的时候，会自动调用close函数。</p><h4 id="文件模式"><a href="#文件模式" class="headerlink" title="文件模式"></a>文件模式</h4><p>在上表中的第三个构造函数中有个mode参数，这是流关联的文件模式。在调用open打开文件时也可以，不论显示隐式 都会调用一种模式。</p><table><thead><tr><th>in</th><th>以读方式打开</th></tr></thead><tbody><tr><td>out</td><td>以写方式打开</td></tr><tr><td>app</td><td>每次<strong>写操作</strong>前均定位到文件末尾</td></tr><tr><td>ate</td><td>打开文件后立即定位到文件末尾</td></tr><tr><td>trunc</td><td>截断文件</td></tr><tr><td>binary</td><td>以二进制方式进行IO</td></tr></tbody></table><ul><li>只可以对ostream设定out模式</li><li>只可以对istream设定in模式</li><li>只有当out也被设定时才可以设定trunc模式</li><li>只要没有设定trunc就可以设定app模式。在app模式下没有设定out也会默认out模式。</li><li>默认情况下没有指定trunc，以out模式打开的文件也会被截断。如果要保留文件内容，必须指定app模式，或者同时指定in模式。</li><li>ate和binary模式可以用于任何类型的文件，并且能与其他模式组合使用。</li></ul><p>当不指定时，文件流使用默认的文件模式，ifstream是in模式；ofstream是out模式；fstream是in和out模式。</p><h4 id="以out打开会丢弃数据"><a href="#以out打开会丢弃数据" class="headerlink" title="以out打开会丢弃数据"></a>以out打开会丢弃数据</h4><p>当一个文件以out模式打开时，会被截断，文件的内容会被丢弃。阻止此行为的方法是指定app模式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ofstream <span class="title">out</span><span class="params">(<span class="string">"file.txt"</span>)</span></span>;<span class="comment">//隐含以输出模式打开并截断</span></span><br><span class="line"><span class="function">ofstream <span class="title">out2</span><span class="params">(<span class="string">"file.txt"</span>, ofstream::out)</span></span>;<span class="comment">//隐含截断文件</span></span><br><span class="line"><span class="function">ofstream <span class="title">out3</span><span class="params">(<span class="string">"file.txt"</span>, ofstream::out|ofstream::trunc)</span></span>;</span><br></pre></td></tr></table></figure><p>指定app模式则能保留文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ofstream <span class="title">app</span><span class="params">(<span class="string">"file.txt"</span>，ofstream::app)</span></span>;<span class="comment">//隐含为out模式</span></span><br><span class="line"><span class="function">ofstream <span class="title">app</span><span class="params">(<span class="string">"file.txt"</span>，ofstream::out | ofstream::app)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="string流"><a href="#string流" class="headerlink" title="string流"></a>string流</h3><p>类似的，sstream头文件定义了三个类型来支持内存IO：istringstream从string读取数据，ostringstream向string写入数据，stringstream可以读写数据。sstream除了继承来的操作，还定义了一些成员来管理string流。</p><table><thead><tr><th>sstream strm;</th><th>sstream是头文件sstream中定义的一个类型，strm是一个未绑定的stringstream对象</th></tr></thead><tbody><tr><td>sstream strm(s);</td><td>strm是一个sstream对象，保存string s的一个拷贝。此构造函数是explicit的</td></tr><tr><td>strm.str();</td><td>返回strm所保存的string的拷贝</td></tr><tr><td>strm.str(s);</td><td>将string s拷贝到strm中。返回void</td></tr></tbody></table><h4 id="使用istringstream"><a href="#使用istringstream" class="headerlink" title="使用istringstream"></a>使用istringstream</h4><p>当我们的某些工作是对整行文本进行处理，而其他的一些工作是处理行内的某个单词时，通常能用istringstream。</p><p><strong>定义：</strong></p><p>可以将一个istringstream与string对象绑定，也可以只定义一个istringstream。然后用str(s)方法绑定</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">istringstream</span> <span class="title">in</span><span class="params">(s)</span></span>;<span class="comment">//定义一个istringstream与string s绑定</span></span><br><span class="line"><span class="built_in">istringstream</span> in2;<span class="comment">//定义一个未绑定的流in2</span></span><br><span class="line">in2.str(s);<span class="comment">//将流in2与string s绑定</span></span><br></pre></td></tr></table></figure><p><strong>例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> line = <span class="string">"hello world"</span>, word;</span><br><span class="line"><span class="function"><span class="built_in">istringstream</span> <span class="title">in</span><span class="params">(line)</span></span>;</span><br><span class="line">in &gt;&gt; word;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; word &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h4 id="使用ostringstream"><a href="#使用ostringstream" class="headerlink" title="使用ostringstream"></a>使用ostringstream</h4><p>当我们逐步构造输出，希望最后一起打印时，ostringstream是很有用的。</p><p><strong>定义：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">ostringstream</span> <span class="title">out</span><span class="params">(s)</span></span>;<span class="comment">//定义一个ostringstream 并将s写入</span></span><br><span class="line"><span class="built_in">ostringstream</span> in2;<span class="comment">//定义ostringstream </span></span><br><span class="line">in2.str(s);<span class="comment">//将s写入内存中</span></span><br></pre></td></tr></table></figure><p><strong>例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">ostringstream</span> <span class="title">os</span><span class="params">(<span class="string">"hello world"</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; os.str();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ps：先是简单的介绍一下IO类、文件的输入输出以及string流。看到之后章节再记录拓展~&lt;/p&gt;
&lt;h1 id=&quot;IO库&quot;&gt;&lt;a href=&quot;#IO库&quot; class=&quot;headerlink&quot; title=&quot;IO库&quot;&gt;&lt;/a&gt;IO库&lt;/h1&gt;&lt;h3 id=&quot;基本介绍：&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="C++Primer笔记" scheme="http://yoursite.com/categories/C-Primer%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="IO" scheme="http://yoursite.com/tags/IO/"/>
    
      <category term="流" scheme="http://yoursite.com/tags/%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>数组</title>
    <link href="http://yoursite.com/2019/02/23/array/"/>
    <id>http://yoursite.com/2019/02/23/array/</id>
    <published>2019-02-23T13:15:12.000Z</published>
    <updated>2019-02-23T13:49:59.920Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>数组是一种类似于标准库类型vector的数据结构。</p><ul><li>与vector相似的是，数组也是存放类型相同的对象的容器，这些对象本身没有名字，需要通过位置访问。</li><li>与vector不同的是，数组的大小确定不变，不能随意向数组中增加元素。<ul><li>改变长度只能创建一个新数组，我们也不能像vector一样用size函数直接获取长度，char数组用strlen 而别的数组只能sizeof(array)/sizeof(array[0])</li></ul></li></ul><h3 id="定义和初始化数组"><a href="#定义和初始化数组" class="headerlink" title="定义和初始化数组"></a>定义和初始化数组</h3><h4 id="数组的定义："><a href="#数组的定义：" class="headerlink" title="数组的定义："></a>数组的定义：</h4><p>数组是一种复合类型。数组的声明形如a[d]，其中a是数组名字，d是数组的维度。</p><ol><li>维度就是个数，因此必须大于0。</li><li>数组中元素的个数属于数组类型的一部分，编译时是已知的。因此维度必须是一个常量表达式。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> cnt = <span class="number">42</span>;<span class="comment">//不是常量表达式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">unsigned</span> sz = <span class="number">42</span>; <span class="comment">//是常量表达式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>];<span class="comment">//含有10个整数的数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *parr[sz];<span class="comment">//含有42个整型指针的数组</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> bad[cnt];<span class="comment">//错误，cnt不是常量表达式</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> strs[get_size()];<span class="comment">//当get_size()是constexpr时正确</span></span><br></pre></td></tr></table></figure><p>和内置类型的变量一样，如果在函数内部定义了某种内置类型的数组，那么默认初始化会令数组含有未定义的值。</p><p>必须指定数组的类型(不允许用auto由初始化列表推断)。</p><p>和vector一样，数组的元素应为对象，因此不存在引用的数组。</p><h4 id="显式初始化数组元素："><a href="#显式初始化数组元素：" class="headerlink" title="显式初始化数组元素："></a>显式初始化数组元素：</h4><p><strong>可以对数组的元素进行列表初始化，此时忽略数组维度</strong>。</p><ul><li>如果在声明时没有指明维度，编译器会根据初始值的数量计算出来</li><li>如果定义了维度并且比列表大，那么剩下的元素会被初始化为默认值。</li><li>如果定义了维度并且比列表小，那么编译错误</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> sz = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ial[sz] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;; <span class="comment">//含有3个元素，012</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a2[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;; <span class="comment">//同上</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a3[<span class="number">5</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;; <span class="comment">//等价于a3[] = &#123;0,1,2,0,0&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> a4[<span class="number">3</span>] = &#123;“hi”, “bye”&#125;;<span class="comment">//等价于a4[] = &#123;“hi”, “bye”, “”&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a5[<span class="number">2</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;; <span class="comment">//错误，维度比初始值小</span></span><br></pre></td></tr></table></figure><h4 id="字符数组-的特殊性："><a href="#字符数组-的特殊性：" class="headerlink" title="字符数组 的特殊性："></a>字符数组 的特殊性：</h4><p>字符数组可以用<strong>字符串字面值</strong>进行初始化。当使用这种方式一定要注意字符串字面值<strong>结尾处还有一个空字符</strong>，要预留一个空间。如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a1[] = &#123;‘c’, ‘+’, ‘+’&#125;;<span class="comment">//列表初始化，没有空字符</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> a2[]=&#123;‘c’, ‘+’, ‘+’, ‘\<span class="number">0</span>’&#125;;<span class="comment">//显式的空字符</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> a3[] = “c++”;<span class="comment">//自动添加表示字符串结束的空字符</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> a4[<span class="number">6</span>] = “Daniel”;<span class="comment">//错误，没有空间放空字符</span></span><br></pre></td></tr></table></figure><h4 id="数组不允许拷贝和赋值："><a href="#数组不允许拷贝和赋值：" class="headerlink" title="数组不允许拷贝和赋值："></a>数组不允许拷贝和赋值：</h4><p>不能将数组的内容拷贝给其他数组作为其初始值，也不能用数组为其他数组赋值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a1[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a2[] = a1; <span class="comment">//错误：不允许使用一个数组初始化另一个数组</span></span><br><span class="line"></span><br><span class="line">a2 = a ;<span class="comment">//错误，不能把一个数组直接赋值给另一个数组</span></span><br></pre></td></tr></table></figure><p>(某些<strong>编译器扩展</strong>可以支持数组赋值，不过最好避免)</p><h4 id="复杂的数组声明-数组-指针、引用等-："><a href="#复杂的数组声明-数组-指针、引用等-：" class="headerlink" title="复杂的数组声明(数组+指针、引用等)："></a>复杂的数组声明(数组+指针、引用等)：</h4><p>数组可以存放对象，就可以定义指针对象。而数组本身是一个对象，那么可以有引用和指针，如下(可从内向外再从右向左阅读)：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *ptrs[<span class="number">10</span>];<span class="comment">//ptrs是有10个整型指针的数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> &amp;refs[<span class="number">10</span>]; <span class="comment">//错误，数组不能放引用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> (*Parray)[<span class="number">10</span>] = &amp;arr<span class="comment">//Parray是一个指针，指向一个整型数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> (&amp;arrRef)[<span class="number">10</span>] = arr;<span class="comment">//arrRef是一个引用，引用一个整型数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *(&amp;arrRef)[<span class="number">10</span>] = ptrs;<span class="comment">//arrRef 是一个引用，指向一个含有10个int类型指针的数组</span></span><br></pre></td></tr></table></figure><h3 id="访问数组元素"><a href="#访问数组元素" class="headerlink" title="访问数组元素"></a>访问数组元素</h3><p>数组的访问跟vector基本类似。也可以用范围for语句或下标运算符来访问。</p><p>在使用下标的时候通常将其定义为<strong>size_t</strong>类型。</p><p>size_t 是一种机器相关的无符号类型。它的定义在<strong>cstddef</strong>头文件中。</p><h3 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a>指针和数组</h3><p>通常情况下，使用取地址符来获取指向某个对象的指针。数组的元素也是对象，因此对数组的元素使用取地址符就能得到指向该元素的指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> nums[] = &#123;“one”, “two”, “three”&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> *p = &amp;nums[<span class="number">0</span>]; <span class="comment">//p指向nums的第一个元素</span></span><br></pre></td></tr></table></figure><p><strong>然而数组有个特性：在很多用到数组名字的地方，编译器会自动的将其转换为一个指向数组首元素的指针。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> *p2 = nums;<span class="comment">//等价于p2 = &amp;nums[0]</span></span><br></pre></td></tr></table></figure><h4 id="对数组使用auto和decltype的不同点："><a href="#对数组使用auto和decltype的不同点：" class="headerlink" title="对数组使用auto和decltype的不同点："></a>对数组使用auto和decltype的不同点：</h4><p>由上可知，在一些情况下数组的操作实际上是指针的操作：</p><ol><li>当使用一个数组作为一个auto变量的初始值时，推断出的类型是指针而非数组</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ia2</span><span class="params">(ia)</span></span>;<span class="comment">//ia2是一个整型指针，指向ia的第一个元素，同 ia2(&amp;ia[0])</span></span><br></pre></td></tr></table></figure><ol start="2"><li>然而当使用decltype(ia)返回的是一个数组。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(ia) ia3 = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">ia3[<span class="number">4</span>] = i;<span class="comment">//给ia3的第三个元素赋值</span></span><br></pre></td></tr></table></figure><h4 id="指针也是迭代器："><a href="#指针也是迭代器：" class="headerlink" title="指针也是迭代器："></a>指针也是迭代器：</h4><p>迭代器可用的运算 指针都能用。也可以使用指针遍历数组。</p><p>同时c++给了两个标准库函数取尾后指针，<strong>begin 和 end</strong>，定义在iterator头文件中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *pbeg = begin(arr);<span class="comment">//指向arr的首元素</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *pend = end(arr);<span class="comment">//指向尾后元素</span></span><br></pre></td></tr></table></figure><h4 id="解引用与指针运算交互："><a href="#解引用与指针运算交互：" class="headerlink" title="解引用与指针运算交互："></a>解引用与指针运算交互：</h4><p>迭代器有的运算操作指针都有，两个指针相减的结果类型是ptrdiff_t， 与size_t一样。</p><p>如果两个指针分别指向不相关的对象，则不能比较它们。</p><p>空指针也可以相减，值为0。</p><p><strong>下标和指针：</strong></p><p>当对数组使用下标运算符时，编译器会自动转换成指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[] = &#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> last = *(ia + <span class="number">4</span>);<span class="comment">//正确：等同于 ia[4]</span></span><br></pre></td></tr></table></figure><p>从上可知，对数组下标运算其实是对指向数组元素的指针执行下标运算：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = &amp;ia[<span class="number">2</span>];<span class="comment">//p指向索引为2的元素</span></span><br><span class="line"><span class="keyword">int</span> j = p[<span class="number">1</span>]; <span class="comment">//p[1]等价于*(p + 1),就是ia[3]表示的那个元素</span></span><br><span class="line"><span class="keyword">int</span> k = p[<span class="number">-2</span>]; <span class="comment">//p[-2]等价于*(p - 2),就是ia[0]表示的那个元素</span></span><br></pre></td></tr></table></figure><p>数组的下标运算与 标准库类型限定使用的下标运算有所不同。<strong>标准库类型的下标必须是无符号类型，而内置的下标则无此要求。</strong></p><h3 id="C风格字符串"><a href="#C风格字符串" class="headerlink" title="C风格字符串"></a>C风格字符串</h3><p>尽管c++支持c风格字符串，但还是不要使用它们。因为用起来不太方便，而且极易引发程序漏洞。</p><p><strong>字符串字面值</strong>是一种通用结构的实例，即是由c继承而来的c风格字符串。</p><p>c通常把字符串存放在字符数组中并以空字符结束(‘\0’)。一般用指针来操作这些字符串。</p><h4 id="C标准库string函数"><a href="#C标准库string函数" class="headerlink" title="C标准库string函数"></a>C标准库string函数</h4><p>下表函数定义在cstring头文件中。</p><table><thead><tr><th>strlen(p)</th><th style="text-align:left">返回p的长度，空字符不计算在内</th></tr></thead><tbody><tr><td>strcmp(p1, p2)</td><td style="text-align:left">比较p1和p2的相等性。如果p1==p2，返回0；如果p1&gt;p2,返回一个正值；返回0；如果p1&lt;p2,返回一个负值</td></tr><tr><td>strcat(p1, p2)</td><td style="text-align:left">和炮</td></tr><tr><td>strcpy(p1, p2)</td><td style="text-align:left">将p2拷贝给p1， 返回p1</td></tr></tbody></table><p><strong>上表所列的函数不负责验证字符串参数。</strong></p><p>传入此类函数的指针必须指向以空字符作为结束的数组：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ca[] = &#123;‘c’, ‘+’, ‘+’&#125;;<span class="comment">//不以空字符结束</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; <span class="built_in">strlen</span>(ca) &lt;&lt;<span class="built_in">endl</span>;<span class="comment">//严重错误：ca没有以空字符结束</span></span><br></pre></td></tr></table></figure><p>上面代码不是以空字符结束，它可能沿着ca在内存中的位置不断向前直到遇到空字符。</p><h4 id="比较字符串："><a href="#比较字符串：" class="headerlink" title="比较字符串："></a>比较字符串：</h4><p>比较两个c风格字符串的方法与标准库string对象的方法大相径庭。</p><p>标准库string对象的比较用的是普通关系运算符和相等性运算符，如 &lt;、==；</p><p>而c风格字符串，实际比较的是两个指针而不是字符串本身：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> ca1[] = “A <span class="built_in">string</span> example”;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> ca2[] = “A different <span class="built_in">string</span>”;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( ca1 &lt; ca2)&#123;&#125;;<span class="comment">//未定义的：试图比较两个无关地址，相当于比较const char*</span></span><br></pre></td></tr></table></figure><p>所以上述ca1和ca2相比其实是两个const char*的值，这两个指针指向的不是一个对象，因此得到未定义的结果。</p><p>如果想要比较两个c风格字符串则需要调用strcmp函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(ca1, ca2) &lt; <span class="number">0</span>) <span class="comment">//相等返回0，前面大返回正值，否则负值。</span></span><br></pre></td></tr></table></figure><h4 id="c风格字符串的连接拷贝："><a href="#c风格字符串的连接拷贝：" class="headerlink" title="c风格字符串的连接拷贝："></a>c风格字符串的连接拷贝：</h4><p>使用strcpy 和 ctrcat函数来进行连接、拷贝，如果使用则需要提供一个用于存放结果的数组，必须足够大容纳下结果字符串以及<strong>末尾的空字符</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strcpy</span>(largeStr, ca1);<span class="comment">//cal拷贝给largeStr</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">strcat</span>(largeStr, “ ”);</span><br><span class="line"></span><br><span class="line"><span class="built_in">strcat</span>(largeStr, ca2);<span class="comment">//ca2连接到largeStr后面</span></span><br></pre></td></tr></table></figure><p>ps：在vs中使用c风格字符串的函数时，会报错。因为c库的函数内部进行参数检验，所以vs提出警告要求使用vs改写的函数。报错：</p><table><thead><tr><th>错误</th><th>描述</th></tr></thead><tbody><tr><td>C4996</td><td>‘strcpy’: This function or variable may be unsafe. Consider using strcpy_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.</td></tr></tbody></table><p>需要改写成：</p><table><thead><tr><th>老接口</th><th>新接口</th></tr></thead><tbody><tr><td>mkdir</td><td>_mkdir</td></tr><tr><td>fopen</td><td>fopen_s</td></tr><tr><td>strcmp</td><td>strcmp_s</td></tr><tr><td>strcpy</td><td>strcpy_s</td></tr><tr><td>strcat</td><td>strcat_s</td></tr></tbody></table><h3 id="与旧代码的接口"><a href="#与旧代码的接口" class="headerlink" title="与旧代码的接口"></a>与旧代码的接口</h3><p>很多c++程序在标准库出现之前就已经写成了，因此c++专门提供了一组功能来衔接c++程序与数组/c风格字符串的代码。</p><h4 id="混用string对象和C风格字符串："><a href="#混用string对象和C风格字符串：" class="headerlink" title="混用string对象和C风格字符串："></a>混用string对象和C风格字符串：</h4><p><strong>任何出现字符串字面值的地方都可以用空字符结束的字符数组来替代：</strong></p><ol><li>允许使用以空字符结束的字符数组来初始化string对象或赋值。</li><li>在string对象的加法运算中允许使用空字符结束的字符数组作为其中一个运算对象(不能两个都是)；</li></ol><p>反之不行，不能用string对象来代替c风格字符串。为了完成这个功能，string专门提供了一个函数<strong>c_str</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *str = s; <span class="comment">//错误，不能用string对象初始化char*</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *str = s.c_str(); <span class="comment">//正确</span></span><br></pre></td></tr></table></figure><p>c_str()函数返回值是一个以空字符结束的字符数组的指针。指针类型是const char*。但如果后续操作改变了s的值那么之前返回的数组失去作用。</p><p>所以：如果执行完c_str()函数后想一直使用，那么最好拷贝一份。</p><h4 id="使用数组初始化vector对象："><a href="#使用数组初始化vector对象：" class="headerlink" title="使用数组初始化vector对象："></a>使用数组初始化vector对象：</h4><p>用数组初始化vector对象只需指明拷贝区域的<strong>首元素地址和尾后地址</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> int_arr[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec(begin(arr), end(arr));</span><br></pre></td></tr></table></figure><p>同样可以只拷贝数组的一部分：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; subVec(arr + <span class="number">1</span>, arr + <span class="number">4</span>);<span class="comment">//拷贝arr[1],arr[2],arr[3]</span></span><br></pre></td></tr></table></figure><h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><p>多维数组就是数组的数组。</p><h4 id="多维数组的初始化："><a href="#多维数组的初始化：" class="headerlink" title="多维数组的初始化："></a>多维数组的初始化：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="comment">//3个元素，每个元素都是大小为4 的数组</span></span><br><span class="line">&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;,</span><br><span class="line">&#123;<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中内嵌花括号不是必需的，例如下面：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>&#125;;<span class="comment">//功能同上</span></span><br></pre></td></tr></table></figure><p>类似一维数组，初始化时并非所有元素都包含在初始化列表内：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//显式的初始化每行的首元素</span></span><br><span class="line"><span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">0</span>&#125;,&#123;<span class="number">4</span>&#125;,&#123;<span class="number">8</span>&#125;&#125;;</span><br><span class="line"><span class="comment">//显式初始化第一行</span></span><br><span class="line"><span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure><h4 id="多维数组下标引用："><a href="#多维数组下标引用：" class="headerlink" title="多维数组下标引用："></a>多维数组下标引用：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (&amp;row)[<span class="number">4</span>] = ia[<span class="number">1</span>]; <span class="comment">//row是含有4个元素的数组的引用，引用ia数组的第二个四元数组上</span></span><br></pre></td></tr></table></figure><h4 id="使用范围for处理多维数组："><a href="#使用范围for处理多维数组：" class="headerlink" title="使用范围for处理多维数组："></a>使用范围for处理多维数组：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">使用范围<span class="keyword">for</span>处理多维数组：</span><br><span class="line"><span class="keyword">size_t</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;row : ia)&#123;<span class="comment">//对于外层数组的每一个元素，row是int[4]类型的引用</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;col : row)&#123;<span class="comment">//对于内层数组的每一个元素</span></span><br><span class="line">col = cnt;</span><br><span class="line">++cnt;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上<strong>row必需声明为引用类型</strong>，这是因为如果不用引用类型那么auto会变为指向数组内首元素的指针，那么遍历指针就不合法了。所以除了最内层的循环，其他的循环变量都为引用类型。</p><h4 id="指针和多维数组："><a href="#指针和多维数组：" class="headerlink" title="指针和多维数组："></a>指针和多维数组：</h4><p>定义指向多维数组的指针，就是指向指针的指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> (*p)[<span class="number">4</span>] = ia;<span class="comment">//指向ia第一个四元素数组的指针</span></span><br><span class="line">p = &amp;ia[<span class="number">2</span>];<span class="comment">//指向ia的第三个元素</span></span><br></pre></td></tr></table></figure><p>通过使用auto或者decltype可以避免在数组面前加一个指针类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> p = begin(ia);p!=end(ia);++p)&#123; <span class="comment">//p指向ia的内层数组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> q = begin(*p);q!=end(*p);++q)&#123;<span class="comment">//q指向*p的数组的首元素</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;*q&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类型别名简化多维数组的指针："><a href="#类型别名简化多维数组的指针：" class="headerlink" title="类型别名简化多维数组的指针："></a>类型别名简化多维数组的指针：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> int_array = <span class="keyword">int</span>[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> int_array[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(int_array p = begin(ia);p!=end(ia);++p)&#123; <span class="comment">//p指向ia的内层数组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> q = begin(*p);q!=end(*p);++q)&#123;<span class="comment">//q指向*p的数组的首元素</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;*q&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数组&quot;&gt;&lt;a href=&quot;#数组&quot; class=&quot;headerlink&quot; title=&quot;数组&quot;&gt;&lt;/a&gt;数组&lt;/h1&gt;&lt;p&gt;数组是一种类似于标准库类型vector的数据结构。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;与vector相似的是，数组也是存放类型相同的对象的容器，这些
      
    
    </summary>
    
      <category term="C++Primer笔记" scheme="http://yoursite.com/categories/C-Primer%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="array" scheme="http://yoursite.com/tags/array/"/>
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>迭代器</title>
    <link href="http://yoursite.com/2019/02/23/iterator/"/>
    <id>http://yoursite.com/2019/02/23/iterator/</id>
    <published>2019-02-23T13:14:57.000Z</published>
    <updated>2019-02-23T13:18:37.117Z</updated>
    
    <content type="html"><![CDATA[<h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><h3 id="迭代器的介绍"><a href="#迭代器的介绍" class="headerlink" title="迭代器的介绍"></a>迭代器的介绍</h3><p>迭代器是一种比下标运算符访问元素更通用的机制。</p><p>所有标准库容器都可以使用<strong>迭代器</strong>，但是只有少数几种才同时支持<strong>下标运算符</strong>。</p><h4 id="迭代器类型："><a href="#迭代器类型：" class="headerlink" title="迭代器类型："></a>迭代器类型：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it1;<span class="comment">//能读写vector&lt;int&gt;的元素</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span>::iterator it2;<span class="comment">//能读写string对象中的元素</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator it3;<span class="comment">//只能读vector&lt;int&gt;的元素</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span>::const_iterator it4;<span class="comment">//只能读string对象中的元素</span></span><br></pre></td></tr></table></figure><p>跟常量指针差不多，如果vector对象或string对象不是常量，那么既可以用iterator也可以用const_iterator。</p><h4 id="迭代器成员begin和end："><a href="#迭代器成员begin和end：" class="headerlink" title="迭代器成员begin和end："></a>迭代器成员begin和end：</h4><p>有迭代器的类型同时拥有返回迭代器的成员。比如这些类型都拥有名为begin和end的成员，其中begin成员负责返回指向第一个元素的迭代器。如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> a = v.begin(), b =v.end();</span><br></pre></td></tr></table></figure><p>迭代器b被称作尾后迭代器。它指向的是尾元素的下一个位置，本不存在的位置。</p><p><strong>如果容器为空，那么begin和end返回的是同一个尾后迭代器。</strong></p><p>如果容器对象的类型是常量，那么begin 和end返回的类型是const_iterator。如果不是则返回iterator：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cv;</span><br><span class="line"><span class="keyword">auto</span> it1 = v.begin();<span class="comment">//it1的类型是vector&lt;int&gt;::iterator</span></span><br><span class="line"><span class="keyword">auto</span> it2 = cv.begin();<span class="comment">//it2的类型是vector&lt;int&gt;::const_iterator</span></span><br></pre></td></tr></table></figure><p>如果对象只需读操作，那么我们可以使用两个新函数:</p><p><strong>cbegin</strong>和<strong>cend</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> it3 = v.cbegin(); <span class="comment">//it3的类型是const_iterator</span></span><br></pre></td></tr></table></figure><h3 id="迭代器运算符-操作-："><a href="#迭代器运算符-操作-：" class="headerlink" title="迭代器运算符(操作)："></a>迭代器运算符(操作)：</h3><table><thead><tr><th>*iter</th><th>返回迭代器iter所指元素的引用</th></tr></thead><tbody><tr><td>iter-&gt;mem</td><td>解引用iter并获取该元素的名为mem的成员，等价于(*iter).mem</td></tr><tr><td>++iter</td><td>令iter指示容器中的下一个元素</td></tr><tr><td>–iter</td><td>令iter指示容器中的上一个元素</td></tr><tr><td>iter1 == iter2、iter1 != iter2</td><td>判断两个迭代器是否相等(不相等)，如果两个迭代器指示的是同一个元素或者它们是同一个容器的尾后迭代器，则相等。</td></tr></tbody></table><h4 id="解引用和成员访问："><a href="#解引用和成员访问：" class="headerlink" title="解引用和成员访问："></a>解引用和成员访问：</h4><p>和指针一样，迭代器也能被解引用来获取所指示的元素，当然前提是迭代器合法并且确实指示某一个元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">"some string"</span>)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (s.begin() != s.end())&#123;<span class="comment">//确保s非空</span></span><br><span class="line">    <span class="keyword">auto</span> it = s.begin();<span class="comment">//it指示s的第一个字符</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; *it &lt;&lt;<span class="built_in">endl</span>;<span class="comment">//解引用获取元素输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解引用可以获得迭代器所指的对象，如果对象的类型刚好是类，就能进一步<strong>访问它的成员</strong>。例如vector<string>想要检查元素是否为空就可以用：</string></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(*it).empty();<span class="comment">//此处的括号必须要加</span></span><br></pre></td></tr></table></figure><p>然后为了简化上述操作，c++定义了 箭头运算符(-&gt;)。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">it-&gt;empty();<span class="comment">//和上面意思相同</span></span><br></pre></td></tr></table></figure><h4 id="迭代器的移动："><a href="#迭代器的移动：" class="headerlink" title="迭代器的移动："></a>迭代器的移动：</h4><p>将迭代器从一个元素移到另外一个元素：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s= “some thing”;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it = s.begin();it!=s.end &amp;&amp; !<span class="built_in">isspace</span>(*it);++it)&#123;</span><br><span class="line">*it = <span class="built_in">toupper</span>(*it); <span class="comment">//将当前字符大写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在for里不用&lt;而用!= 的原因是因为迭代器使然</strong>，之前说只有string和vector等一些标准库类型有下标运算符，并非全部如此。与之类似，所有标准库容器的迭代器都定义了==和!=，但是大多数没有&lt;运算符。</p><h4 id="某些对vector对象操作会使迭代器失效："><a href="#某些对vector对象操作会使迭代器失效：" class="headerlink" title="某些对vector对象操作会使迭代器失效："></a>某些对vector对象操作会使迭代器失效：</h4><p>vector是动态增长，但也有副作用。已知的一个限制是不能在范围for循环中向vector对象添加元素。另外一个是任何一种可能改变vector容量的操作，比如push_back。都会使迭代器失效。9.3.6</p><h4 id="迭代器运算："><a href="#迭代器运算：" class="headerlink" title="迭代器运算："></a><strong>迭代器运算：</strong></h4><p>迭代器的算术运算(必须是两个迭代器指向同一个容器中的元素)：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">iter += n;<span class="comment">//向前移动了n个元素</span></span><br><span class="line"></span><br><span class="line">iter -= n;<span class="comment">//向后移动了n个元素</span></span><br><span class="line"></span><br><span class="line">iter1 - iter2; <span class="comment">//两个迭代器相减就是他们的距离</span></span><br><span class="line"></span><br><span class="line">&lt;、&gt;、&lt;=、&gt;=;<span class="comment">//两个迭代器的前后位置比较</span></span><br></pre></td></tr></table></figure><p>只要两个迭代器指向的是同一个容器或者尾元素，就能相减。距离是指右侧迭代器向前移动多少位就能追上左侧迭代器，其类型名是<strong>difference_type</strong>的带符号整型数。</p><p>ps：还需拓展</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;迭代器&quot;&gt;&lt;a href=&quot;#迭代器&quot; class=&quot;headerlink&quot; title=&quot;迭代器&quot;&gt;&lt;/a&gt;迭代器&lt;/h1&gt;&lt;h3 id=&quot;迭代器的介绍&quot;&gt;&lt;a href=&quot;#迭代器的介绍&quot; class=&quot;headerlink&quot; title=&quot;迭代器的介绍&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="C++Primer笔记" scheme="http://yoursite.com/categories/C-Primer%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="iterator" scheme="http://yoursite.com/tags/iterator/"/>
    
      <category term="迭代器" scheme="http://yoursite.com/tags/%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>标准库类型vector</title>
    <link href="http://yoursite.com/2019/02/23/vector/"/>
    <id>http://yoursite.com/2019/02/23/vector/</id>
    <published>2019-02-23T13:14:37.000Z</published>
    <updated>2019-02-23T13:17:14.400Z</updated>
    
    <content type="html"><![CDATA[<h1 id="标准库类型vector"><a href="#标准库类型vector" class="headerlink" title="标准库类型vector"></a>标准库类型vector</h1><p>vector表示对象的集合，其中所有对象的类型都相同。它是一个容器。</p><p>想要使用vector需要添加头文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span></span><br></pre></td></tr></table></figure><p>同时vector也是一个<strong>类模板</strong>,因此需要提供额外信息指定模板实例化成什么样的类。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec;<span class="comment">//ivec保存int类型的对象</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; file;<span class="comment">//该向量的元素是vector对象</span></span><br></pre></td></tr></table></figure><h3 id="vector的初始化"><a href="#vector的初始化" class="headerlink" title="vector的初始化"></a>vector的初始化</h3><p><strong>常用初始化vector对象的方法:</strong></p><table><thead><tr><th>vector<t> v1</t></th><th>v1是一个空vector，它潜在元素是T类型的，执行默认初始化</th></tr></thead><tbody><tr><td>vector<t> v2(v1)</t></td><td>v2中包含有v1所有元素的副本</td></tr><tr><td>vector<t> v2 = v1</t></td><td>等价于v2(v1)</td></tr><tr><td>vector<t> v3(n, val)</t></td><td>v3包含了n个重复的元素，每个元素的值都是val</td></tr><tr><td>vector<t> v4(n)</t></td><td>v4包含了n个重复的执行了值初始化的对象</td></tr><tr><td>vector<t> v5{a, b, c…}</t></td><td>v5包含了初始值个数的元素，每个元素都被赋予相应的初始值</td></tr><tr><td>vector<t> v5 = {a, b, c…}</t></td><td>等价于v5{a, b, c…}</td></tr></tbody></table><h4 id="列表初始化vector对象："><a href="#列表初始化vector对象：" class="headerlink" title="列表初始化vector对象："></a>列表初始化vector对象：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; articles = &#123;“a”, “an”, “the”&#125;; <span class="comment">//花括号</span></span><br></pre></td></tr></table></figure><h4 id="创建指定元素的数量："><a href="#创建指定元素的数量：" class="headerlink" title="创建指定元素的数量："></a>创建指定元素的数量：</h4><p>用vector对象容纳的<strong>元素数量</strong>，和<strong>元素统一初始值</strong>来初始化vector。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec(<span class="number">10</span>, <span class="number">-1</span>); <span class="comment">//10个int类型的元素，值都为-1</span></span><br></pre></td></tr></table></figure><h4 id="值初始化："><a href="#值初始化：" class="headerlink" title="值初始化："></a>值初始化：</h4><p>通常情况下，我们可以只提供vector元素的数量。那么库会创建一个<strong>值初始化</strong>的元素初值，由vector对象的类型决定。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec(<span class="number">10</span>);<span class="comment">//10个元素都是0</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; svec(<span class="number">10</span>);<span class="comment">//10个每个都是空的string对象</span></span><br></pre></td></tr></table></figure><p>这种初始化有两个限制：</p><ul><li>其一，有些类要求明确必须提供初始值(2.2.1)。</li><li>其二，只提供元素的数量而没有设定初始值只能用直接初始化,而不是拷贝初始化。</li></ul><h4 id="初始化的圆括号-，与花括号"><a href="#初始化的圆括号-，与花括号" class="headerlink" title="初始化的圆括号()，与花括号{}"></a>初始化的圆括号()，与花括号{}</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1(<span class="number">10</span>);<span class="comment">//v1有10个元素，每个都是0 </span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2&#123;<span class="number">10</span>&#125;;<span class="comment">//v2有1个元素是10  </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v3(<span class="number">10</span>, <span class="number">1</span>)<span class="comment">//v3 10个元素每个是1</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v4&#123;<span class="number">10</span>,<span class="number">1</span>&#125; <span class="comment">//v3 有个2个元素。10和1</span></span><br></pre></td></tr></table></figure><p> 可以说：</p><ol><li>如果用的是圆括号，可以说提供的值是用来构造vector对象。</li><li>如果是用花括号，首先是表述为想用列表初始化该vector对象，除非当提供的值无法进行列表初始化，那么它会考虑其他初始化方式，比如下列：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; svec&#123;<span class="number">10</span>, “hi”&#125;;<span class="comment">//花括号，会初始化为10个”hi”</span></span><br></pre></td></tr></table></figure><p>上述代码可以看出，int值无法初始化string对象，所以当编译器确定了无法执行列表初始化后，会尝试用默认值初始化vector对象。</p><h3 id="vector的操作："><a href="#vector的操作：" class="headerlink" title="vector的操作："></a>vector的操作：</h3><p><strong>vector支持的操作：</strong></p><table><thead><tr><th>v.empty()</th><th>如果v中不含有元素，返回真；否则返回假</th></tr></thead><tbody><tr><td>v.size()</td><td>返回v中元素的个数</td></tr><tr><td>v.push_back(t)</td><td>向v的尾端添加一个值为t的元素</td></tr><tr><td>v[n]</td><td>返回v中第n个位置上元素的引用</td></tr><tr><td>v1 = v2</td><td>用v2中元素拷贝替换v1中元素</td></tr><tr><td>v1 = {a, b, c…}</td><td>用列表中元素拷贝替换v1中元素</td></tr><tr><td>v1 == v2、 v1 != v2</td><td>v1和v2相等 当且仅当 它们的元素数量相同且对应位置元素值相同</td></tr><tr><td>&lt;, &lt;=, &gt;, &gt;=</td><td>以字典顺序比较</td></tr></tbody></table><h4 id="v-size-："><a href="#v-size-：" class="headerlink" title="v.size()："></a>v.size()：</h4><p>类似string类，v.size()返回的是 <strong>vector<t>::size_type</t></strong>类型</p><h4 id="vector不能用下标形式添加元素："><a href="#vector不能用下标形式添加元素：" class="headerlink" title="vector不能用下标形式添加元素："></a><strong>vector不能用下标形式添加元素：</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec;<span class="comment">//空vector</span></span><br><span class="line">ivec[<span class="number">0</span>] = <span class="number">1</span>;<span class="comment">//错误，ivec不包含任何元素</span></span><br></pre></td></tr></table></figure><p>空的vector不包含任何元素，自然不能用下标访问不存在的元素，正确的方法是用push_back。 否则会造成缓冲区溢出(buffer overflow)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;标准库类型vector&quot;&gt;&lt;a href=&quot;#标准库类型vector&quot; class=&quot;headerlink&quot; title=&quot;标准库类型vector&quot;&gt;&lt;/a&gt;标准库类型vector&lt;/h1&gt;&lt;p&gt;vector表示对象的集合，其中所有对象的类型都相同。它是一个容器。
      
    
    </summary>
    
      <category term="C++Primer笔记" scheme="http://yoursite.com/categories/C-Primer%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="vector" scheme="http://yoursite.com/tags/vector/"/>
    
  </entry>
  
  <entry>
    <title>标准库类型string</title>
    <link href="http://yoursite.com/2019/02/20/string/"/>
    <id>http://yoursite.com/2019/02/20/string/</id>
    <published>2019-02-19T22:44:44.000Z</published>
    <updated>2019-02-20T13:41:45.339Z</updated>
    
    <content type="html"><![CDATA[<h1 id="标准库类型string"><a href="#标准库类型string" class="headerlink" title="标准库类型string"></a>标准库类型string</h1><p>string表示可变长的字符序列。</p><ul><li>使用string类型必须首先包含头文件</li><li>作为标准库的一部分，string定义在命名空间std中。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>一个类可以定义很多种初始化对象的方式，但是这些方式之间必须有所区别：</p><ul><li>或者是初始值数量不同</li><li>或者是初始值类型不同</li></ul><p><strong>以下是初始化string的方式：</strong></p><ol><li>默认初始化</li></ol><p>通过默认的方式初始化一个string对象，得到的s1是个空字符串。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s1;<span class="comment">//默认初始化</span></span><br></pre></td></tr></table></figure><ol start="2"><li>用另一个string进行初始化</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(s1)</span></span>;<span class="comment">//s2是s1的副本</span></span><br><span class="line"><span class="built_in">string</span> s2 = s1;<span class="comment">//等价于s2(s1)</span></span><br></pre></td></tr></table></figure><ol start="3"><li>给定一个字符串字面值</li></ol><p>则该字面值中除了最后一个空字符外其他所有的字符都被拷贝到新创建的string对象中去。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s3</span><span class="params">(“value”)</span></span>;<span class="comment">//s3是字面值”value”的副本，除了字面值最后一个空字符外</span></span><br><span class="line"><span class="built_in">string</span> s3 = “value”;<span class="comment">//同上</span></span><br></pre></td></tr></table></figure><ol start="4"><li>给定一个数字和一个字符</li></ol><p>则string对象的内容是给定字符连续重复若干次后得到的序列。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s4</span><span class="params">(n,’c’)</span></span>;<span class="comment">//把s4初始化为由连续n个字符c组成的串</span></span><br></pre></td></tr></table></figure><h4 id="直接初始化和拷贝初始化"><a href="#直接初始化和拷贝初始化" class="headerlink" title="直接初始化和拷贝初始化"></a>直接初始化和拷贝初始化</h4><p>像用“=”等号初始化一个变量是拷贝初始化，反之则是直接初始化。</p><p>而像上面的s4那样初始化用到的值有多个，一般来说只能使用直接初始化的方式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s5 = <span class="string">"hi"</span>;<span class="comment">//拷贝初始化</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s6</span><span class="params">(<span class="string">"hi"</span>)</span></span>;<span class="comment">//直接初始化</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s7</span><span class="params">(<span class="number">10</span>, <span class="string">'C'</span>)</span></span>;<span class="comment">//直接初始化，s7为cccccccccc</span></span><br></pre></td></tr></table></figure><h4 id="string对象上的操作"><a href="#string对象上的操作" class="headerlink" title="string对象上的操作:"></a><strong>string对象上的操作:</strong></h4><p>以下是大多数操作：</p><table><thead><tr><th>os&lt;&lt;s</th><th>将s写到输出流os中，返回os</th></tr></thead><tbody><tr><td>is&gt;&gt;s</td><td>将is中读出字符串赋给s，字符串以<strong>空白分隔</strong>，返回is</td></tr><tr><td>getline(is,s)</td><td>从is中读取一行赋给s，返回is</td></tr><tr><td>s.empty()</td><td>s为空返回true，否则返回false</td></tr><tr><td>s.size()</td><td>返回s中字符的个数</td></tr><tr><td>s[n]</td><td>返回s中第n个字符的引用，位置从0计起</td></tr><tr><td>s1+s2</td><td>返回s1和s2连接后的结果</td></tr><tr><td>s1=s2</td><td>用s2的副本代替s1中原来的字符</td></tr><tr><td>s1==s2</td><td>如果s1和s2中所含的字符完全一样，则他们相等</td></tr><tr><td>s1!=s2</td><td>与上相反</td></tr><tr><td>&lt;,&lt;=,&gt;,&gt;=</td><td>利用字符在字典中的顺序进行比较，对大小写敏感</td></tr></tbody></table><h4 id="读写string对象"><a href="#读写string对象" class="headerlink" title="读写string对象"></a>读写string对象</h4><p>可以使用io操作符读写string对象:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s1, s2;<span class="comment">//空字符串</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s1 &gt;&gt; s2;<span class="comment">//将string对象读入s，遇到空白停止</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; s1 &lt;&lt; s2 &lt;&lt;<span class="built_in">endl</span>;<span class="comment">//输出s</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在执行读取操作时，string对象会自动<strong>忽略开头的空白</strong>(即空格符、换行符、制表符等)并从第一个真正的字符读起，直到<strong>遇见下一处空白</strong>。</p><p>例如输入”    hello world    “，那么输出会是”hello”和”world”，不会有空白。</p><h5 id="使用getline-读取一整行："><a href="#使用getline-读取一整行：" class="headerlink" title="使用getline()读取一整行："></a>使用getline()读取一整行：</h5><p>有时我们希望最终得到的字符串中保留输入时的空白符，那么用getline()代替原来的&gt;&gt;运算符。他的参数是一个输入流和一个string对象，函数从给定的输入流中读入内容，直到遇到换行符位置(换行符也读入)，然后将内容存到string(不存换行符)。随后返回它的流参数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> line;</span><br><span class="line">getline(<span class="built_in">cin</span>, line);<span class="comment">//读入一整行</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; line &lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h5 id="string-size-type类型："><a href="#string-size-type类型：" class="headerlink" title="string::size_type类型："></a>string::size_type类型：</h5><p>对于size()函数来说，返回一个int类型或者unsigned似乎都是合情合理的。但是size函数返回的是一个string::size_type类型的值。</p><p>string类以及其他大多数标准库类型都定义了几种配套的类型，为了体现标准库类型与机器无关。</p><p>它是一个<strong>无符号类型</strong>的值，而且<strong>足够存放</strong>下任何string对象的大小。</p><h5 id="比较string对象："><a href="#比较string对象：" class="headerlink" title="比较string对象："></a>比较string对象：</h5><p>相等性运算符(== 、!=)和关系运算符(&lt;、&lt;=、&gt;、&gt;=)都按照字典顺序：</p><ol><li><p>如果两个string对象的长度不同，而且较短string对象的每个字符都与较长string对象对应位置上字符相同，就说较短string小于较长string</p></li><li><p>如果两个string对象在某些对应位置上不一致，则string对象比较的结果其实是string对象中第一对不同字符比较的结果</p></li></ol><p>例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str = <span class="string">"Hello"</span>;</span><br><span class="line"><span class="built_in">string</span> phrase = <span class="string">"Hello World"</span>;</span><br><span class="line"><span class="built_in">string</span> slang = <span class="string">"Hiya"</span>;</span><br></pre></td></tr></table></figure><p>根据规则1，str&lt;phrase。根据规则2, slang&gt;phrase 也 &gt;str。</p><h5 id="字面值和string对象相加："><a href="#字面值和string对象相加：" class="headerlink" title="字面值和string对象相加："></a>字面值和string对象相加：</h5><p>标准库允许把字符字面值和字符串字面值转换成string对象。但必须确保每个加法运算符(+)两侧运算对象至少有一个是string：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s3 = s1 + <span class="string">"value"</span>;<span class="comment">//正确 </span></span><br><span class="line"><span class="built_in">string</span> s4 = <span class="string">"value"</span> + <span class="string">","</span>;<span class="comment">//错误 两个都不是string</span></span><br><span class="line"><span class="built_in">string</span> s5 = s1 + <span class="string">"value"</span> + <span class="string">","</span> + <span class="string">"dog"</span>; <span class="comment">//正确，每个加法都有一个string</span></span><br><span class="line"><span class="built_in">string</span> s6 = <span class="string">"value"</span> + <span class="string">","</span> + s1;<span class="comment">//错误，不能把字面值相加</span></span><br></pre></td></tr></table></figure><p><strong><u>注意</u>：字符串字面值与string是不同的类型。</strong></p><h5 id="string处理字符的一些函数"><a href="#string处理字符的一些函数" class="headerlink" title="string处理字符的一些函数:"></a>string处理字符的一些函数:</h5><p><strong>表:cctype头文件的函数</strong></p><table><thead><tr><th>isalnum(c)</th><th>当c是字母或数字时为真</th></tr></thead><tbody><tr><td>isalpha(c)</td><td>当c是字母时为真</td></tr><tr><td>iscntrl(c)</td><td>当c是控制字符为真</td></tr><tr><td>isdigit(c)</td><td>当c是数字时为真</td></tr><tr><td>isgraph(c)</td><td>当c不是空格但可打印时为真</td></tr><tr><td>islower(c)</td><td>当c是小写字母时为真</td></tr><tr><td>isprint(c)</td><td>当c是可打印字符时为真(即c是空格或c具有可视形式)</td></tr><tr><td>ispunct(c)</td><td>当c是标点符号时为真(即c不是控制字符、数字、字母、可打印空白中的一种)</td></tr><tr><td>isspace(c)</td><td>当c是空白时为真(即c是空格、横向制表符、纵向制表符、回车符、换行符、进纸符中的一种)</td></tr><tr><td>isupper(c)</td><td>当c是大写字母时为真</td></tr><tr><td>isxdigit(c)</td><td>当c是十六进制数字时为真</td></tr><tr><td>tolower(c)</td><td>如果c是大写字母，输出对应的小写字母；否则原样输出c</td></tr><tr><td>toupper(c)</td><td>如果c是小写字母，输出对应的大写字母；否则原样输出c</td></tr></tbody></table><p><strong><u>建议</u>使用c++的兼容c的标准库头文件</strong>。c语言头文件为name.h而c++则将命名为cname。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;标准库类型string&quot;&gt;&lt;a href=&quot;#标准库类型string&quot; class=&quot;headerlink&quot; title=&quot;标准库类型string&quot;&gt;&lt;/a&gt;标准库类型string&lt;/h1&gt;&lt;p&gt;string表示可变长的字符序列。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用s
      
    
    </summary>
    
      <category term="C++Primer笔记" scheme="http://yoursite.com/categories/C-Primer%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="string" scheme="http://yoursite.com/tags/string/"/>
    
  </entry>
  
  <entry>
    <title>变量、基本类型和类型别名</title>
    <link href="http://yoursite.com/2019/02/19/variable-type/"/>
    <id>http://yoursite.com/2019/02/19/variable-type/</id>
    <published>2019-02-19T14:32:03.000Z</published>
    <updated>2019-02-20T12:38:52.949Z</updated>
    
    <content type="html"><![CDATA[<h1 id="变量、基本类型和类型别名"><a href="#变量、基本类型和类型别名" class="headerlink" title="变量、基本类型和类型别名"></a><strong>变量、基本类型和类型别名</strong></h1><p><strong>任何编程语言都具备一组公共语法特征，基本特征包括</strong>：</p><ul><li>整型、字符型等内置类型</li><li>变量，用来为对象命名</li><li>表达式和语句，用于操纵上述数据类型的具体值</li><li>if或while等控制结构，这些结构允许我们有选择的执行一些语句。</li><li>函数，用于定义可供随时调用的计算单元</li></ul><p><strong>大多数变成语言通过两种方式来进一步补充其基本特征</strong>：</p><ol><li>赋予程序员自定义数据类型的权利，从而实现扩展</li><li>将一些有用的功能封装成库函数提供使用</li></ol><h2 id="基本内置类型"><a href="#基本内置类型" class="headerlink" title="基本内置类型"></a>基本内置类型</h2><p>C++定义了一套包括算术类型(arithmetic type)和空类型(void)在内的基本数据类型。其中算术类型包括字符、整型数、布尔值和浮点数。</p><h3 id="C-基本类型大小"><a href="#C-基本类型大小" class="headerlink" title="C++基本类型大小"></a>C++基本类型大小</h3><p>int，long int，short int的宽度都可能随编译器而异。但有几条铁定的原则（ANSI/ISO制订的）：</p><ul><li>sizeof(short int) &lt;= sizeof(int)</li><li>sizeof(int) &lt;= sizeof(long int)</li><li>short int至少应为16位（2字节）</li><li>long int至少应为32位。</li></ul><p><strong>表：c++算数类型</strong></p><table><thead><tr><th>类型</th><th>含义</th><th>最小尺寸</th></tr></thead><tbody><tr><td>bool</td><td>布尔类型(true,false)</td><td>未定义</td></tr><tr><td>char</td><td>字符</td><td>8位</td></tr><tr><td>wchar_t</td><td>宽字符</td><td>16位</td></tr><tr><td>char16_t</td><td>Unicode字符</td><td>16位</td></tr><tr><td>char32_t</td><td>Unicode字符</td><td>32位</td></tr><tr><td>short</td><td>短整型</td><td>16位</td></tr><tr><td>int</td><td>整型</td><td>16位</td></tr><tr><td>long</td><td>长整型</td><td>32位</td></tr><tr><td>long long</td><td>长整型</td><td>64位</td></tr><tr><td>float</td><td>单精度浮点数</td><td>6位有效数字</td></tr><tr><td>double</td><td>双精度浮点数</td><td>10位有效数字</td></tr><tr><td>long double</td><td>扩展进度浮点数</td><td>10位有效数字</td></tr></tbody></table><p>c++标准制定了一个浮点数有效位数的最小值，然而大多数编译器实现了更高的进度。通常float以1个字节(32位)来表示，double以2个字节表示，long double以3或4个字节表示。</p><h4 id="带符号和不带符号类型"><a href="#带符号和不带符号类型" class="headerlink" title="带符号和不带符号类型"></a>带符号和不带符号类型</h4><p>除去布尔型和扩展的字符型之外，其他可以划分为带符号的(signed)和不带符号的(unsigned)。带符号可表示正数、负数或0，无符号仅能表示大于等于0的值。</p><p>类型int、short、long、long long都是带符号的，在前添加unsigned就是不带符号的类型，unsigned int可以缩写为unsigned。</p><p>与其他整型不同 char被分为三种 char 、signed char、unsigned char。尽管字符型有3种但是字符的表现形式只有两种：带符号和无符号。类型char会表现为以上两种，具体由编译器决定。</p><p>例：8bit的signed char表示范围定为-128~127。</p><p><u><strong>建议：选择类型</strong></u></p><ul><li>当明确数值为正时，选用无符号类型</li><li>使用int执行整数运算。在应用中，short常常太小而long一般和int一样的尺寸。如果数值超过了int表示范围。选用long long</li><li>算数表达式中不要使用char 或 bool，只有在存放字符或布尔时使用它们。因为类型char在一些机器上是有符号而另一些是无符号，容易出问题。如果需要使用一个不大的整数明确是unsigned char 还是 signed char。</li><li>执行浮点数运算选用double，因为float通常精度不够而且双精度浮点数和单精度浮点数计算代价相差无几。事实上对于某些机器来说双精度运算更快。</li></ul><h3 id="字面值常量（literal）"><a href="#字面值常量（literal）" class="headerlink" title="字面值常量（literal）"></a>字面值常量（literal）</h3><p>一个形如42的值被称作<strong>字面值常量</strong>，这样的值一望而知。每个字面值常量都对应一种数据类型，由它的形式和值决定。</p><h4 id="整数和浮点型字面值："><a href="#整数和浮点型字面值：" class="headerlink" title="整数和浮点型字面值："></a><strong>整数和浮点型字面值：</strong></h4><p> 整型字面值写成 十进制、八进制、十六进制。以0开头的整数代表八进制数，以0x、0X代表十六进制。例如：</p><p> 20  (十进制 )             024 (八进制)             0x14 (十六进制)</p><p>整型字面值的数据类型由他的值和符号决定。默认情况，十进制字面值带符号数，八进制和十六进制带符号不带符号都可能。十进制是int、long、long long中能容纳下当前值的最小尺寸（例如三者最小是int）。八进制和十六进制是int 、unsigned int、…unsigned long long 中容纳下当前值的最小尺寸。如果一个字面值与之关联的最大数据类型都放不下则产生错误。short无字面值。</p><p>负号字面值只是 字面值取反。例如-42，负号不在字面值内，它的作用仅仅是对字面值取负值而已。</p><p>浮点数字面值表示为 小数或带e的科学计数法的指数。默认是double</p><h4 id="字符和字符串字面值："><a href="#字符和字符串字面值：" class="headerlink" title="字符和字符串字面值："></a>字符和字符串字面值：</h4><p>字符：‘a’</p><p>字符串：“hello”</p><p>字符串字面值是由常量字符组成的数组，<strong>最后有个‘\0’空字符</strong>。如果两个字符串字面值由空格、缩进、换行符分隔，实际上是一个字符串。</p><h4 id="布尔和指针字面值："><a href="#布尔和指针字面值：" class="headerlink" title="布尔和指针字面值："></a>布尔和指针字面值：</h4><p>布尔：true、false</p><p>指针：nullptr</p><h4 id="转义序列："><a href="#转义序列：" class="headerlink" title="转义序列："></a>转义序列：</h4><p>有两类字符程序员不能直接使用：</p><ol><li>不可打印的字符，如退格或其他控制字符</li><li>在c++语言中含有特殊含义的字符（引号、问号等）</li></ol><p>这时候就需要用到转义序列。</p><table><thead><tr><th>换行符</th><th>\n</th><th>横向制表符</th><th style="text-align:left">\t</th><th>报警符</th><th>\a</th></tr></thead><tbody><tr><td><strong>纵向制表符</strong></td><td><strong>\v</strong></td><td><strong>退格符</strong></td><td style="text-align:left">\b</td><td>双引号</td><td>\“</td></tr><tr><td><strong>反斜线</strong></td><td>\ \</td><td>问号</td><td style="text-align:left">\?</td><td><strong>单引号</strong></td><td>\‘</td></tr><tr><td><strong>回车符</strong></td><td><strong>\r</strong></td><td><strong>进纸符</strong></td><td style="text-align:left">\f</td><td></td></tr></tbody></table><p>也可以用泛化的转义序列，有下两种形式：</p><ol><li>\x 后紧跟1个或多个十六进制数字（一般超过8位的十六进制字符都是与下表中的某个前缀开头的扩展字符集一起使用的）</li><li>\ 后紧跟1~3个八进制数字</li></ol><h4 id="指定字面值的类型："><a href="#指定字面值的类型：" class="headerlink" title="指定字面值的类型："></a>指定字面值的类型：</h4><p><strong>表：字符和字符串字面值：</strong></p><table><thead><tr><th>前缀</th><th>含义</th><th>类型</th></tr></thead><tbody><tr><td>u</td><td>Unicode16字符</td><td>char16_t</td></tr><tr><td>U</td><td>Unicode32字符</td><td>char32_t</td></tr><tr><td>L</td><td>宽字符</td><td>wchar_t</td></tr><tr><td>u8</td><td>UTF-8（仅用于字符串字面常量）</td><td>char</td></tr></tbody></table><p><strong>表：整型字面值</strong>                            </p><table><thead><tr><th>后缀</th><th>最小匹配类型</th></tr></thead><tbody><tr><td>u or U</td><td>unsigned</td></tr><tr><td>l or L</td><td>long</td></tr><tr><td>ll or LL</td><td>long long</td></tr></tbody></table><p><strong>表：浮点型字面值</strong></p><table><thead><tr><th>后缀</th><th>最小匹配类型</th></tr></thead><tbody><tr><td>f or F</td><td>float</td></tr><tr><td>l or L</td><td>long double</td></tr></tbody></table><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量提供一个具名的、可供程序操作的存储空间。C++中的每个变量都有其数据类型，数据类型决定着变量所占空间的大小和布局方式、该空间存储值的范围，以及变量能参与的运算。</p><h4 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h4><p>变量定义的基本形式：类型说明符 变量名，变量名；</p><p>例：int a=0,b;</p><h4 id="变量初始化"><a href="#变量初始化" class="headerlink" title="变量初始化"></a>变量初始化</h4><p>初始化的含义是创建变量时赋予一个初始值。而赋值这是把对象的当前值擦除，用一个新值代替。</p><ol><li>列表初始化</li><li>默认初始化: 如果定义变量时没有指定初值，则变量被<strong>默认初始化</strong>。内置类型在函数体外定义的话初始化为0， 函数体内则不被初始化. string 在函数内外都是默认为空字符串</li></ol><h4 id="变量的声明与定义（extern关键字）"><a href="#变量的声明与定义（extern关键字）" class="headerlink" title="变量的声明与定义（extern关键字）"></a>变量的声明与定义（extern关键字）</h4><p>C++语言支持分离式编译机制，该机制允许每个文件独立编译。为了支持分离时编译，C++将声明与定义区分开来。<strong>声明</strong>使得名字为程序所知，<strong>定义</strong>创建与名字相关联的实体。</p><p>定义区别于声明是定义除了规定了变量的类型和名字，还会申请存储空间与赋初始值。</p><p>在变量名前加关键字(extern)是声明但不要显示地初始化。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> i; <span class="comment">//声明非定义</span></span><br><span class="line"><span class="keyword">int</span> i ; <span class="comment">//声明且定义</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> i = <span class="number">2</span>; <span class="comment">//定义</span></span><br></pre></td></tr></table></figure><p>变量只能被定义一次，但可以被多次声明。在函数内部如果试图初始化一个extern关键字标记的变量会引发错误。</p><h4 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h4><p>标识符由字母数字下划线组成，必须以字母下划线开始，对长度无限制大小写敏感，不得使用c++关键字，不得连续两个下划线或下划线后加大写字母。</p><p><img src="/2019/02/19/variable-type/identifier.png" alt="c++关键字"></p><h4 id="作用域（scope）："><a href="#作用域（scope）：" class="headerlink" title="作用域（scope）："></a><strong>作用域（scope）：</strong></h4><p>作用域是程序的一部分，C++语言中大多数作用域都以花括号分隔。</p><p>同一个名字在不同的作用域中可能指向不同的实体。名字的有效区域始于名字的声明语句，以声明语句所在的作用域末端为结束。</p><p>外层作用域的变量能被能层作用域使用，当内层同样定义了一个相同的变量时会覆盖外层的变量，如需使用则要显示的调用，用<strong>作用域符号</strong>   “<strong>::</strong>“</p><h3 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h3><p>复合类型是指基于其他类型定义的类型。最常见的两种是<strong>引用</strong>和<strong>指针</strong>。</p><h4 id="复合类型的声明"><a href="#复合类型的声明" class="headerlink" title="复合类型的声明"></a>复合类型的声明</h4><p>变量的定义包括一个基本数据类型和一组声明符。在一条定义语句中，基本数据类型只有一个但是声明符的不同可以定义出不同类型的变量。</p><p>例：int i = 1024, *p = &amp;i, &amp;r = i;        //i是一个int数， p是int型指针， r是int型引用</p><h4 id="指针和引用的区别："><a href="#指针和引用的区别：" class="headerlink" title="指针和引用的区别："></a><strong>指针和引用的区别：</strong></h4><ol><li>指针指向内存中的某个对象，引用直接绑定对象。</li><li>指针本身是一个对象，允许指针赋值拷贝，在生命周期内可以指向不同的对象；引用不是对象，无法令引用重新绑定到其他对象。</li><li>指针无须在定义时赋初值，和其他内置类型一样，在块作用域内如果没有被初始化则将拥有一个不确定的值；引用则必须在定义时赋初值。</li></ol><h3 id="类型的处理"><a href="#类型的处理" class="headerlink" title="类型的处理"></a>类型的处理</h3><h4 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h4><p>类型别名用于简化一些复杂的类型名字。有typedef (类型别名)和 using (别名声明)两种方法。</p><p><strong>typedef：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> wages;<span class="comment">//wages是double的同义词</span></span><br><span class="line"><span class="keyword">typedef</span> wages base, *p;<span class="comment">//base是double的同义词，p是double*的同义词</span></span><br></pre></td></tr></table></figure><p><strong>using:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> db = <span class="keyword">double</span>;<span class="comment">//db是double的同义词</span></span><br></pre></td></tr></table></figure><p><strong><u>注意</u>的是某个类型别名指代的是符合类型或常量，那么用到声明语句就会产生意想不到的后果。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *pstring;</span><br><span class="line"><span class="keyword">const</span> pstring cstr = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>上面定义了pstring为char*类型，而const是对给定类型的修饰。所以const是修饰指针类型，cstr则是指向char的常量指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *cstr = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>而这处const修饰的是char，则cstr是指向常量char的指针。</p><h4 id="auto类型说明符"><a href="#auto类型说明符" class="headerlink" title="auto类型说明符"></a>auto类型说明符</h4><p>auto 类型说明符可以让编译器通过初始值去推算类型。因此auto定义的变量必须有初始值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> item = val1 + val2;<span class="comment">//val1、val2相加的结果推出item的类型</span></span><br></pre></td></tr></table></figure><p>使用auto也能在一条语句中声明多个变量。但是一条声明语句只能有一个基本数据类型，所以语句中变量的初始基本类型都必须一样。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> i = <span class="number">0</span>, *p = &amp;i;<span class="comment">//正确：i是整数、p是整型指针</span></span><br><span class="line"><span class="keyword">auto</span> sz = <span class="number">0</span>, pi = <span class="number">3.14</span>;<span class="comment">//错误：sz和pi的类型不一致</span></span><br></pre></td></tr></table></figure><p><strong>编译器推断出来的auto类型有时候和初始值的类型并不完全一样。</strong></p><p>例如<strong>引用</strong>，编译器会以引用对象的类型来作为auto的类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, r = &amp;i;</span><br><span class="line"><span class="keyword">auto</span> a = r;<span class="comment">//a是一个int类型的整数</span></span><br></pre></td></tr></table></figure><p>其次一般会忽略掉顶层const，而底层const会保留下来:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = i;</span><br><span class="line"><span class="keyword">auto</span> b = ci;<span class="comment">//b是整数(ci的顶层const被忽略)</span></span><br><span class="line"><span class="keyword">auto</span> c = &amp;i;<span class="comment">//c是整型指针(整数的地址就是指向整数的指针)</span></span><br><span class="line"><span class="keyword">auto</span> d = &amp;ci; <span class="comment">//d是指向整数常量的指针(对常量对象取地址是底层const)</span></span><br></pre></td></tr></table></figure><p>如果希望推出的是顶层const则需要明确定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> e = ci；</span><br></pre></td></tr></table></figure><h4 id="decltype类型指示符"><a href="#decltype类型指示符" class="headerlink" title="decltype类型指示符:"></a><strong>decltype类型指示符:</strong></h4><p>decltype说明符能从表达式的类型推断出要定义的变量的类型。在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(f()) sum = x;<span class="comment">//sum的类型就是函数f的返回类型</span></span><br></pre></td></tr></table></figure><p>decltype处理顶层const与auto有些不同。</p><p>如果decltype使用的表达式是一个变量，则decltype返回的类型包括<strong>顶层const</strong>和<strong>引用</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">0</span>, &amp;cj = ci;</span><br><span class="line"><span class="keyword">decltype</span>(ci) x = <span class="number">0</span>;<span class="comment">//x的类型是const int</span></span><br><span class="line"><span class="keyword">decltype</span>(cj) y = x;<span class="comment">//y的类型是const int&amp;，y绑定到变量x</span></span><br><span class="line"><span class="keyword">decltype</span>(cj) z;<span class="comment">//错误，z是引用，必须初始化</span></span><br></pre></td></tr></table></figure><p><strong>需要指出的是，引用从来都是作为所指对象的同义词出现，只有用在decltype处是个例外。</strong></p><p>如果decltype使用的表达式不是一个变量，则decltype返回表达式结果对应的类型：</p><p>如果表达式求值的结果是一个<strong>左值</strong>(参看左值与右值)，那么decltype返回的是一个引用类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>, *p = &amp;i, &amp;r = i;</span><br><span class="line"><span class="keyword">decltype</span>(r + <span class="number">0</span>) b;<span class="comment">//正确：加法的结果是int，因此b是一个int</span></span><br><span class="line"><span class="keyword">decltype</span>(*p) c;<span class="comment">//错误：c是int&amp;，必须初始化</span></span><br></pre></td></tr></table></figure><p>解释一下上面代码。因为r是一个引用，因此decltype(r)的结果是引用类型，如果想让结果是r所指的类型，可以把r作为表达式的一部分。显然这个表达式的结果是一个具体值。</p><p>而解引用操作得到的结果是一个左值，因此decltype(*p)是一个引用类型。</p><p>decltype的一个注意的点是：如果decltype所用的表达式是一个变量名加上了一层或多层括号，编译器就会将变量认为是表达式。而变量是一种可以作为赋值语句左值的特殊表达式。所以decltype得到的结果会是引用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>((i)) d;<span class="comment">//错误：d是int &amp;,必须初始化</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;变量、基本类型和类型别名&quot;&gt;&lt;a href=&quot;#变量、基本类型和类型别名&quot; class=&quot;headerlink&quot; title=&quot;变量、基本类型和类型别名&quot;&gt;&lt;/a&gt;&lt;strong&gt;变量、基本类型和类型别名&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;任何编程语
      
    
    </summary>
    
      <category term="C++Primer笔记" scheme="http://yoursite.com/categories/C-Primer%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="变量" scheme="http://yoursite.com/tags/%E5%8F%98%E9%87%8F/"/>
    
      <category term="基本类型" scheme="http://yoursite.com/tags/%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/"/>
    
      <category term="auto" scheme="http://yoursite.com/tags/auto/"/>
    
      <category term="decltype" scheme="http://yoursite.com/tags/decltype/"/>
    
      <category term="typedef" scheme="http://yoursite.com/tags/typedef/"/>
    
      <category term="using" scheme="http://yoursite.com/tags/using/"/>
    
  </entry>
  
  <entry>
    <title>GUN编译器</title>
    <link href="http://yoursite.com/2019/02/18/gun-compile/"/>
    <id>http://yoursite.com/2019/02/18/gun-compile/</id>
    <published>2019-02-18T15:11:44.000Z</published>
    <updated>2019-02-20T12:38:43.261Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GUN编译器"><a href="#GUN编译器" class="headerlink" title="GUN编译器"></a>GUN编译器</h2><p>编译器的一部分工作是检查文本错误：</p><ol><li>语法错误(syntax)：引号 分号等</li><li>类型错误(type error): 向一个int类型的变量传递了字符串字面值常量</li><li>声明错误(declaration error): c++的每个名字都要先声明才能使用。两种常见的声明错误是:对来自标准库的名字忘记使用std:: 、标识符名字拼写错误。(v1 写成v)</li></ol><h3 id="安装GUN编译器出现的错误："><a href="#安装GUN编译器出现的错误：" class="headerlink" title="安装GUN编译器出现的错误："></a>安装GUN编译器出现的错误：</h3><p><strong>“没有文件扩展‘.js’的脚本引擎。”</strong></p><p><img src="/2019/02/18/gun-compile/no-js.png" alt="no-js"></p><p>该错误是默认js打开方式被修改了。（我是安装了webstorm。-  -）</p><ol><li>打开注册表编辑器中的“HEKY_CLASSES_ROOT.js” </li><li>修改默认的文件为 <strong>JSFile</strong></li></ol><p><img src="/2019/02/18/gun-compile/register.png" alt="注册表编辑器"></p><h3 id="安装完成后的步骤："><a href="#安装完成后的步骤：" class="headerlink" title="安装完成后的步骤："></a>安装完成后的步骤：</h3><ol><li>打开MinGW Installation Manager</li><li>选择MinGW Compiler Suite之后，添加The GUN C++ Compiler的相关项</li><li>然后点击installation -&gt; apply changes 等待完成</li></ol><h3 id="环境变量配置："><a href="#环境变量配置：" class="headerlink" title="环境变量配置："></a>环境变量配置：</h3><ul><li>在PATH里面添加bin目录路径，我的是C:\MinGW\bin</li><li>重启cmd 然后输入g++ -v 如果出现gcc版本就说明配置成功</li></ul><p><img src="/2019/02/18/gun-compile/cmd-gcc.png" alt="cmd-gcc-version"></p><h3 id="GUN编译"><a href="#GUN编译" class="headerlink" title="GUN编译"></a>GUN编译</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -o _test test.cpp</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;GUN编译器&quot;&gt;&lt;a href=&quot;#GUN编译器&quot; class=&quot;headerlink&quot; title=&quot;GUN编译器&quot;&gt;&lt;/a&gt;GUN编译器&lt;/h2&gt;&lt;p&gt;编译器的一部分工作是检查文本错误：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;语法错误(syntax)：引号 分号等&lt;/li
      
    
    </summary>
    
      <category term="C++Primer笔记" scheme="http://yoursite.com/categories/C-Primer%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="gun" scheme="http://yoursite.com/tags/gun/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2018/11/25/hello-world/"/>
    <id>http://yoursite.com/2018/11/25/hello-world/</id>
    <published>2018-11-25T15:42:24.230Z</published>
    <updated>2019-01-08T17:17:49.697Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
      <category term="Testing" scheme="http://yoursite.com/categories/Testing/"/>
    
    
      <category term="Testing" scheme="http://yoursite.com/tags/Testing/"/>
    
      <category term="Another Tag" scheme="http://yoursite.com/tags/Another-Tag/"/>
    
  </entry>
  
</feed>
