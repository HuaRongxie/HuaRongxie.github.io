<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="默而识之，学而不厌，诲人不倦，何有于我哉？">
<meta property="og:type" content="website">
<meta property="og:title" content="HuaRongxie&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="HuaRongxie&#39;s Blog">
<meta property="og:description" content="默而识之，学而不厌，诲人不倦，何有于我哉？">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="HuaRongxie&#39;s Blog">
<meta name="twitter:description" content="默而识之，学而不厌，诲人不倦，何有于我哉？">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>HuaRongxie's Blog</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">HuaRongxie's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/13/zhuan-java66/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HuaRongxie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HuaRongxie's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/13/zhuan-java66/" itemprop="url">JVM内存模型、垃圾回收、类加载</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-13T13:14:01+08:00">
                2019-01-13
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/JVM/" itemprop="url" rel="index">
                    <span itemprop="name">JVM</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="JVM内存模型、垃圾回收、类加载"><a href="#JVM内存模型、垃圾回收、类加载" class="headerlink" title="JVM内存模型、垃圾回收、类加载"></a>JVM内存模型、垃圾回收、类加载</h1><h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><p>JVM 中有的区域是线程私有，有的区域是线程共享的。如程序计数器、Java虚拟机栈、本地方法栈均为线程私有；堆、方法区、直接内存均为线程共享。</p>
<p><strong>程序计数器</strong>:记录正在执行的字节码指令地址。若执行本地方法，则为 undefined。该区域是 JVM 中唯一不会发生 OutOfMemoryError 的区域。</p>
<p><strong>Java 虚拟机栈</strong>:每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用到执行完成的过程对应一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</p>
<p>这个区域可能发生两种异常:</p>
<ul>
<li>当线程请求的栈深度超过最大值，会抛出 Stack OverflowError 异常。</li>
<li>栈进行动态扩展时，无法申请足够内存，会抛出 OutOfMemoryError 异常。</li>
</ul>
<p><strong>本地方法栈</strong>:本地方法栈与 Java 虚拟机栈相似，它们之间的区别主要是本地方法栈为本地方法服务。</p>
<p><strong>堆</strong>:几乎所有的对象都在堆中分配。是垃圾回收的主要区域。现代的垃圾收集器基本都是采用分代收集算法，其主要思想是针对不同类型的对象采用不同的垃圾回收算法。可以将堆分成两块新生代和老年代。堆不需要的连续的内存，并且可以动态扩展内存。扩展失败则抛出 OutOfMemoryError 异常。虚拟机参数: -Xms :堆的初始大小; -Xmx :堆的最大值。</p>
<p>Java 对象的分配过程是编译器先通过逃逸分析，确定对象是在栈上分配还是堆上分配。(逃逸分析:是一种可以有效减少 Java 程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。通过逃逸分析，HotSpot 编译器能够分析出一个新的对象的引用的使用范围从而决定是否将这个对象分配到堆上)</p>
<p><strong>在堆中为对象分配内存主要有两种方式</strong>:</p>
<ul>
<li><p>指针碰撞法</p>
<p>假设 Java 堆中内存是完整的，已分配的内存和空闲内存分别在不同的一侧，通过一个指针作为分界点，需要分配内存时，仅仅需要把指针往空闲的一端移动与对象大小相等的距离。</p>
</li>
<li><p>空闲列表法</p>
<p>事实上，Java 堆的内存并不是完整的，已分配的内存和空闲内存相互交错， JVM 通过维护一个列表，记录可用的内存块信息，当分配操作发生时，从列表中找到一个足够大的内存块分配给对象实例，并更新列表上的记录。</p>
</li>
</ul>
<p>对象创建是一个非常频繁的行为，进行堆内存分配时还需要考虑多线程并发问题，可能出现正在给对象 A 分配内存，指针或记录还未更新，对象 B 又同时分配到原来的内存，解决这个问题有两种方案：</p>
<ol>
<li>采用 CAS 保证数据更新操作的原子性；</li>
<li>把内存分配的行为按照线程进行划分，在不同的空间中进行，每个线程在 Java 堆中预先分配一个内存块，称为本地线程分配缓冲（Thread Local Allocation Buffer, TLAB）;</li>
</ol>
<p><strong>方法区</strong>:用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。和堆一样不需要连续的内存，并且可以动态扩展，扩展失败则抛出 OutOfMemoryError 异常。对这块区域进行垃圾回收的主要目的是对常量池的回收和类的卸载，但一般很难实现。 HotSpot 虚拟机是把它当成永久代来进行垃圾回收的。但很难确定永久代的大小。因为它受很多因素影响，并且每次 FullGC 之后，永久代的大小都会改变，所以容易出现 OutOfMemoryError 异常。为了更容易管理方法区。从 JDK 1.8开始，移除永久代，并把方法区移至元空间。它位于本地内存中，而不是虚拟机内存中。</p>
<p><strong>运行时常量池</strong>:运行时常量池是方法区的一部分。 Class 文件中的常量池(编译期生成的各种字面量和符号引用)会在类加载后被放入这个区域。除了在编译期生成的常量，还允许动态生成。例如 String 类的 intern() 方法。</p>
<p><strong>直接内存</strong>:在 JDK 1.4时新增加入 NIO 类，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆内的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样可以在一些场景中提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。</p>
<h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><p><strong>标记-清除</strong></p>
<p>标记要回收的对象，然后清除。</p>
<p>不足:1.标记与清除效率不高。2.会产生大量内存碎片，可能导致无法给大对象分配内存。</p>
<p><strong>标记-整理</strong></p>
<p>让所有存活的对象移动到一端，然后清理掉端边界以外的内存。</p>
<p><strong>复制</strong></p>
<p>把内存划分为大小相等的两块，每次只使用其中一块，当这块内存使用完了就将还存活的对象复制到另外一块上，然后再把使用过的内存清理一遍。</p>
<p>不足:只使用了一半内存。</p>
<p><em>拓展</em> :现代的商业虚拟机都采用复制算法来回收新生代，但不是把新生代划分为大小相等的两块，而是分为一块较大的 Eden 区和两块较小的 Survivor 区。每次只使用 Eden 区和其中一块 Survivor 区，在回收的时候，将 Eden 区和 Survivor 区中还存活的对象一次性复制到另一块 Survivor 区中，最后清理 Eden 和那块使用过的Survivor 区。在 HotSpot 虚拟机中 Eden 和 Survivor 区域大小默认比例为8:1，内存使用率为百分之90.如果每次回收存活的对象大于10%,此时需要依赖老年代进行分配担保，也就是借用老年代的空间存储放不下的对象。</p>
<p><strong>分代算法</strong></p>
<p>现在的商用虚拟机采用分代算法算法。一般将堆分成新生代和老年代。新生代使用复制算法，老年代使用标记-清除算法或者是标记-整理算法。</p>
<h2 id="如何判断一个对象是否可回收"><a href="#如何判断一个对象是否可回收" class="headerlink" title="如何判断一个对象是否可回收"></a>如何判断一个对象是否可回收</h2><p><strong>引用计数算法</strong></p>
<p>给对象添加一个引用计数器。当对象增加一个引用时，计数器加1，引用失效时，计数器减1。引用计数为0的对象可以被回收。两个对象出现循环可用的情况下，引用计数器永不为0，导致无法对它们进行回收。正因为循环引用的存在，Java虚拟机不使用引用计数算法。</p>
<p><strong>可达性分析算法</strong></p>
<p>通过 GC Roots 作为起始点进行搜索，能够到达的对象都是存活的，不可达的对象可以被回收。</p>
<p>GC Roots:</p>
<ol>
<li>虚拟机栈中局部变量表中引用的对象</li>
<li>本地方法栈中 JNI 中引用的对象</li>
<li>方法区中静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
</ol>
<p><strong>方法区的回收</strong></p>
<p>方法区的回收主要是对常量池的回收和对类的卸载。</p>
<h2 id="类的加载机制"><a href="#类的加载机制" class="headerlink" title="类的加载机制"></a>类的加载机制</h2><p>类从加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括:加载-验证-准备-解析-初始化-使用-卸载。其中验证-准备-解析称为链接( Linking )。加载、验证、准备、初始化、卸载这五个阶段顺序是确定的，解析在某些情况下会在初始化后进行。</p>
<p><strong>加载( Loading )</strong></p>
<p>在加载阶段，虚拟机需要完成下面3件事:</p>
<ol>
<li>通过一个类的全限定名获取定义此类的二进制字节流，实现这个动作的代码就是”类加载器”，获取的途径不仅仅是 Class 文件，也可能来源网络、数据库等。</li>
<li>将这个字节流所表示的静态存储结构转化为方法区运行时数据结构。</li>
<li>在内存中生成一个代表这个类的 class 对象，作为方法区的各种数据的访问入口。</li>
</ol>
<p>加载阶段和链接阶段的部分内容是交叉进行的(如部分字节码格式验证)。加载阶段还没结束，链接阶段可能已经开始了，夹杂在加载阶段操作依然属于链接阶段，并且加载阶段和链接阶段的开始时间是仍然保持固定的先后顺序的。加载阶段可以是用户参与的阶段，开发人员可以自定义类加载器，去实现自己的类加载过程。</p>
<p><em>拓展</em>:</p>
<h6 id="JVM-是按需加载类的"><a href="#JVM-是按需加载类的" class="headerlink" title="JVM 是按需加载类的"></a>JVM 是按需加载类的</h6><p>JVM 如果加载一个jar包，只会在加载那些明确使用到的类到内存中。要查看JVM到底加载哪些类可以在启动参数上加<code>-verbose:class</code></p>
<h6 id="JDK-内建的类加载器"><a href="#JDK-内建的类加载器" class="headerlink" title="JDK 内建的类加载器"></a><strong>JDK 内建的类加载器</strong></h6><ul>
<li>启动类加载器( Bootstrap Class-Loader )，负责加载 jre/lib 下面的 jar 文件。</li>
<li>扩展类加载器( Extension or Ext Class-Loader )，负责加载 jre/lib/ext 下面的 jar 文件。</li>
<li>应用类加载器( Application or App Class-Loade r)，加载 classpath 的的内容。</li>
</ul>
<h6 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a><strong>ClassLoader</strong></h6><p>ClassLoader 主要有三个作用:加载 Class 到 JVM 中；审查每个类该由谁加载，它是一种父优先的加载机制；将 Class 字节码重新解析成 JVM 统一要求的对象格式。</p>
<p><strong>验证( Verification )</strong></p>
<p>验证的目的是为了确保 class 文件的字节流中包含的信息符合当前虚拟机的要求，且不会危害虚拟机自身的安全。验证阶段大致会完成下面4个阶段的验证动作:</p>
<ol>
<li>文件格式验证:验证字节流是否符合class文件的规范，如是否以魔数0xCAFEBABE开头。</li>
<li>元数据验证:对字节码描述的信息进行语义分析。以保证其描述的信息符合 Java 语言规范。</li>
<li>字节码验证:字节码验证将对类的方法进行校验分析，保证被校验的方法在运行时不会做出危害虚拟机的事，一个类方法体的字节码没有通过字节码验证，那一定有问题，但若一个方法通过了验证，也不能说明它一定安全。</li>
<li>符号引用验证:确保解析动作能够正确执行。</li>
</ol>
<p>验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用 -Xverifynone 参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p>
<p><strong>准备( Preparation )</strong></p>
<p>准备阶段是正式为类的静态变量分配内存并设置变量的初始值的阶段，这些变量所使用的内存都将在方法区中分配。</p>
<p>如 <code>public static int a=123;</code>准备阶段后 a 的值为 0，而不是 123，要在初始化之后才变为 123，但若被 final 修饰，<code>public static final int a=123;</code>在准备阶段后就变为了 123。</p>
<p><strong>解析( Resolution )</strong></p>
<p>解析阶段是虚拟机将常量池中的符号引用变为直接引用的过程。</p>
<p>符号引用（Symbolic Reference）：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。</p>
<p>直接引用（Direct Reference）：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机实现的内存布局相关的，如果有了直接引用，那么引用的目标必定已经在内存中存在。</p>
<p><strong>初始化(Initialization)</strong></p>
<p>类初始化是类加载过程的最后一步，前面的类加载过程，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的 Java 程序代码。</p>
<p>初始化阶段是执行类构造器<code>&lt;clinit&gt;()</code>方法的过程。<code>&lt;clinit&gt;()</code>方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块(static{}块中的语句)合并产生的。</p>
<p>虚拟机会保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程环境中被正确的加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<code>&lt;clinit&gt;()</code>方法，其他线程都需要阻塞等待，直到活动线程执行<code>&lt;clinit&gt;()</code>方法完毕。如果在一个类的<code>&lt;clinit&gt;()</code>方法中有耗时很长的操作，就可能造成多个线程阻塞，在实际应用中这种阻塞往往是隐藏的。</p>
<p>在遇到下列情况时，若没有初始化，则需要触发其初始化（加载-验证-准备自然需 要在此之前）：</p>
<ol>
<li>A.使用 new 关键字实例化对象 B.读取或设置一个类的静态字段 C.调用一个类的静态方法。</li>
<li>使用 java.lang.reflect 包的方法对类进行反射调用时，若类没有进行初始化，则需要触发其初始化</li>
<li>当初始化一个类时，若发现其父类还没有进行初始化，则要先触发其父类的初始化。</li>
<li>当虚拟机启动时，用户需要制定一个要执行的主类（有 main 方法的那个类），虚拟机会先初始化这个类。</li>
<li>当使用JDK1.7动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果 REF_getstatic, REF_putstatic, REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行初始化，则需要先出触发其初始化。</li>
</ol>
<p><strong>类的卸载</strong></p>
<p>类的卸载条件必须满足以下条件，并且满足了也不一定会卸载。</p>
<ol>
<li>该类的所有实例被回收</li>
<li>加载该类的 Class Loader 已经被回收</li>
<li>该类对应的 Class 对象没有被引用</li>
</ol>
<p>需要注意的是，JVM 所创建的三个默认类加载器 Bootstrap ClassLoader、ExtClassLoader 和 AppClassLoader 都不可能满足这些条件，因此，任何系统类(例如 java.lang.String )或者通过应用程序类加载器加载的任何应用程序类都不能在运行时释放。</p>
<p><strong>类加载机制的三个基本特征</strong></p>
<ol>
<li>双亲委派模型。但不是所有类加载器都遵守这个模型。有时候，启动类加载器所加载的类型，可能是要加载用户代码的，比如JDK内部的ServiceProvider/ServiceLoader 机制，用户可以在标准API框架上，提供自己的实现，JDK也需要提供些默认的参考实现。例如， Java中 JNDI、 JDBC、文件系统、 Cipher 等很多方面，都是利用的这种机制，这种情况就不会用双亲委派模型去加载，而是利用所谓的上下文加载器。</li>
<li>可见性，子类加载器可以访问父加载器加载的类型，但是反过来是不允许的，不然因为缺少必要的隔离，我们就没有办法利用类加载器去实现容器的逻辑。</li>
<li>单一性，由于父加载器的类型对于子加载器是可见的，所以父加载器中加载过的类型，就不会再子加载器中重复加载。但是，在类加载器”邻居”之间，同一类型仍然可以被加载多次，因为互相之间并不可见。</li>
</ol>
<h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><p>双亲委派模型，就是当类加载器试图加载某个类型的时候，除非父加载器找不到相应类型，否则尽量将这个任务代理给当前加载器的父加载器去做。使用双亲委派模型的目的是避免重复加载Java类型。</p>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/01/expression-operate/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HuaRongxie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HuaRongxie's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/01/expression-operate/" itemprop="url">表达式与运算符</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-01T19:57:07+08:00">
                2018-12-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/C-Primer笔记/" itemprop="url" rel="index">
                    <span itemprop="name">C++Primer笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="表达式与运算符-附表"><a href="#表达式与运算符-附表" class="headerlink" title="表达式与运算符(附表)"></a>表达式与运算符(附表)</h1><p>表达式由一个或多个运算对象组成，对表达式求值将得到一个结果。</p>
<p><strong>字面值</strong>和<strong>变量</strong>是最简单的表达式，其结果就是它们的值。</p>
<p>把一个运算符和一个或多个运算对象组合起来可以生成较复杂的表达式。</p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>c++定义了一元运算符和二元运算符，作用于一个运算对象的运算符是一元比如说取地址符(&amp;)和解引用符(*)。</p>
<p>作用于两个对象的是二元比如乘法运算符(*)。</p>
<p>此外还有作用于三个运算对象的三元运算符。</p>
<p>函数调用也是一种特殊的运算符，它对运算对象的数量没有限制。</p>
<h4 id="组合运算符和运算对象"><a href="#组合运算符和运算对象" class="headerlink" title="组合运算符和运算对象"></a>组合运算符和运算对象</h4><p><strong>对于含有多个运算符和运算对象的复杂表达式来说，得先理解运算符的优先级、结合律以及求值顺序</strong>。</p>
<h4 id="运算对象转换"><a href="#运算对象转换" class="headerlink" title="运算对象转换"></a>运算对象转换</h4><p>在表达时求值中，运算对象常常由一种类型转换成另一种类型。例如：</p>
<p>整数和浮点数能互相转换，而通常小整数(bool、char、short等)会被提升成较大的整数类型，主要是int。更多了解——<strong><a href="../type-conversion.md">类型转换</a></strong></p>
<h4 id="重载运算符"><a href="#重载运算符" class="headerlink" title="重载运算符"></a>重载运算符</h4><p>当运算符作用于类类型的对象时用户可以自行定义其含义。称之为重载运算符，比如IO库的&gt;&gt;和&lt;&lt;运算符以及string、vector对象和迭代器使用的运算符都是。</p>
<p>重载运算符时，其包括运算对象的类型和返回值的类型，都是由该运算符定义的；<strong>但是运算对象的个数、运算符的优先级和结合律都是无法改变的</strong>。</p>
<h4 id="求值顺序"><a href="#求值顺序" class="headerlink" title="求值顺序"></a>求值顺序</h4><p>优先级规定了运算对象的组合方式，但是没有说明运算对象按照什么顺序求值。在大多数情况下不会明确求值顺序。对于如下表达式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = f1() * f2();</span><br></pre></td></tr></table></figure>
<p>我们不知道f1()和f2()哪个先调用。</p>
<p>对于那些没有指定执行顺序的运算符来说，如果表达式指向了同一个对象，将会引发错误并产生未定义的行为。例如&lt;&lt;:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; i &lt;&lt; “ ”&lt;&lt; ++i &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>我们不知道是先++i还是先输出i再++。编译器可能先求++i的值那么结果是1 1，也可能先输出i那么结果是0 1。因为此表达式的行为不可预知，因此编译器生成什么样的代码程序都是错误的。</p>
<p><strong>但是有四种运算符明确规定了运算对象的求值顺序。 逻辑与(&amp;&amp;)、逻辑或(||)、条件(?:)、逗号(,)。</strong></p>
<h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p><img src="/2018/12/01/expression-operate/arithmetic.png" alt=""></p>
<p>按照运算符的优先级分组，一元运算符最高。上面所有运算符都满足左结合律。</p>
<p>取余：如果m和n是整数且n非0，则表达式(m/n)*n+m%n的求值结果与m相等:</p>
<p>m%(-n) 就是 m%n、 -m%n 就是-(m%n)。</p>
<h4 id="逻辑-和-关系运算符"><a href="#逻辑-和-关系运算符" class="headerlink" title="逻辑 和 关系运算符"></a>逻辑 和 关系运算符</h4><p><img src="/2018/12/01/expression-operate/logic.png" alt=""></p>
<p>逻辑与(&amp;&amp;)：当且仅当两个运算对象都为真适才为真；逻辑或(||)：只要有一个为真结果就为真。</p>
<p>逻辑与和逻辑或都是先算左边运算对象值，如果无法确定表达式结果才算右侧运算对象的值。—称为短路求值</p>
<ul>
<li>对于逻辑与(&amp;&amp;)运算符来说，当且仅当左侧运算对象为真时才对右侧对象求值</li>
<li>对于逻辑或(||)运算符来说，当且仅当左侧运算对象为假时才对右侧对象求值</li>
</ul>
<h4 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h4><p><strong>赋值运算符的左侧对象必须是一个可修改的左值(更多了解——<a href="">左值与右值</a>)。</strong></p>
<p>下面的赋值语句都是非法的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>,k=<span class="number">0</span>; 			<span class="comment">//初始化非赋值</span></span><br><span class="line"><span class="number">1024</span> = k;					<span class="comment">//错误：字面值是右值</span></span><br><span class="line">(<span class="keyword">const</span>类型)ci = k;		   <span class="comment">//错误：ci是常量不可修改的左值</span></span><br></pre></td></tr></table></figure>
<p>也允许用花括号括起来的初始值列表来赋值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">k=&#123;<span class="number">3.14</span>&#125;					<span class="comment">//错误：窄化转换</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line">vi = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;	<span class="comment">//vi现在有10个元素了</span></span><br></pre></td></tr></table></figure>
<p><strong>赋值运算满足右结合律:</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line">a = b = <span class="number">0</span>;					<span class="comment">//正确：都被赋值为0</span></span><br></pre></td></tr></table></figure>
<p>对于多重赋值运算，必须是可以由右边对象的类型转换得到：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ival, *pval;</span><br><span class="line">ival = pval = <span class="number">0</span>; 			<span class="comment">//错误：不能把指针的值赋给int</span></span><br></pre></td></tr></table></figure>
<h4 id="递增和递减运算符-–"><a href="#递增和递减运算符-–" class="headerlink" title="递增和递减运算符(++/–)"></a>递增和递减运算符(++/–)</h4><p>递增和递减运算符有两种形式：前置版本和后置版本。</p>
<p>这两种运算符必须作用于左值运算对象。</p>
<p>前置版本将运算对象加减1然后将<strong>改变后的运算对象</strong>作为求值结果(左值)，而后置版本则返回运算对象<strong>改变之前的值</strong>的副本(右值)。</p>
<p><strong><u>建议</u></strong>：使用前置版本可以避免了拷贝对象的额外开销。</p>
<p>例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span>&lt;&lt;*iter++&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>由于递增运算符高于解引用运算符，所以上述代码等于*(iter++)。先将iter的值加1但是返回的是iter原来的值。等同于：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span>&lt;&lt;*iter&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">++iter;</span><br></pre></td></tr></table></figure>
<p>如果使用的是++iter 那么是先将iter+1再参与运算。</p>
<p><strong>运算对象可按任意顺序求值：</strong></p>
<p>一般情况没影响。然而如果一条子表达式改变了某个运算对象的值，另一条子表达式又要用该值的话，那就要提防在复合表达式中错用这两个运算符。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it = s.begin();it!=s.end()&amp;&amp;!<span class="built_in">isspace</span>(*it);++it)&#123;</span><br><span class="line">	*it = <span class="built_in">toupper</span>(*it);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果将上述代码改为下面这条，则会有问题：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(it!=s.end()&amp;&amp;!<span class="built_in">isspace</span>(*it))&#123;</span><br><span class="line">	*it = <span class="built_in">toupper</span>(*it++);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这将产生未定义的行为，问题在于：赋值运算左右两端的运算对象都用到了it，并且右侧运算对象还改变了it的值，编译器可能按照任意一种思路处理该表达式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*it = <span class="built_in">toupper</span>(*it);			<span class="comment">//如果先求左侧的值</span></span><br><span class="line">*(it+<span class="number">1</span>) = <span class="built_in">toupper</span>(*it);		<span class="comment">//如果先求右侧的值</span></span><br></pre></td></tr></table></figure>
<h4 id="成员访问运算符"><a href="#成员访问运算符" class="headerlink" title="成员访问运算符"></a><strong>成员访问运算符</strong></h4><p>点运算符(.) 和 箭头运算符(-&gt;)都可以用于访问成员，其中点运算符是获取类对象的一个成员；箭头运算符和点运算符有关  :  <strong>prt-&gt;mem</strong> 等价于 <strong>(*ptr).mem</strong>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s1 = “a <span class="built_in">string</span>”, *p=&amp;s1;</span><br><span class="line"><span class="keyword">auto</span> n = s1.size();</span><br><span class="line">n = (*p).size();		<span class="comment">//运行p所指对象的size成员</span></span><br><span class="line">n = p-&gt;size();			<span class="comment">//等价于(*p).size()</span></span><br></pre></td></tr></table></figure>
<p>点运算符优先于解引用运算符，所以当*p.size()需要括号 (*p).size。</p>
<p>箭头运算符作用于一个指针类型的运算对象，结果是一个左值。</p>
<p>点运算符分情况：如果成员所属的对象是左值，那么结果是左值；反之，结果是右值。</p>
<h4 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符(?:)"></a>条件运算符(?:)</h4><p>条件运算符允许我们把简单的if-else逻辑嵌入到单个表达式中，条件运算符按照如下形式使用：</p>
<p>cond? expr1 : expr2;</p>
<p>cond是判断条件的表达式，而expr1和expr2是两个类型相同或可能转换为某个公共类型的表达式。当这两个表达式都是左值或者能转换成同一种左值类型时，运算的结果是左值；否则运算的结果是右值。</p>
<p>例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> finalgrade = (grade&lt;<span class="number">60</span>) ?<span class="string">"fail"</span> : <span class="string">"pass"</span>;</span><br></pre></td></tr></table></figure>
<p>条件运算符的优先级很低，比cout还低，所以最好加括号。</p>
<h4 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h4><p><img src="/2018/12/01/expression-operate/bit.png" alt=""></p>
<p><strong>移位运算符(&lt;&lt; 、&gt;&gt;)：</strong></p>
<p>一般来说，运算对象是小整型会被提升成大整型，左移运算符在右侧插入值为0的二进制位。右移行为依赖左侧运算对象的类型:如果对象是无符号类型，在左侧插入0；如果带符号，在左侧插入符号位的副本或值为0的二进制位。</p>
<p>移位超出的直接被舍弃。</p>
<p><strong>位与、位或、异或：</strong></p>
<p>位与运算符(&amp;): 两个对象都为1则结果为1，否则为0</p>
<p>位或运算符(|): 其中有一个对象为1则结果就为1，否则为0</p>
<p>异或运算符(^): 有且只有一个对象为1，这结果为1，否则为0</p>
<p>例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">quizl |= <span class="number">1U</span>L &lt;&lt; <span class="number">27</span>；				<span class="comment">//第27个人的值赋为1</span></span><br><span class="line">quizl &amp;= `(<span class="number">1U</span>L&lt;&lt;<span class="number">27</span>);			<span class="comment">//除了27别的值都不变</span></span><br><span class="line"><span class="keyword">bool</span> status = quizl&amp;(<span class="number">1U</span>L&lt;&lt;<span class="number">27</span>);  <span class="comment">//然后返回的值是0或者1，那么可以用bool接收</span></span><br></pre></td></tr></table></figure>
<h4 id="sizeof运算符"><a href="#sizeof运算符" class="headerlink" title="sizeof运算符"></a>sizeof运算符</h4><p>sizeof运算符返回一条表达式或一个类型名字所占的字节数。满足右结合律，返回size_t类型的常量表达式。运算符的运算对象有两种表达形式：</p>
<p>sizeof (type)</p>
<p>sizeof expr            </p>
<p>第二种形式中，返回表达式结果 类型的大小。sizeof并不实际计算其运算对象的值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Sales_data data, *p;</span><br><span class="line"><span class="keyword">sizeof</span>(Sales_data);		<span class="comment">//Sales_data类型的对象所占空间的大小</span></span><br><span class="line"><span class="keyword">sizeof</span> data;			<span class="comment">//同上</span></span><br><span class="line"><span class="keyword">sizeof</span> p;				<span class="comment">//指针所占空间的大小</span></span><br><span class="line"><span class="keyword">sizeof</span> *p;				<span class="comment">//p所指类型空间大小，也就是Sales_data</span></span><br></pre></td></tr></table></figure>
<p>sizeof运算符的结果部分的依赖于其作用的类型：</p>
<ul>
<li>对char或者类型为char的表达式执行sizeof运算，结果得1</li>
<li>对引用类型执行sizeof运算得到被引用对象所占空间的大小</li>
<li>对指针执行sizeof运算得到指针指向的对象所占空间的大小</li>
<li>对解引用指针执行sizeof运算得到指针指向的对象所占空间大小，指针不需有效</li>
<li>对数组执行sizeof运算得到整个数组所占空间的大小。</li>
<li>对string或vector执行sizeof运算只会得到固定类型的大小，不会计算元素所占空间大小。</li>
</ul>
<h4 id="逗号运算符"><a href="#逗号运算符" class="headerlink" title="逗号运算符"></a>逗号运算符</h4><p>含有两个运算对象，求值左侧表达式然后将结果丢掉，真正结果是右侧表达式，如果值是左值那结果也是左值。</p>
<h3 id="运算符优先级表"><a href="#运算符优先级表" class="headerlink" title="运算符优先级表"></a>运算符优先级表</h3><table>
<thead>
<tr>
<th>结合律</th>
<th>运算符</th>
<th>功能</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>左</td>
<td>::</td>
<td>全局作用域</td>
<td>::name</td>
</tr>
<tr>
<td>左</td>
<td>::</td>
<td>类作用域</td>
<td>class::name</td>
</tr>
<tr>
<td>左</td>
<td>::</td>
<td>命名空间作用域</td>
<td>namespace::name</td>
</tr>
<tr>
<td>左</td>
<td>.</td>
<td>成员选择</td>
<td>object.member</td>
</tr>
<tr>
<td>左</td>
<td>-&gt;</td>
<td>成员选择</td>
<td>point-&gt;member</td>
</tr>
<tr>
<td>左</td>
<td>[]</td>
<td>下标</td>
<td>expr[expr]</td>
</tr>
<tr>
<td>左</td>
<td>()</td>
<td>函数调用</td>
<td>name(expr_list)</td>
</tr>
<tr>
<td>左</td>
<td>()</td>
<td>类型构造</td>
<td>type(expr_list)</td>
</tr>
<tr>
<td>右</td>
<td>++</td>
<td>后置递增运算</td>
<td>lvalue++</td>
</tr>
<tr>
<td>右</td>
<td>–</td>
<td>后置递减运算</td>
<td>lvalue–</td>
</tr>
<tr>
<td>右</td>
<td>typeid</td>
<td>类型ID</td>
<td>typeid(type)</td>
</tr>
<tr>
<td>右</td>
<td>typeid</td>
<td>运行时类型ID</td>
<td>typeid(expr)</td>
</tr>
<tr>
<td>右</td>
<td>explicit cast</td>
<td>类型转换</td>
<td>cast_name&lt; type&gt;(expr)</td>
</tr>
<tr>
<td>右</td>
<td>++</td>
<td>前置递增运算</td>
<td>++lvalue</td>
</tr>
<tr>
<td>右</td>
<td>–</td>
<td>前置递减运算</td>
<td>–lvalue</td>
</tr>
<tr>
<td>右</td>
<td>~</td>
<td>位求反</td>
<td>~expr</td>
</tr>
<tr>
<td>右</td>
<td>!</td>
<td>逻辑非</td>
<td>!expr</td>
</tr>
<tr>
<td>右</td>
<td>-</td>
<td>一元负号</td>
<td>-expr</td>
</tr>
<tr>
<td>右</td>
<td>+</td>
<td>一元正号</td>
<td>+expr</td>
</tr>
<tr>
<td>右</td>
<td>*</td>
<td>解引用</td>
<td>*expr</td>
</tr>
<tr>
<td>右</td>
<td>&amp;</td>
<td>取地址</td>
<td>&amp;expr</td>
</tr>
<tr>
<td>右</td>
<td>()</td>
<td>类型转换</td>
<td>(type)expr</td>
</tr>
<tr>
<td>右</td>
<td>sizeof</td>
<td>对象大小</td>
<td>sizeof expr</td>
</tr>
<tr>
<td>右</td>
<td>sizeof</td>
<td>类型的大小</td>
<td>sizeof（type)</td>
</tr>
<tr>
<td>右</td>
<td>Sizeof…</td>
<td>参数包的大小</td>
<td>sizeof…(name)</td>
</tr>
<tr>
<td>右</td>
<td>new</td>
<td>创建对象</td>
<td>new type</td>
</tr>
<tr>
<td>右</td>
<td>new[]</td>
<td>创建数组</td>
<td>new type[size]</td>
</tr>
<tr>
<td>右</td>
<td>delete</td>
<td>释放对象</td>
<td>delete expr</td>
</tr>
<tr>
<td>右</td>
<td>delete[]</td>
<td>释放数组</td>
<td>delete[] expr</td>
</tr>
<tr>
<td>右</td>
<td>noexcept</td>
<td>能否抛出异常</td>
<td>noexcept (expr)</td>
</tr>
<tr>
<td>左</td>
<td>-&gt;*</td>
<td>指向成员选择的指针</td>
<td>ptr-&gt;*ptr_to_member</td>
</tr>
<tr>
<td>左</td>
<td>.*</td>
<td>指向成员选择的指针</td>
<td>obj.*ptr_to_member</td>
</tr>
<tr>
<td>左</td>
<td>*</td>
<td>乘法</td>
<td>expr*expr</td>
</tr>
<tr>
<td>左</td>
<td>/</td>
<td>除法</td>
<td>expr/expr</td>
</tr>
<tr>
<td>左</td>
<td>%</td>
<td>取模(取余)</td>
<td>expr%expr</td>
</tr>
<tr>
<td>左</td>
<td>+</td>
<td>加法</td>
<td>expr+expr</td>
</tr>
<tr>
<td>左</td>
<td>-</td>
<td>减法</td>
<td>expr-expr</td>
</tr>
<tr>
<td>左</td>
<td>&lt;&lt;</td>
<td>向左移位</td>
<td>expr&lt;&lt;expr</td>
</tr>
<tr>
<td>左</td>
<td>&gt;&gt;</td>
<td>向右移位</td>
<td>expr&gt;&gt;expr</td>
</tr>
<tr>
<td>左</td>
<td>&lt;</td>
<td>小于</td>
<td>expr&lt;expr</td>
</tr>
<tr>
<td>左</td>
<td>&lt;=</td>
<td>小于等于</td>
<td>expr&lt;=expr</td>
</tr>
<tr>
<td>左</td>
<td>&gt;</td>
<td>大于</td>
<td>expr&gt;expr</td>
</tr>
<tr>
<td>左</td>
<td>&gt;=</td>
<td>大于等于</td>
<td>expr&gt;=expr</td>
</tr>
<tr>
<td>左</td>
<td>==</td>
<td>相等</td>
<td>expr==expr</td>
</tr>
<tr>
<td>左</td>
<td>!=</td>
<td>不相等</td>
<td>expr!=expr</td>
</tr>
<tr>
<td>左</td>
<td>&amp;</td>
<td>位与</td>
<td>expr&amp;expr</td>
</tr>
<tr>
<td>左</td>
<td>^</td>
<td>位异或</td>
<td>expr^expr</td>
</tr>
<tr>
<td>左</td>
<td>丨</td>
<td>位或</td>
<td>expr丨expr</td>
</tr>
<tr>
<td>左</td>
<td>&amp;&amp;</td>
<td>逻辑与</td>
<td>expr&amp;&amp;expr</td>
</tr>
<tr>
<td>左</td>
<td>丨丨</td>
<td>逻辑或</td>
<td>expr丨丨expr</td>
</tr>
<tr>
<td>左</td>
<td>?:</td>
<td>条件</td>
<td>expr ? expr : expr</td>
</tr>
<tr>
<td>右</td>
<td>=</td>
<td>赋值</td>
<td>lvalue=expr</td>
</tr>
<tr>
<td>右</td>
<td>*=, /=, %=</td>
<td>复合赋值</td>
<td>lvalue += expr等</td>
</tr>
<tr>
<td>右</td>
<td>+=, -=</td>
<td></td>
<td></td>
</tr>
<tr>
<td>右</td>
<td>&lt;&lt;=, &gt;&gt;=</td>
<td></td>
<td></td>
</tr>
<tr>
<td>右</td>
<td>&amp;=,丨 =, ^=</td>
<td></td>
<td></td>
</tr>
<tr>
<td>右</td>
<td>throw</td>
<td>抛出异常</td>
<td>throw</td>
</tr>
<tr>
<td>右</td>
<td>,</td>
<td>逗号</td>
<td>expr , expr</td>
</tr>
</tbody>
</table>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/23/array/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HuaRongxie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HuaRongxie's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/23/array/" itemprop="url">数组</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-23T21:15:12+08:00">
                2018-11-23
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/C-Primer笔记/" itemprop="url" rel="index">
                    <span itemprop="name">C++Primer笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>数组是一种类似于标准库类型vector的数据结构。</p>
<ul>
<li>与vector相似的是，数组也是存放类型相同的对象的容器，这些对象本身没有名字，需要通过位置访问。</li>
<li>与vector不同的是，数组的大小确定不变，不能随意向数组中增加元素。<ul>
<li>改变长度只能创建一个新数组，我们也不能像vector一样用size函数直接获取长度，char数组用strlen 而别的数组只能sizeof(array)/sizeof(array[0])</li>
</ul>
</li>
</ul>
<h3 id="定义和初始化数组"><a href="#定义和初始化数组" class="headerlink" title="定义和初始化数组"></a>定义和初始化数组</h3><h4 id="数组的定义："><a href="#数组的定义：" class="headerlink" title="数组的定义："></a>数组的定义：</h4><p>数组是一种复合类型。数组的声明形如a[d]，其中a是数组名字，d是数组的维度。</p>
<ol>
<li>维度就是个数，因此必须大于0。</li>
<li>数组中元素的个数属于数组类型的一部分，编译时是已知的。因此维度必须是一个常量表达式。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> cnt = <span class="number">42</span>;			<span class="comment">//不是常量表达式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">unsigned</span> sz = <span class="number">42</span>; <span class="comment">//是常量表达式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>];				<span class="comment">//含有10个整数的数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *parr[sz];				<span class="comment">//含有42个整型指针的数组</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> bad[cnt];			<span class="comment">//错误，cnt不是常量表达式</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> strs[get_size()];	<span class="comment">//当get_size()是constexpr时正确</span></span><br></pre></td></tr></table></figure>
<p>和内置类型的变量一样，如果在函数内部定义了某种内置类型的数组，那么默认初始化会令数组含有未定义的值。</p>
<p>必须指定数组的类型(不允许用auto由初始化列表推断)。</p>
<p>和vector一样，数组的元素应为对象，因此不存在引用的数组。</p>
<h4 id="显式初始化数组元素："><a href="#显式初始化数组元素：" class="headerlink" title="显式初始化数组元素："></a>显式初始化数组元素：</h4><p><strong>可以对数组的元素进行列表初始化，此时忽略数组维度</strong>。</p>
<ul>
<li>如果在声明时没有指明维度，编译器会根据初始值的数量计算出来</li>
<li>如果定义了维度并且比列表大，那么剩下的元素会被初始化为默认值。</li>
<li>如果定义了维度并且比列表小，那么编译错误</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> sz = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ial[sz] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;		 <span class="comment">//含有3个元素，012</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a2[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;			 <span class="comment">//同上</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a3[<span class="number">5</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;		 <span class="comment">//等价于a3[] = &#123;0,1,2,0,0&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> a4[<span class="number">3</span>] = &#123;“hi”, “bye”&#125;;<span class="comment">//等价于a4[] = &#123;“hi”, “bye”, “”&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a5[<span class="number">2</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;		 <span class="comment">//错误，维度比初始值小</span></span><br></pre></td></tr></table></figure>
<h4 id="字符数组-的特殊性："><a href="#字符数组-的特殊性：" class="headerlink" title="字符数组 的特殊性："></a>字符数组 的特殊性：</h4><p>字符数组可以用<strong>字符串字面值</strong>进行初始化。当使用这种方式一定要注意字符串字面值<strong>结尾处还有一个空字符</strong>，要预留一个空间。如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a1[] = &#123;‘c’, ‘+’, ‘+’&#125;;	<span class="comment">//列表初始化，没有空字符</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> a2[]=&#123;‘c’, ‘+’, ‘+’, ‘\<span class="number">0</span>’&#125;;<span class="comment">//显式的空字符</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> a3[] = “c++”;				<span class="comment">//自动添加表示字符串结束的空字符</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> a4[<span class="number">6</span>] = “Daniel”;	<span class="comment">//错误，没有空间放空字符</span></span><br></pre></td></tr></table></figure>
<h4 id="数组不允许拷贝和赋值："><a href="#数组不允许拷贝和赋值：" class="headerlink" title="数组不允许拷贝和赋值："></a>数组不允许拷贝和赋值：</h4><p>不能将数组的内容拷贝给其他数组作为其初始值，也不能用数组为其他数组赋值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a1[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a2[] = a1; 			<span class="comment">//错误：不允许使用一个数组初始化另一个数组</span></span><br><span class="line"></span><br><span class="line">a2 = a ;				<span class="comment">//错误，不能把一个数组直接赋值给另一个数组</span></span><br></pre></td></tr></table></figure>
<p>(某些<strong>编译器扩展</strong>可以支持数组赋值，不过最好避免)</p>
<h4 id="复杂的数组声明-数组-指针、引用等-："><a href="#复杂的数组声明-数组-指针、引用等-：" class="headerlink" title="复杂的数组声明(数组+指针、引用等)："></a>复杂的数组声明(数组+指针、引用等)：</h4><p>数组可以存放对象，就可以定义指针对象。而数组本身是一个对象，那么可以有引用和指针，如下(可从内向外再从右向左阅读)：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *ptrs[<span class="number">10</span>];				<span class="comment">//ptrs是有10个整型指针的数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> &amp;refs[<span class="number">10</span>]; 				<span class="comment">//错误，数组不能放引用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> (*Parray)[<span class="number">10</span>] = &amp;arr	<span class="comment">//Parray是一个指针，指向一个整型数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> (&amp;arrRef)[<span class="number">10</span>] = arr;	<span class="comment">//arrRef是一个引用，引用一个整型数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *(&amp;arrRef)[<span class="number">10</span>] = ptrs;	<span class="comment">//arrRef 是一个引用，指向一个含有10个int类型指针的数组</span></span><br></pre></td></tr></table></figure>
<h3 id="访问数组元素"><a href="#访问数组元素" class="headerlink" title="访问数组元素"></a>访问数组元素</h3><p>数组的访问跟vector基本类似。也可以用范围for语句或下标运算符来访问。</p>
<p>在使用下标的时候通常将其定义为<strong>size_t</strong>类型。</p>
<p>size_t 是一种机器相关的无符号类型。它的定义在<strong>cstddef</strong>头文件中。</p>
<h3 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a>指针和数组</h3><p>通常情况下，使用取地址符来获取指向某个对象的指针。数组的元素也是对象，因此对数组的元素使用取地址符就能得到指向该元素的指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> nums[] = &#123;“one”, “two”, “three”&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> *p = &amp;nums[<span class="number">0</span>]; 		<span class="comment">//p指向nums的第一个元素</span></span><br></pre></td></tr></table></figure>
<p><strong>然而数组有个特性：在很多用到数组名字的地方，编译器会自动的将其转换为一个指向数组首元素的指针。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> *p2 = nums;			<span class="comment">//等价于p2 = &amp;nums[0]</span></span><br></pre></td></tr></table></figure>
<h4 id="对数组使用auto和decltype的不同点："><a href="#对数组使用auto和decltype的不同点：" class="headerlink" title="对数组使用auto和decltype的不同点："></a>对数组使用auto和decltype的不同点：</h4><p>由上可知，在一些情况下数组的操作实际上是指针的操作：</p>
<ol>
<li>当使用一个数组作为一个auto变量的初始值时，推断出的类型是指针而非数组</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ia2</span><span class="params">(ia)</span></span>;			<span class="comment">//ia2是一个整型指针，指向ia的第一个元素，同 ia2(&amp;ia[0])</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>然而当使用decltype(ia)返回的是一个数组。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(ia) ia3 = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">ia3[<span class="number">4</span>] = i;			<span class="comment">//给ia3的第三个元素赋值</span></span><br></pre></td></tr></table></figure>
<h4 id="指针也是迭代器："><a href="#指针也是迭代器：" class="headerlink" title="指针也是迭代器："></a>指针也是迭代器：</h4><p>迭代器可用的运算 指针都能用。也可以使用指针遍历数组。</p>
<p>同时c++给了两个标准库函数取尾后指针，<strong>begin 和 end</strong>，定义在iterator头文件中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *pbeg = begin(arr);		<span class="comment">//指向arr的首元素</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *pend = end(arr);		<span class="comment">//指向尾后元素</span></span><br></pre></td></tr></table></figure>
<h4 id="解引用与指针运算交互："><a href="#解引用与指针运算交互：" class="headerlink" title="解引用与指针运算交互："></a>解引用与指针运算交互：</h4><p>迭代器有的运算操作指针都有，两个指针相减的结果类型是ptrdiff_t， 与size_t一样。</p>
<p>如果两个指针分别指向不相关的对象，则不能比较它们。</p>
<p>空指针也可以相减，值为0。</p>
<p><strong>下标和指针：</strong></p>
<p>当对数组使用下标运算符时，编译器会自动转换成指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[] = &#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> last = *(ia + <span class="number">4</span>);		<span class="comment">//正确：等同于 ia[4]</span></span><br></pre></td></tr></table></figure>
<p>从上可知，对数组下标运算其实是对指向数组元素的指针执行下标运算：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = &amp;ia[<span class="number">2</span>];	<span class="comment">//p指向索引为2的元素</span></span><br><span class="line"><span class="keyword">int</span> j = p[<span class="number">1</span>]; 		<span class="comment">//p[1]等价于*(p + 1),就是ia[3]表示的那个元素</span></span><br><span class="line"><span class="keyword">int</span> k = p[<span class="number">-2</span>]; 		<span class="comment">//p[-2]等价于*(p - 2),就是ia[0]表示的那个元素</span></span><br></pre></td></tr></table></figure>
<p>数组的下标运算与 标准库类型限定使用的下标运算有所不同。<strong>标准库类型的下标必须是无符号类型，而内置的下标则无此要求。</strong></p>
<h3 id="C风格字符串"><a href="#C风格字符串" class="headerlink" title="C风格字符串"></a>C风格字符串</h3><p>尽管c++支持c风格字符串，但还是不要使用它们。因为用起来不太方便，而且极易引发程序漏洞。</p>
<p><strong>字符串字面值</strong>是一种通用结构的实例，即是由c继承而来的c风格字符串。</p>
<p>c通常把字符串存放在字符数组中并以空字符结束(‘\0’)。一般用指针来操作这些字符串。</p>
<h4 id="C标准库string函数"><a href="#C标准库string函数" class="headerlink" title="C标准库string函数"></a>C标准库string函数</h4><p>下表函数定义在cstring头文件中。</p>
<table>
<thead>
<tr>
<th>strlen(p)</th>
<th style="text-align:left">返回p的长度，空字符不计算在内</th>
</tr>
</thead>
<tbody>
<tr>
<td>strcmp(p1, p2)</td>
<td style="text-align:left">比较p1和p2的相等性。如果p1==p2，返回0；如果p1&gt;p2,返回一个正值；返回0；如果p1&lt;p2,返回一个负值</td>
</tr>
<tr>
<td>strcat(p1, p2)</td>
<td style="text-align:left">和炮</td>
</tr>
<tr>
<td>strcpy(p1, p2)</td>
<td style="text-align:left">将p2拷贝给p1， 返回p1</td>
</tr>
</tbody>
</table>
<p><strong>上表所列的函数不负责验证字符串参数。</strong></p>
<p>传入此类函数的指针必须指向以空字符作为结束的数组：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ca[] = &#123;‘c’, ‘+’, ‘+’&#125;;		<span class="comment">//不以空字符结束</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; <span class="built_in">strlen</span>(ca) &lt;&lt;<span class="built_in">endl</span>;			<span class="comment">//严重错误：ca没有以空字符结束</span></span><br></pre></td></tr></table></figure>
<p>上面代码不是以空字符结束，它可能沿着ca在内存中的位置不断向前直到遇到空字符。</p>
<h4 id="比较字符串："><a href="#比较字符串：" class="headerlink" title="比较字符串："></a>比较字符串：</h4><p>比较两个c风格字符串的方法与标准库string对象的方法大相径庭。</p>
<p>标准库string对象的比较用的是普通关系运算符和相等性运算符，如 &lt;、==；</p>
<p>而c风格字符串，实际比较的是两个指针而不是字符串本身：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> ca1[] = “A <span class="built_in">string</span> example”;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> ca2[] = “A different <span class="built_in">string</span>”;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( ca1 &lt; ca2)&#123;&#125;;		<span class="comment">//未定义的：试图比较两个无关地址，相当于比较const char*</span></span><br></pre></td></tr></table></figure>
<p>所以上述ca1和ca2相比其实是两个const char*的值，这两个指针指向的不是一个对象，因此得到未定义的结果。</p>
<p>如果想要比较两个c风格字符串则需要调用strcmp函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(ca1, ca2) &lt; <span class="number">0</span>) <span class="comment">//相等返回0，前面大返回正值，否则负值。</span></span><br></pre></td></tr></table></figure>
<h4 id="c风格字符串的连接拷贝："><a href="#c风格字符串的连接拷贝：" class="headerlink" title="c风格字符串的连接拷贝："></a>c风格字符串的连接拷贝：</h4><p>使用strcpy 和 ctrcat函数来进行连接、拷贝，如果使用则需要提供一个用于存放结果的数组，必须足够大容纳下结果字符串以及<strong>末尾的空字符</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strcpy</span>(largeStr, ca1);		<span class="comment">//cal拷贝给largeStr</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">strcat</span>(largeStr, “ ”);</span><br><span class="line"></span><br><span class="line"><span class="built_in">strcat</span>(largeStr, ca2);		<span class="comment">//ca2连接到largeStr后面</span></span><br></pre></td></tr></table></figure>
<p>ps：在vs中使用c风格字符串的函数时，会报错。因为c库的函数内部进行参数检验，所以vs提出警告要求使用vs改写的函数。报错：</p>
<table>
<thead>
<tr>
<th>错误</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>C4996</td>
<td>‘strcpy’: This function or variable may be unsafe. Consider using strcpy_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.</td>
</tr>
</tbody>
</table>
<p>需要改写成：</p>
<table>
<thead>
<tr>
<th>老接口</th>
<th>新接口</th>
</tr>
</thead>
<tbody>
<tr>
<td>mkdir</td>
<td>_mkdir</td>
</tr>
<tr>
<td>fopen</td>
<td>fopen_s</td>
</tr>
<tr>
<td>strcmp</td>
<td>strcmp_s</td>
</tr>
<tr>
<td>strcpy</td>
<td>strcpy_s</td>
</tr>
<tr>
<td>strcat</td>
<td>strcat_s</td>
</tr>
</tbody>
</table>
<h3 id="与旧代码的接口"><a href="#与旧代码的接口" class="headerlink" title="与旧代码的接口"></a>与旧代码的接口</h3><p>很多c++程序在标准库出现之前就已经写成了，因此c++专门提供了一组功能来衔接c++程序与数组/c风格字符串的代码。</p>
<h4 id="混用string对象和C风格字符串："><a href="#混用string对象和C风格字符串：" class="headerlink" title="混用string对象和C风格字符串："></a>混用string对象和C风格字符串：</h4><p><strong>任何出现字符串字面值的地方都可以用空字符结束的字符数组来替代：</strong></p>
<ol>
<li>允许使用以空字符结束的字符数组来初始化string对象或赋值。</li>
<li>在string对象的加法运算中允许使用空字符结束的字符数组作为其中一个运算对象(不能两个都是)；</li>
</ol>
<p>反之不行，不能用string对象来代替c风格字符串。为了完成这个功能，string专门提供了一个函数<strong>c_str</strong>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *str = s;				 <span class="comment">//错误，不能用string对象初始化char*</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *str = s.c_str(); <span class="comment">//正确</span></span><br></pre></td></tr></table></figure>
<p>c_str()函数返回值是一个以空字符结束的字符数组的指针。指针类型是const char*。但如果后续操作改变了s的值那么之前返回的数组失去作用。</p>
<p>所以：如果执行完c_str()函数后想一直使用，那么最好拷贝一份。</p>
<h4 id="使用数组初始化vector对象："><a href="#使用数组初始化vector对象：" class="headerlink" title="使用数组初始化vector对象："></a>使用数组初始化vector对象：</h4><p>用数组初始化vector对象只需指明拷贝区域的<strong>首元素地址和尾后地址</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> int_arr[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec(begin(arr), end(arr));</span><br></pre></td></tr></table></figure>
<p>同样可以只拷贝数组的一部分：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; subVec(arr + <span class="number">1</span>, arr + <span class="number">4</span>);	<span class="comment">//拷贝arr[1],arr[2],arr[3]</span></span><br></pre></td></tr></table></figure>
<h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><p>多维数组就是数组的数组。</p>
<h4 id="多维数组的初始化："><a href="#多维数组的初始化：" class="headerlink" title="多维数组的初始化："></a>多维数组的初始化：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">4</span>] = &#123;		<span class="comment">//3个元素，每个元素都是大小为4 的数组</span></span><br><span class="line">	&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">	&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;,</span><br><span class="line">	&#123;<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中内嵌花括号不是必需的，例如下面：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>&#125;;		<span class="comment">//功能同上</span></span><br></pre></td></tr></table></figure>
<p>类似一维数组，初始化时并非所有元素都包含在初始化列表内：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//显式的初始化每行的首元素</span></span><br><span class="line"><span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">0</span>&#125;,&#123;<span class="number">4</span>&#125;,&#123;<span class="number">8</span>&#125;&#125;;</span><br><span class="line"><span class="comment">//显式初始化第一行</span></span><br><span class="line"><span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="多维数组下标引用："><a href="#多维数组下标引用：" class="headerlink" title="多维数组下标引用："></a>多维数组下标引用：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (&amp;row)[<span class="number">4</span>] = ia[<span class="number">1</span>]; 		<span class="comment">//row是含有4个元素的数组的引用，引用ia数组的第二个四元数组上</span></span><br></pre></td></tr></table></figure>
<h4 id="使用范围for处理多维数组："><a href="#使用范围for处理多维数组：" class="headerlink" title="使用范围for处理多维数组："></a>使用范围for处理多维数组：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">使用范围<span class="keyword">for</span>处理多维数组：</span><br><span class="line"><span class="keyword">size_t</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;row : ia)&#123;		<span class="comment">//对于外层数组的每一个元素，row是int[4]类型的引用</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> &amp;col : row)&#123;	<span class="comment">//对于内层数组的每一个元素</span></span><br><span class="line">		col = cnt;</span><br><span class="line">		++cnt;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上<strong>row必需声明为引用类型</strong>，这是因为如果不用引用类型那么auto会变为指向数组内首元素的指针，那么遍历指针就不合法了。所以除了最内层的循环，其他的循环变量都为引用类型。</p>
<h4 id="指针和多维数组："><a href="#指针和多维数组：" class="headerlink" title="指针和多维数组："></a>指针和多维数组：</h4><p>定义指向多维数组的指针，就是指向指针的指针。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> (*p)[<span class="number">4</span>] = ia;		<span class="comment">//指向ia第一个四元素数组的指针</span></span><br><span class="line">p = &amp;ia[<span class="number">2</span>];				<span class="comment">//指向ia的第三个元素</span></span><br></pre></td></tr></table></figure>
<p>通过使用auto或者decltype可以避免在数组面前加一个指针类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> p = begin(ia);p!=end(ia);++p)&#123; 		<span class="comment">//p指向ia的内层数组</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> q = begin(*p);q!=end(*p);++q)&#123;		<span class="comment">//q指向*p的数组的首元素</span></span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;*q&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="类型别名简化多维数组的指针："><a href="#类型别名简化多维数组的指针：" class="headerlink" title="类型别名简化多维数组的指针："></a>类型别名简化多维数组的指针：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> int_array = <span class="keyword">int</span>[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> int_array[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(int_array p = begin(ia);p!=end(ia);++p)&#123; 		<span class="comment">//p指向ia的内层数组</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> q = begin(*p);q!=end(*p);++q)&#123;		<span class="comment">//q指向*p的数组的首元素</span></span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;*q&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/23/iterator/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HuaRongxie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HuaRongxie's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/23/iterator/" itemprop="url">迭代器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-23T21:14:57+08:00">
                2018-11-23
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/C-Primer笔记/" itemprop="url" rel="index">
                    <span itemprop="name">C++Primer笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><h3 id="迭代器的介绍"><a href="#迭代器的介绍" class="headerlink" title="迭代器的介绍"></a>迭代器的介绍</h3><p>迭代器是一种比下标运算符访问元素更通用的机制。</p>
<p>所有标准库容器都可以使用<strong>迭代器</strong>，但是只有少数几种才同时支持<strong>下标运算符</strong>。</p>
<h4 id="迭代器类型："><a href="#迭代器类型：" class="headerlink" title="迭代器类型："></a>迭代器类型：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it1;		<span class="comment">//能读写vector&lt;int&gt;的元素</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span>::iterator it2;			<span class="comment">//能读写string对象中的元素</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator it3;<span class="comment">//只能读vector&lt;int&gt;的元素</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span>::const_iterator it4;		<span class="comment">//只能读string对象中的元素</span></span><br></pre></td></tr></table></figure>
<p>跟常量指针差不多，如果vector对象或string对象不是常量，那么既可以用iterator也可以用const_iterator。</p>
<h4 id="迭代器成员begin和end："><a href="#迭代器成员begin和end：" class="headerlink" title="迭代器成员begin和end："></a>迭代器成员begin和end：</h4><p>有迭代器的类型同时拥有返回迭代器的成员。比如这些类型都拥有名为begin和end的成员，其中begin成员负责返回指向第一个元素的迭代器。如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> a = v.begin(), b =v.end();</span><br></pre></td></tr></table></figure>
<p>迭代器b被称作尾后迭代器。它指向的是尾元素的下一个位置，本不存在的位置。</p>
<p><strong>如果容器为空，那么begin和end返回的是同一个尾后迭代器。</strong></p>
<p>如果容器对象的类型是常量，那么begin 和end返回的类型是const_iterator。如果不是则返回iterator：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cv;</span><br><span class="line"><span class="keyword">auto</span> it1 = v.begin();	<span class="comment">//it1的类型是vector&lt;int&gt;::iterator</span></span><br><span class="line"><span class="keyword">auto</span> it2 = cv.begin();	<span class="comment">//it2的类型是vector&lt;int&gt;::const_iterator</span></span><br></pre></td></tr></table></figure>
<p>如果对象只需读操作，那么我们可以使用两个新函数:</p>
<p><strong>cbegin</strong>和<strong>cend</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> it3 = v.cbegin(); 		<span class="comment">//it3的类型是const_iterator</span></span><br></pre></td></tr></table></figure>
<h3 id="迭代器运算符-操作-："><a href="#迭代器运算符-操作-：" class="headerlink" title="迭代器运算符(操作)："></a>迭代器运算符(操作)：</h3><table>
<thead>
<tr>
<th>*iter</th>
<th>返回迭代器iter所指元素的引用</th>
</tr>
</thead>
<tbody>
<tr>
<td>iter-&gt;mem</td>
<td>解引用iter并获取该元素的名为mem的成员，等价于(*iter).mem</td>
</tr>
<tr>
<td>++iter</td>
<td>令iter指示容器中的下一个元素</td>
</tr>
<tr>
<td>–iter</td>
<td>令iter指示容器中的上一个元素</td>
</tr>
<tr>
<td>iter1 == iter2、iter1 != iter2</td>
<td>判断两个迭代器是否相等(不相等)，如果两个迭代器指示的是同一个元素或者它们是同一个容器的尾后迭代器，则相等。</td>
</tr>
</tbody>
</table>
<h4 id="解引用和成员访问："><a href="#解引用和成员访问：" class="headerlink" title="解引用和成员访问："></a>解引用和成员访问：</h4><p>和指针一样，迭代器也能被解引用来获取所指示的元素，当然前提是迭代器合法并且确实指示某一个元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">"some string"</span>)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (s.begin() != s.end())&#123;	<span class="comment">//确保s非空</span></span><br><span class="line">    <span class="keyword">auto</span> it = s.begin();	<span class="comment">//it指示s的第一个字符</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; *it &lt;&lt;<span class="built_in">endl</span>;		<span class="comment">//解引用获取元素输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解引用可以获得迭代器所指的对象，如果对象的类型刚好是类，就能进一步<strong>访问它的成员</strong>。例如vector<string>想要检查元素是否为空就可以用：</string></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(*it).empty();	<span class="comment">//此处的括号必须要加</span></span><br></pre></td></tr></table></figure>
<p>然后为了简化上述操作，c++定义了 箭头运算符(-&gt;)。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">it-&gt;empty();		<span class="comment">//和上面意思相同</span></span><br></pre></td></tr></table></figure>
<h4 id="迭代器的移动："><a href="#迭代器的移动：" class="headerlink" title="迭代器的移动："></a>迭代器的移动：</h4><p>将迭代器从一个元素移到另外一个元素：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s= “some thing”;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it = s.begin();it!=s.end &amp;&amp; !<span class="built_in">isspace</span>(*it);++it)&#123;</span><br><span class="line">	*it = <span class="built_in">toupper</span>(*it); <span class="comment">//将当前字符大写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>在for里不用&lt;而用!= 的原因是因为迭代器使然</strong>，之前说只有string和vector等一些标准库类型有下标运算符，并非全部如此。与之类似，所有标准库容器的迭代器都定义了==和!=，但是大多数没有&lt;运算符。</p>
<h4 id="某些对vector对象操作会使迭代器失效："><a href="#某些对vector对象操作会使迭代器失效：" class="headerlink" title="某些对vector对象操作会使迭代器失效："></a>某些对vector对象操作会使迭代器失效：</h4><p>vector是动态增长，但也有副作用。已知的一个限制是不能在范围for循环中向vector对象添加元素。另外一个是任何一种可能改变vector容量的操作，比如push_back。都会使迭代器失效。9.3.6</p>
<h4 id="迭代器运算："><a href="#迭代器运算：" class="headerlink" title="迭代器运算："></a><strong>迭代器运算：</strong></h4><p>迭代器的算术运算(必须是两个迭代器指向同一个容器中的元素)：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">iter += n;	<span class="comment">//向前移动了n个元素</span></span><br><span class="line"></span><br><span class="line">iter -= n;		<span class="comment">//向后移动了n个元素</span></span><br><span class="line"></span><br><span class="line">iter1 - iter2; <span class="comment">//两个迭代器相减就是他们的距离</span></span><br><span class="line"></span><br><span class="line">&lt;、&gt;、&lt;=、&gt;=;<span class="comment">//两个迭代器的前后位置比较</span></span><br></pre></td></tr></table></figure>
<p>只要两个迭代器指向的是同一个容器或者尾元素，就能相减。距离是指右侧迭代器向前移动多少位就能追上左侧迭代器，其类型名是<strong>difference_type</strong>的带符号整型数。</p>
<p>ps：还需拓展</p>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/10/zhuan-java8/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HuaRongxie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HuaRongxie's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/10/zhuan-java8/" itemprop="url">MySQL中索引的类型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-10T13:18:35+08:00">
                2018-11-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/MySQL/" itemprop="url" rel="index">
                    <span itemprop="name">MySQL</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="MySQL中索引的类型"><a href="#MySQL中索引的类型" class="headerlink" title="MySQL中索引的类型"></a>MySQL中索引的类型</h1><p>索引(在MySQL中也被叫做”键(key)”)是存储引擎用于快速找到记录的一种数据结构。这是索引的基本功能。</p>
<h3 id="索引的类型"><a href="#索引的类型" class="headerlink" title="索引的类型"></a>索引的类型</h3><p>索引很很多种类型，可以为不同的场景提供更好的性能。在MySQL中，索引是在存储引擎层实现而不是服务器层。所以不同的存储引擎索引的工作方式不同，也不是所有存储引擎都支持所有类型的索引。即使多个存储引擎支持同一种类型的索引，其底层的实现也可能不同。</p>
<h4 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B-Tree索引"></a>B-Tree索引</h4><p>B-Tree索引使用B-Tree数据结构来存储数据。大多数MySQL引擎都支持这种索引，Archive引擎是例外。</p>
<p>使用术语”B-Tree”，是因为MySQL在CREATE TABLE和其他语句中也使用该关键字。不过，底层不同的存储引擎也可能使用不同的存储结构。例如，NDB集群存储引擎内部使用了T-Tree结构存储这种索引，即使其名字是BTree;InnoDB则使用的是B+Tree。</p>
<p>B-Tree通常意味着所有的值都是按照顺序存储的，并且每个叶子节点到根的距离都是相等的。</p>
<p>B-Tree索引能够加快访问数据的速度，因为存储引擎不再需要进行全表扫描来获取数据，而是从索引的根节点开始搜索，根节点的槽中存放了指向子节点的指针，存储引擎根据这些指针向下层查找。通过比较节点页的值和要查找的值可以找到合适的指针进入下一层子节点。这些指针实际上定义了子节点页中值的上限和下限。最终存储引擎要么找到对应的值，要么该记录不存在。</p>
<p>叶子节点比较特别，因为它们的指针指向的是被索引的数据，而不是其他节点页。</p>
<p>B-Tree对索引列是顺序组织存储的，索引很适合查找范围数据。例如”找出A到C开头的名字”<br><strong>索引的维护</strong><br>B+树为了维护索引的有序性，在插入新值的时候需要做必要的维护。如果插入新的行，需要挪动后面的数据，空出位置，而更糟糕的情况是，如果插入所在数据页已经满了，根据B+树算法，这时候需要申请一个新的数据页，然后挪动部分数据过去。这个过程称为页分裂。这种情况下，性能自然会受到影响，除了性能外，页分裂操作还影响数据页的利用率。原本放在一个页的数据，现在分到两个页中，整体空间利用率降低大约50%。在相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并。合并的过程，可以认为是分裂过程的逆过程。<br><strong>可以使用B-Tree索引的查询类型</strong></p>
<ol>
<li><strong>全值匹配</strong></li>
</ol>
<p>全值匹配是指和索引中的所有列进行匹配，例如前面提到的索引可查找名字Cuba Allen、出生于1960-01-01的人。</p>
<ol>
<li><strong>匹配最左前缀</strong></li>
</ol>
<p>可以只匹配某一列的值的开头部分。例如前面提到的索引可以用于查找所有以J开头的姓氏的人。这里也只使用了索引的第一列。</p>
<ol>
<li><strong>匹配范围值</strong></li>
</ol>
<p>例如前面提到的索引可以用于查找姓氏在Allen和Barrymore之间的人。这里也只使用了索引的第一列。</p>
<ol>
<li><strong>精确匹配某一列并范围匹配另外一列</strong></li>
</ol>
<p>例如前面提到的索引可以用于查找所有姓为Allen，并且名字是字母K开头的人。这里第一列姓氏last_name全匹配，第二列范围匹配。</p>
<p><strong>B-Tree索引的使用限制</strong></p>
<ol>
<li><strong>如果不是按照索引的最左列开始查找，则无法使用索引</strong>。例如前面提到的索引无法查找名字为yuanzhi的人，也无法查找某个特定生日的人，也无法查找姓氏以某个字母结尾的人。因为这些都不是最左数据列。</li>
<li><strong>不能跳过索引中的列</strong>。例如前面提到的索引无法查找last_name为Smith并且某个日期出生的人。如果不指定first_name这一列，则MySQL只能使用索引的第一列。</li>
<li><strong>如果查询中有个某个列的范围查询，则其右边所有列都无法使用索引优化查找</strong>。例如查询WHERE last_name=’Smith’ AND first_name LIKE ‘J%’ AND dob = ‘1976-12-23’,这里只能使用索引的前两列，因为LIKE是一个范围条件。</li>
</ol>
<p>索引列的顺序很重要，这些限制都和索引列的顺序有关。在优化性能的时候，可能需要使用相同的列但顺序不同的索引来满足不同类型的查询需求。</p>
<h3 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h3><p>哈希索引(hash index)基于哈希表实现，只有精确匹配索引所有列的查询才有效。对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码(hash code)，哈希码是一个较小的值，并且不同键值的行计算出来的哈希码也不一样。哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。</p>
<p>在MySQL中，只有Memory引擎显式支持哈希索引。这也是Memory引擎表的默认索引类型，Memory引擎同时也支持B-Tree索引。值得一提的是，Memory引擎是支持非唯一哈希索引的，如果多个列的哈希值相同，索引会以链表的方式存放多个记录指针到同一个哈希条目中。</p>
<p>例如<code>SELECT last_name FROM test WHERE first_name = &#39;Peter&#39;;</code>MySQL先计算‘Peter’的哈希值，并使用该值寻找对应的记录指针。然后根据哈希值，找到指向数据行的指针，最后一步是判断数据行的值是否为‘Peter’，以确保就是要查找的行。</p>
<p>因为哈希索引只需要存储哈希值，索引结构十分紧凑，这也让哈希索引查找的速度非常快。然而，哈希索引也有他的限制:</p>
<ol>
<li>哈希索引只包含哈希值和行指针，不存储字段值，所以不能使用索引中的值来避免读取行。</li>
<li>哈希索引数据不是按照索引值顺序存储的，所以无法用于排序。</li>
<li>哈希索引也不支持索引列的匹配查找。因为哈希索引使用索引列的全部内容来计算哈希值。</li>
<li>当出现哈希冲突的时候(不同的索引列值却有相同的哈希值)，存储引擎必须遍历链表中所有的行指针，逐行进行比较，直到找到所有符合条件的行。哈希冲突很多的话，索引维护操作的代价也会很高。例如从表中删除一行时，存储引擎需要遍历对应哈希值的链表的每一行，找到并删除对应行 的引用，冲突越多，代价越大。</li>
</ol>
<p>InnoDB引擎有一个特殊的功能叫做“自适应哈希索引”。当InnoDB注意到某些索引值被使用得非常频繁时，它会在内存中基于B-Tree索引之上再创建一个哈希索引，这样让B-Tree索引也具有哈希索引的一些优点，比如快速哈希查找。这是一个完全自动的，内部行为，用户无法控制或者配置，不过有必要，完全可以关闭该功能。</p>
<p>创建自定义哈希索引。让不支持哈希索引的存储引擎可以模拟和InnoDB一样创建哈希索引。</p>
<h4 id="空间数据索引-R-Tree"><a href="#空间数据索引-R-Tree" class="headerlink" title="空间数据索引(R-Tree)"></a>空间数据索引(R-Tree)</h4><p>MyISAM表支持空间索引，可以用作地理数据存储。和B-Tree索引不同，空间数据索引无须前缀查询。可以从所有纬度来索引数据。查询时，可以有效地使用任意纬度来组合查询。必须使用MySQL的GIS相关函数如MBRCONTAINS()等来维护数据。MySQL的GIS支持并不完善，所以大部分人都不会使用这个特性。</p>
<h4 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h4><p>全文索引是一种特殊类型的索引，它查找的是文本中的关键词，而不是直接比较索引中的值。全文搜索和其他几类索引的匹配方式完全不一样。全文索引更类似搜索引擎做的事情，而不是简单的WHERE条件匹配。</p>
<p>在相同的列上同时创建全文索引和基于值的B-Tree索引不会有冲突，全文索引适用于MATCH AGAINST操作，而不是普通的WHERE条件操作。</p>
<h3 id="索引的优点"><a href="#索引的优点" class="headerlink" title="索引的优点"></a>索引的优点</h3><p>最常见的B-Tree索引，按照顺序存储数据，所以MySQL可以用来做ORDER BY 和GROUP BY操作。因为数据是有序的，所以B-Tree会将相关的列值存储在一起。最后，因为所以中存储了实际的列值，所以有些查询可以只使用索引就能够完成全部查询。总结三个优点:</p>
<ol>
<li>索引大大减少了服务器需要扫描的数据量。</li>
<li>索引可以帮助服务器避免排序和临时表。</li>
<li>索引可以将随机I/O变为顺序I/O。</li>
</ol>
<h3 id="主键索引与非主键索引的区别"><a href="#主键索引与非主键索引的区别" class="headerlink" title="主键索引与非主键索引的区别"></a>主键索引与非主键索引的区别</h3><p>主键索引的叶子节点存放的是整行数据，在InnoDB里，主键索引也被称为聚簇索引。<br>非主键索引的叶子节点存放的是主键的值。在InnoDB里，非主键索引也被称为二级索引。</p>
<ul>
<li>如果语句是SELECT * FROM T WHRER 主键 = 1,即主键查询方式，则只需要搜索主键这棵B+树；</li>
<li>如果语句是SELECT * FROM T WHRER 非主键 = 1，则需要先搜索这个非主键索引树，得到主键Id，再到主键索引树搜索一次。这个过程称为回表。</li>
</ul>
<p>也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，应该尽量使用主键查询。并且主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。</p>
<p>聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。具体的细节依赖于实现方式，InnoDB的聚簇索引实际上在同一个结构中保存了B-Tree索引和数据行。当表有聚簇索引时，它的数据行实际上是存放在索引的叶子页中的。术语”聚簇”表示数据行和相邻的键值紧凑地存储在一起(实际上也不都成立)。因为无法同时吧数据行存放在两个不同的地方，所以一个表只能由一个聚簇索引。因为存储引擎负责实现索引，因此不是所有的存储引擎都支持聚簇索引。</p>
<p>聚簇索引的优点:</p>
<ul>
<li>可以把相关数据保存在一起。例如在实现电子邮箱时，可以根据用户ID来聚集数据，这样只需要从磁盘中读取少数的数据页就能获取某个用户的全部邮件。如果没有使用聚簇索引，则没封邮件都可能导致一次磁盘I/O。</li>
<li>数据访问更快。聚簇索引将索引和数据保存在同一个B-Tree中，因此从聚簇索引中获取数据通常比在非聚簇索引中查找要快。</li>
<li>使用覆盖索引扫描的查询可以直接使用叶节点中的主键值。</li>
</ul>
<p>聚簇索引的缺点:</p>
<ul>
<li><p>聚簇数据最大限度地提高了I/O密集型应用的性能，但如果数据全部都放在内存中，则访问的顺序就没有那么重要了，聚簇索引也没什么优势了。</p>
</li>
<li><p>插入速度严重依赖于插入顺序。安卓主键的顺序插入是加载数据到InnoDB表中速度最快的方式。但如果不是按照主键顺序加载数据，那么在加载完成之后最后使用OPTIMIZE TABLE命令重新组织一下表。</p>
</li>
<li><p>更新聚簇索引列的代价很高，因为会强制InnoDB将每个被更新的行移到新的位置。</p>
</li>
<li><p>基于聚簇索引的表在插入新行，或者主键被更新导致需要移动行的时候，可能面临“页分裂(page split)”的问题。当行的主键值要求必须将这一行插入到某个已满的页中时，存储引擎会将该页分裂成两个页面来容纳该行，这就是一次页分裂操作。页分裂会导致表占用更多的磁盘空间。</p>
</li>
<li><p>聚簇索引可能导致全表扫描变慢，尤其是行比较稀疏，或者由于页分裂导致数据存储不连续。</p>
</li>
<li><p>二级索引(非聚簇索引)可能比想象的要更大，因为在二级索引的叶子节点包含了引用行的主键列。</p>
</li>
<li><p>二级索引(非聚簇索引)访问需要两次索引查找。(二级索引叶子节点保存的不是指向行的物理位置的指针，而是行的主键值。这意味着通过二级索引查找行，存储引擎需要找到二级索引的叶子节点获得对应的主键值，然后根据这个值去聚簇索引中查找到对应的行。对于InnoDB，自适应哈希索引能够减少这样的重复工作)</p>
<h3 id="覆盖索引、联合索引、索引下推"><a href="#覆盖索引、联合索引、索引下推" class="headerlink" title="覆盖索引、联合索引、索引下推"></a>覆盖索引、联合索引、索引下推</h3><p>覆盖索引</p>
<p>:当索引已经覆盖了我们的查询需求时，称为覆盖索引。</p>
<p>由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。</p>
<p>联合索引</p>
<p>:两个或者两个以上列的索引称为联合索引，又称复合索引。</p>
<p>根据创建联合索引的顺序，以最左原则进行where检索。在建立联合索引的时候，如何安排索引内的字段顺序，主要看索引的复用能力，因为支持最左前缀，所以当已经有了(a,b)这个联合索引之后，一般就不需要单独在a上建立索引了。因此，第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往是需要优先考虑的。但是当查询条件里只有b的语句，是无法使用(a,b)这个联合索引的，这个时候你不得不维护另外一个索引，也就是说你需要同时维护(a,b)、(b)这两个索引。这个时候，需要考虑的原则就是空间了，如果a的字段比b的字段大，那就建议创建一个(a,b)的联合索引和一个(b)的单字段索引。</p>
<p>索引下推</p>
<p>:</p>
<p>例如SQL语句:SELECT * FROM T WHERE name LIKE ‘丁%’ AND age = 10;有联合索引(name,age)。</p>
<p>那么此时只能使用name字段。当然还要判断其他条件是否满足。</p>
<p>在MySQL5.6之前，只能从找到name满足条件的，然后一个一个回表。到主键索引中找出数据行，再对比字段值。</p>
<p>再MySQL引入的索引下推优化(index condition pushdown),可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，</p>
<p>减少回表次数</p>
<p>。</p>
</li>
</ul>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/07/zhuan-java9/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HuaRongxie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HuaRongxie's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/07/zhuan-java9/" itemprop="url">MySQL数据库事务、隔离级别、多版本并发控制(MVCC)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-07T13:18:57+08:00">
                2018-11-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/MySQL/" itemprop="url" rel="index">
                    <span itemprop="name">MySQL</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="MySQL数据库事务、隔离级别以及多版本并发控制-MVCC"><a href="#MySQL数据库事务、隔离级别以及多版本并发控制-MVCC" class="headerlink" title="MySQL数据库事务、隔离级别以及多版本并发控制(MVCC)"></a>MySQL数据库事务、隔离级别以及多版本并发控制(MVCC)</h1><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>事务就是一组原子性的SQL查询。也就是说，事务内的语句，要么全部执行成功，要么全部执行失败。</p>
<h3 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h3><p><strong>原子性(atomicity)</strong></p>
<p>一个事务必须被视为一个不可分割的最小单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作，这就是事务的原子性。</p>
<p><strong>一致性(consistency)</strong></p>
<p>数据库总是从一个一致性的状态转换到另外一个一致性的状态。一致性确保了事务只要没有最终提交，就不会把事务中所作的修改保存到数据库中。</p>
<p><strong>隔离性(isolation)</strong></p>
<p>通常来说(因为要考虑隔离级别，所以说是通常情况)，一个事务所作的修改在最终提交之前，对其他事务是不可见的。</p>
<p><strong>持久性(durability)</strong></p>
<p>一旦事务提交，其所作的修改就会永久保存到数据库中。此时即使系统奔溃，修改的数据也不会丢失。持久性是个模糊的概念，因为持久性也分很多级别。有些持久性策略能够提供非常强的安全保障，而有些则未必。而且不可能做到百分之百的持久性保证的策略。</p>
<h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><p>隔离性其实比想象的要复杂。在SQL标准中定义了四种隔离级别，每一种级别规定了一个事务中所作的修改，哪些在事务间是可见的，哪些是不可见的。较低级别的隔离通常可以执行更高的并发，系统的开销也更低。</p>
<p><strong>READ UNCOMMITTED(读未提交)</strong></p>
<p>在READ UNCOMMITTED级别，事务中的修改即使是没有提交，对其他事务也是可见的。事务可以读取到未提交的数据，这被称为脏读(Dirty Read)。从性能来说，READ UNCOMMITTED不会比其他级别好太多，但缺乏其他级别的很多优势，所以实际应用很少。</p>
<p><strong>READ COMMITTED(读提交)</strong></p>
<p>大多数数据库的默认隔离级别都是READ COMMITTED(但MySQL不是)。READ COMMITTED满足隔离性的简单定义:一个事务开始时，只能看见已经提交的事务所作的修改。换句话说，一个事务从开始直到提交之前，所作的任何修改对其他事务都是不可见的。这个级别有时候会产生不可重复读(nonrepeatable read)，因为执行两次执行同样的查询，可能会得到不一样的结果。</p>
<p><strong>REPEATABLE READ(可重复读)</strong></p>
<p>REPEATABLE READ解决了脏读，和不可重复读的问题。但是无法解决幻读(Phantom Read)的问题。幻读是指当某个事务在读取某个范围内的记录时，另外一个事务又在范围内插入新的记录，当之前的事务再次读取该范围的记录，会产生幻行(Phantom Row)。InnoDB和XtraDB存储引擎通过多版本并发控制(MVCC)解决了幻读的问题。(可重复读是MySQL的默认事务隔离级别)。</p>
<p><strong>SERIALIZABLE(可串行化)</strong></p>
<p>SERIALIZABLE是最高隔离级别。它通过强制事务串行执行，避免幻读问题。简单来说，SERIALIZABLE会在读取的每一行上都加锁，所以可能导致大量的超时和锁争用的问题。实际应用很少使用该隔离级别，只有在非常需要确保数据一致性而且可以接受没有并发的情况下，才考虑采用该级别。</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读可能性</th>
<th>不可重复读可能性</th>
<th>幻读可能性</th>
<th>加锁读</th>
</tr>
</thead>
<tbody>
<tr>
<td>READ UNCOMMITTED</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>READ COMMITTED</td>
<td>No</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>REPEATABLE READ</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>SERIALIZABLE</td>
<td>No</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
</tr>
</tbody>
</table>
<h3 id="多版本并发控制-MVCC"><a href="#多版本并发控制-MVCC" class="headerlink" title="多版本并发控制(MVCC)"></a>多版本并发控制(MVCC)</h3><p>MySQL的大多数事务型存储引擎实现的都不是简单的行级锁。基于提升并发性能的考虑，它们一般都同时实现了多版本并发控制(MVCC)。不仅是MySQL，包括Oracle、PostgreSQL等其他数据库系统也实现了MVCC，但是实现机制不尽相同，因为MVCC没有一个统一的实现标准。</p>
<p>可以认为MVCC是行级锁的一个变种，但是它在多数情况下都避免了加锁操作，因此开销更低。虽然实现机制有所不同，但大都实现了非阻塞的读操作，写操作也只锁定必要的行。</p>
<p>MVCC的实现，是通过保存数据在某个时间点的快照来实现的。也就是说，不管执行多长时间，每个事物看到的数据都是一致的。根据事务开始时间的不同，每个事物对同一张表，同一时刻看到的数据可能是不一样的。</p>
<p>InnoDB的MVCC，是通过在每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存行的过期时间或者删除时间。存储的并不是实际的时间值，而是系统版本号(system version number)。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。</p>
<p><strong>MVCC在REPEATABLE READ隔离级别下的操作</strong></p>
<p><strong>SELECT</strong></p>
<p>InnoDB会根据以下两个条件检查每行记录:</p>
<p>a.InnDB只查找版本早于当前事务版本的数据行(也就是，行的系统版本号小于或者等于事务的系统版本号)，这样可以确保事务读取的行，要么是在事务开始前已经存在，要么是事务自身插入或者修改过的。</p>
<p>b.行的删除版本要么未定义，要么大于当前事务版本号。这可以确保事务读取到的行，在事务开始之前未被删除。</p>
<p>只有符合上述两个条件的记录，才能返回作为查询的结果。</p>
<p><strong>INSERT</strong></p>
<p>InnoDB为新插入的每一行保存当前系统版本号作为行版本号。</p>
<p><strong>DELETE</strong></p>
<p>InnoDB为删除的每一行保存当前系统版本号作为行删除标识。</p>
<p><strong>UPDATE</strong></p>
<p>InnoDB先插入一行新记录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行的删除标识。</p>
<p>保存这样两个系统版本号，使大多数读操作都可以不用加锁。这样设计使得读操作很简单，性能很好，并且也能保证只会读到符合标准的行。不足之处是每行记录都是需要额外的存储空间，需要做更多的行检查工作以及一些额外的维护工作。</p>
<p>MVCC只在REPEATABLE READ和READ COMMITTED两个隔离级别下工作。其他两个隔离级别都和MVCC不兼容。因为READ UNCOMMITTED总是读到最新的数据行，而不是符合当前事务版本的数据行。SERIALIZABLE则会对所有读取的行都加锁。</p>
<h3 id="InnoDB中幻读的解决到底是依赖Next-Key-Locks还是MVCC"><a href="#InnoDB中幻读的解决到底是依赖Next-Key-Locks还是MVCC" class="headerlink" title="InnoDB中幻读的解决到底是依赖Next-Key Locks还是MVCC?"></a>InnoDB中幻读的解决到底是依赖Next-Key Locks还是MVCC?</h3><p>首先读分为:快照读、当前读。</p>
<ul>
<li><p>快照读。例: SELECT * FROM table WHERE …;</p>
</li>
<li><p>当前读。当前读都是先读后写,只能读当前的值特殊的读操作。比如更新，插入，删除操作，属于当前读，需要加锁。</p>
<p>SELECT <em>FROM table WHERE ? lock in share mode;SELECT</em> from FROM table WHERE ? for update;<br>INSERT INTO table values (…);<br>UPDATE table SET ? WHERE ?;</p>
</li>
</ul>
<p>结论:</p>
<ul>
<li>对于快照读来讲，幻读的解决依赖于MVCC，使用 MVCC 读取的是快照中的数据，这样可以减少加锁所带来的开销。</li>
<li>对于当前读，读取的是最新的数据，需要加锁，依赖Next-Key Locks。</li>
</ul>
<p><em>拓展</em>:</p>
<p>Next-key Locks:是InnoDB存储引擎的一种锁实现。</p>
<p>Record Locks:锁定一个记录上的索引，而不是记录本身。</p>
<p>Gap Locks:锁定索引之间的间隙，但是不包含索引本身。</p>
<p>Next-key Locks:是上述两者的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。</p>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/05/function/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HuaRongxie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HuaRongxie's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/05/function/" itemprop="url">函数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-05T19:50:16+08:00">
                2018-11-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/C-Primer笔记/" itemprop="url" rel="index">
                    <span itemprop="name">C++Primer笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="函数基础"><a href="#函数基础" class="headerlink" title="函数基础"></a>函数基础</h2><p>函数的定义包括： 返回类型、函数名、形参列表、函数体。</p>
<p>通过调用运算符()来执行函数。</p>
<h4 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h4><p>函数的调用完成两项工作：</p>
<ol>
<li>用实参初始化函数对应的形参</li>
<li>将控制权转移给被调用函数。此时，主调函数的执行被暂时中断，被调函数开始执行。</li>
</ol>
<p>当遇到一条return语句时函数结束执行过程。return语句也完成两项工作：</p>
<ol>
<li>返回return语句中的值(有的话)</li>
<li>将控制权从被调函数转移回主调函数。继续完成主调函数剩余部分。</li>
</ol>
<h4 id="形参和实参"><a href="#形参和实参" class="headerlink" title="形参和实参"></a>形参和实参</h4><p>实参是形参的初始值。第一个实参初始化第一个形参，第二个实参初始化第二个形参，以此类推。</p>
<p>尽管实参与形参存在对应关系，但是没有规定实参的求值顺序。编译器能任意可行的顺序对实参求值。</p>
<p>实参类型必须与对应的形参匹配，且数量必须相等。两个形参的名字不能相同。    </p>
<h4 id="函数的形参列表"><a href="#函数的形参列表" class="headerlink" title="函数的形参列表"></a>函数的形参列表</h4><p>函数的形参列表可以为空，但是不能省略。要想定义一个不带形参的函数，最常用的办法是书写一个空的形参列表。为了与C语言兼容，也可以使用关键字void表示函数没有形参：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span>		<span class="comment">//隐式的定义空形参列表</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">void</span>)</span>	<span class="comment">//显示的定义空形参列表</span></span></span><br></pre></td></tr></table></figure>
<h4 id="函数返回类型"><a href="#函数返回类型" class="headerlink" title="函数返回类型"></a>函数返回类型</h4><p>大多数类型都能用作函数的返回类型。一种特殊的返回类型是void，它表示函数不返回任何值。</p>
<p>一种特殊的返回值是void：不返回任何值。</p>
<p>函数的返回类型不能是数组或者函数类型。可以是指针或者引用。</p>
<h3 id="局部对象"><a href="#局部对象" class="headerlink" title="局部对象"></a>局部对象</h3><p>在c++中，名字有作用域；对象有生命周期。</p>
<ul>
<li>名字的作用域是程序文本的一部分，名字在其中可见</li>
<li>对象的生命周期是程序执行过程中该对象存在的一段时间</li>
</ul>
<p>函数体是一个语句块。块构成一个新的作用域，我们可以再其中定义变量。形参和函数体内部定义的变量统称为局部变量。它们对函数而言是局部的，仅在函数的作用域内可见，同时局部变量还会隐藏在外层作用域中同名的其他所有声明中。</p>
<h4 id="自动对象"><a href="#自动对象" class="headerlink" title="自动对象"></a>自动对象</h4><p>对于普通局部变量对应的对象来说，当函数的控制路径经过变量定义语句时创建对象，到达定义所在的块末尾时销毁它。我们把只存在于块执行期间的对象称为自动对象。</p>
<p><strong>对于局部变量来说，如果没有初始化的值那就会执行默认初始化，意味着默认初始化内置变量将产生未定义的值。</strong></p>
<h4 id="局部静态对象"><a href="#局部静态对象" class="headerlink" title="局部静态对象"></a>局部静态对象</h4><p>某些时候，有必要令局部变量的生命周期贯穿函数调用及之后的时间。可以将局部变量定义成static类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">size_t</span> ctr = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p><strong>局部静态对象</strong>在程序第一次执行经过对象定义语句时初始化，并且直到程序终止才被销毁，期间就算函数结束执行也不会对它有影响。</p>
<p>内置类型局部静态变量默认初始化为0。</p>
<h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><p>类似于变量，函数只能定义一次，但是可以声明多次。</p>
<p>函数的声明与定义类似，只是声明无须函数体，用一个分号替代即可。</p>
<p>函数的三要素(<strong>返回类型、函数名、形参类型</strong>)描述了函数的接口，说明了调用该函数所需的信息。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator beg,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator end)</span></span>;</span><br></pre></td></tr></table></figure>
<p>函数声明也被称为函数原型。</p>
<p>函数通常在头文件中进行函数声明而在源文件中定义。</p>
<h3 id="分离式编译"><a href="#分离式编译" class="headerlink" title="分离式编译"></a>分离式编译</h3><p>随着程序越来越复杂，我们希望把程序的各个部分分别存储在不同文件中。</p>
<p>分离式编译(separate compilation)允许我们可以根据逻辑关系把程序分离成不同的文件中，每个文件独立编译。</p>
<h4 id="编译和链接"><a href="#编译和链接" class="headerlink" title="编译和链接"></a>编译和链接</h4><p>比如fact函数定义在一个fact.cc的文件中，它的声明在Chapter6.h的头文件中，在名为factMain.cc的文件中创建main函数调用fact函数。要生成可执行文件必须要告诉编译器需要用到的文件。</p>
<p>接下来编译器把对象文件(.obj(windows)或.o(unix))链接在一起形成可执行文件。</p>
<h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p>如前所述，每次调用函数都会重新创建它的形参，并用传入的实参对形参进行初始化。</p>
<p><strong>形参初始化的机理与变量初始化一样。</strong></p>
<ul>
<li>当形参是引用类型时，我们说它对应的实参被<strong>引用传递</strong>或者函数被传引用调用。它将绑定到对应实参上</li>
<li>当实参的值被拷贝给形参时，形参和实参是相互独立的两个对象。我们说这样的实参被<strong>值传递</strong>或者函数被传值调用</li>
</ul>
<h4 id="指针形参"><a href="#指针形参" class="headerlink" title="指针形参"></a>指针形参</h4><p>和其他非引用类型一样。执行指针拷贝操作时，拷贝的是指针的值。拷贝之后两个指针是不同的指针，但是指向的是同一个对象。因为指针使我们可以间接访问它所指的对象，所以通过指针可以修改它所指对象的值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wrap</span><span class="params">(<span class="keyword">int</span> *p)</span></span>;</span><br><span class="line">wrap(&amp;a);			<span class="comment">//调用</span></span><br></pre></td></tr></table></figure>
<p><strong>建议</strong>用引用类型的形参代替指针类型。</p>
<h4 id="传引用参数"><a href="#传引用参数" class="headerlink" title="传引用参数"></a>传引用参数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wrap</span><span class="params">(<span class="keyword">int</span> &amp;r)</span></span>;</span><br><span class="line"></span><br><span class="line">wrap(a);</span><br></pre></td></tr></table></figure>
<p>使用引用从而避免拷贝。</p>
<p>可以使用引用参数获得额外的信息：定义一个引用的形参用来获取值</p>
<h4 id="const形参和实参"><a href="#const形参和实参" class="headerlink" title="const形参和实参"></a><strong>const形参和实参</strong></h4><p>和其他初始化一样，当用实参初始化形参时会忽略顶层const(作用于对象本身)。当形参有const时，传给他常量或者非常量都是可以的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fcn</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> i)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fcn</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;&#125;			<span class="comment">//错误：重复定义了fcn(int)</span></span><br></pre></td></tr></table></figure>
<p>因为上面两个方法传入的参数可以一样，所以是重复定义了。</p>
<h4 id="指针或引用形参与const"><a href="#指针或引用形参与const" class="headerlink" title="指针或引用形参与const"></a>指针或引用形参与const</h4><p>形参的初始化方式和变量是一样的。我们可以使用非常量初始化一个底层const对象，但是反过来不行：</p>
<p>也就是，形参参数是int <em>,那么实参不能是const int </em>;</p>
<p>如果形参参数是int &amp;那么实参不能是const int &amp;。</p>
<h4 id="数组形参"><a href="#数组形参" class="headerlink" title="数组形参"></a><strong>数组形参</strong></h4><p>数组的两个特殊性质会影响函数的使用：</p>
<ol>
<li>数组不能被拷贝（所以不能使用值传递）</li>
<li>使用数组时通常被转换成指针</li>
</ol>
<p>尽管不能以值传递的方式传递数组，但是我们可以把形参写成类似数组的形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>[<span class="number">10</span>])</span></span>;</span><br></pre></td></tr></table></figure>
<p>以上三个函数是等价的：每个函数的唯一形参都是const int *。定义的第一个维度会被忽略。</p>
<p><strong>因为不知道长度，所以需要管理形参：</strong></p>
<p>管理形参的三个方法：</p>
<ol>
<li>使用标记指定数组长度：使用c风格字符串，在字符数组中跟一个空字符，那么运行到空字符就停止</li>
<li>使用标准库规范：传递数组首指针和尾后指针。begin()、end()</li>
<li>显示传递一个表示数组大小的形参</li>
</ol>
<p><strong>数组形参和const</strong></p>
<p>当函数不需要执行写操作的时候定义为const的指针</p>
<p><strong>数组引用形参</strong></p>
<p>可以将引用形参绑定到数组上：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> (&amp;arr)[<span class="number">10</span>])</span></span>;</span><br></pre></td></tr></table></figure>
<p>括号不可少，这表明arr是具有10个整数的数组引用。这样在函数体内就能放心的使用数组，只要不超过维度。但是这样增加了局限性，这个函数只能作用于大小为10的数组。16.1.1介绍传递任意大小的数组。</p>
<h4 id="传递多维数组"><a href="#传递多维数组" class="headerlink" title="传递多维数组"></a>传递多维数组</h4><p>传递的就是指向一个数组的指针，数组第二维(以及后面所有的维度)的大小都是数组类型的一部分，不能省略：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> (*matrix)[<span class="number">10</span>], <span class="keyword">int</span> rowSize)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>同样可以用数组的语法定义函数，此时依然会忽略第一个维度：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等价定义</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> matrix[][<span class="number">10</span>, <span class="keyword">int</span> rowSize])</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="main：处理命令行选项"><a href="#main：处理命令行选项" class="headerlink" title="main：处理命令行选项"></a><strong>main：处理命令行选项</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br></pre></td></tr></table></figure>
<p>第二个参数是指向c风格字符串的指针的数组。第一个参数是数组内的数量。</p>
<p>比如可执行文件名：prog</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prog -d -o ofile data0</span><br></pre></td></tr></table></figure>
<p>那么数组argv就是：</p>
<p>argv[0] = “prog”;         //第0位是执行文件的名字</p>
<p>argv[1] = “-d”            //接下来就是命令行输入的字符串了</p>
<p>…</p>
<p>在vs中设置main()选项：</p>
<ol>
<li>右键项目-&gt;属性-&gt;调试</li>
<li>在命令参数里面写需要写的参数，用空格分开</li>
</ol>
<p><img src="/2018/11/05/function/main.png" alt=""></p>
<p>用cmd命令行则是：</p>
<p><img src="/2018/11/05/function/cmd.png" alt=""></p>
<h4 id="可变形参——initializer-list形参"><a href="#可变形参——initializer-list形参" class="headerlink" title="可变形参——initializer_list形参"></a>可变形参——initializer_list形参</h4><p>这是一个标准库类型，如果传入的参数数量是不定的但是类型都相同，那么可以用这个模板类型。</p>
<p><img src="/2018/11/05/function/initializer-list.png" alt="img"></p>
<p>像vector一样：</p>
<p>initializer_list<string> ls;</string></p>
<p><strong>initializer_list类型</strong>的元素都是常量，因此在用for循环时候不能设为普通引用，编译会报错。（？除非是类类型或者容器类型(比如string)才能将设为引用）。</p>
<h3 id="返回类型和return"><a href="#返回类型和return" class="headerlink" title="返回类型和return"></a>返回类型和return</h3><p>return语句终止当前正在执行的函数并将控制权返回到调用该函数的地方。</p>
<p>return语句有两种形式：</p>
<ol>
<li>return;</li>
<li>return expression</li>
</ol>
<h4 id="无返回值函数"><a href="#无返回值函数" class="headerlink" title="无返回值函数"></a>无返回值函数</h4><p>void函数可以不加return，函数的最后一句会隐式的地执行return。</p>
<p>void函数可以执行第二种return但是返回的必须是另一个void的函数</p>
<h4 id="有返回值函数"><a href="#有返回值函数" class="headerlink" title="有返回值函数"></a>有返回值函数</h4><p>除了void的函数必须要有返回值，不然会编译报错。但是如果某一条路径上没有返回值，则会在运行时报错。</p>
<p><strong>值的返回</strong></p>
<p>return一个值的方式和初始化一个变量和形参的方式完全一样。</p>
<p>但是不能返回一个局部变量的指针或者引用，因为局部变量在函数完成后它的存储空间也被释放掉，那么局部变量(字面值也算)的引用将指向不再有效的内存。</p>
<p><strong>返回类类型的函数和调用运算符</strong></p>
<p>调用运算符和点运算符箭头运算符优先级一样并且符合左结合律。因此能如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> sz = shortString(s1, s2).size();</span><br></pre></td></tr></table></figure>
<p><strong>引用返回左值</strong></p>
<p>函数的返回类型决定函数调用是否是左值。调用一个返回引用的函数是左值，其他返回类型是右值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> &amp;<span class="title">get_val</span><span class="params">()</span></span>;</span><br><span class="line">get_val(s, <span class="number">0</span>) = ‘A’;		<span class="comment">//能给返回的引用赋值</span></span><br></pre></td></tr></table></figure>
<p><strong>列表初始化返回值</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; process()&#123;</span><br><span class="line">	<span class="keyword">return</span> &#123;“a”,”b”,”c”&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>主函数main的返回值</strong></p>
<p>main函数会隐式在最后一行返回0，它的函数值看作是状态指示器，返回0表示执行成功，别的值则是执行失败。非0的值含义根据机器而定。</p>
<p>cstdlib头文件里面定义了两个预处理变量，可以用这两个变量表示成功(0)与失败。这样返回值与机器无关：</p>
<p>EXIT_FALLURE;</p>
<p>EXIT_SUCCESS;</p>
<p>main函数不能调用他自己。</p>
<h4 id="返回数组指针"><a href="#返回数组指针" class="headerlink" title="返回数组指针"></a>返回数组指针</h4><p>因为数组不能被拷贝所以能返回数组的引用或者指针。</p>
<p>声明一个返回指针的函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Type(*function(parameter _list))[dimension]</span><br></pre></td></tr></table></figure>
<p>Type表示元素类型，dimension是数组的大小，括号必须存在。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (*func(<span class="keyword">int</span> i))[<span class="number">10</span>];		<span class="comment">//func返回一个10个int元素的数组的指针</span></span><br></pre></td></tr></table></figure>
<p><strong>尾置返回类型</strong></p>
<p>用于简化函数声明，这种形式对比较复杂的函数返回类型比较有用，上述可定义为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto func(int i)-&gt;int (*)[10];</span><br></pre></td></tr></table></figure>
<p>在参数列表后面有一个箭头符号，后面代表返回类型，然后在前面加一个auto。</p>
<p>使用<strong>decltype</strong></p>
<p>如果我们知道指针指向哪个数组，就可以使用decltype，但是它返回的是数组，所以我们需要把它在声明时加一个*。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(odd) *func(<span class="keyword">int</span> i)&#123;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>如果同一作用域内的几个函数的名字相同但形参列表不同，称之为重载函数。</p>
<p>定义：</p>
<ol>
<li>形参数量或者形参类型上有所不同。<br>注（以下不算函数重载）：</li>
<li>如果只是返回类型不同不算函数重载</li>
<li>省略了形参名字、或只是形参别名也不算</li>
<li>传入的是顶层const</li>
</ol>
<h4 id="重载和const形参"><a href="#重载和const形参" class="headerlink" title="重载和const形参"></a>重载和const形参</h4><p>顶层const不影响传入函数的对象，因此一个顶层const的函数和一个没有const的函数不能区分成两个函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Phone)</span></span>;</span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Phone)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Phone*)</span></span>;</span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Phone* <span class="keyword">const</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这两组都是重复的声明，因为是顶层const</p>
<p>如果传入的是底层的const，区分指针或者引用指向的对象是否是const可以区分成<strong>两个</strong>函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Account&amp;)</span></span>;</span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Account&amp;)</span></span>;</span><br></pre></td></tr></table></figure>
<p>指针同上。</p>
<h4 id="const-cast-和重载"><a href="#const-cast-和重载" class="headerlink" title="const_cast 和重载"></a>const_cast 和重载</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="built_in">string</span> &amp;<span class="title">shorterString</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s1, <span class="keyword">const</span> <span class="built_in">string</span> &amp;s1)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> s1.size()&gt;s2.size()?s2:s1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>传入和返回的都是const类型的string引用，我们想传入普通引用。那么可以用const_cast：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> &amp;<span class="title">shorterString</span><span class="params">(<span class="built_in">string</span> &amp;s1, <span class="built_in">string</span> &amp;s2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> &amp;r = shorterString(<span class="keyword">const_cast</span>&lt;<span class="keyword">const</span> <span class="built_in">string</span>&amp;&gt;(s1), </span><br><span class="line">							<span class="keyword">const_cast</span>&lt;<span class="keyword">const</span> <span class="built_in">string</span>&amp;&gt;(s2));</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;<span class="built_in">string</span>&amp;&gt;(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样操作是安全的。</p>
<h3 id="重载与作用域"><a href="#重载与作用域" class="headerlink" title="重载与作用域"></a>重载与作用域</h3><p>一般来说函数声明置于全局而不是局部。如果将函数声明在局部，那么会将在外层作用域中同名的函数实体隐藏。在不同作用域中无法重载函数名：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fooBar</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">bool</span> read = <span class="literal">false</span>;</span><br><span class="line">	<span class="built_in">string</span> s = read();			<span class="comment">//错误：read变为bool值而非函数</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">	print(“Value : ”);			<span class="comment">//错误：print(const string&amp;)被隐藏了</span></span><br><span class="line">	print(<span class="number">1</span>);</span><br><span class="line">	print(<span class="number">3.14</span>);				<span class="comment">//正确：调用print(int);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上可知，局部声明的函数会隐藏作用域外的同名函数。调用函数时，编译器首先寻找对该函数的声明，找到的是局部声明，就会忽略掉外层的同名实体。</p>
<h2 id="特殊用途语言特性"><a href="#特殊用途语言特性" class="headerlink" title="特殊用途语言特性"></a>特殊用途语言特性</h2><h3 id="默认实参"><a href="#默认实参" class="headerlink" title="默认实参"></a>默认实参</h3><p>如果一个函数多次调用，传入的参数是相同的那么我们可以设置一个默认参数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">string</span>::size sz;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">screen</span><span class="params">(sz ht = <span class="number">24</span>, sz wid = <span class="number">80</span>, <span class="keyword">char</span> backgrnd = ‘ ’)</span></span>;</span><br></pre></td></tr></table></figure>
<p>想使用默认实参只需要省略参数就可以了。</p>
<p>默认实参负责填补函数调用缺少的尾部实参，意思就是如果想要覆盖第三个参数，那么前面两个参数也要给定实参：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window = screen(, , ‘?’);			<span class="comment">//错误：只能省略尾部的实参</span></span><br></pre></td></tr></table></figure>
<h4 id="默认实参声明"><a href="#默认实参声明" class="headerlink" title="默认实参声明"></a>默认实参声明</h4><p>在给定的作用域中一个形参只能被赋予一次默认实参。后续声明只能为没有默认值的形参添加实参，而且该形参的右侧必须都有默认值:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">screen</span><span class="params">(sz, sz, <span class="keyword">char</span> = ‘ ‘)</span></span>;			<span class="comment">//char = ‘ ’等同于char c = ‘ ’。</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">screen</span><span class="params">(sz, sz, <span class="keyword">char</span> = ‘*’)</span></span>;			<span class="comment">//错误：重复声明了char</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">screen</span><span class="params">(sz=<span class="number">24</span>, sz = <span class="number">80</span>, <span class="keyword">char</span>)</span></span>;		<span class="comment">//正确：添加默认实参</span></span><br></pre></td></tr></table></figure>
<p>如果在局部内声明，那么会<strong>隐藏外层作用域的声明</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">make_plural</span><span class="params">(<span class="keyword">size_t</span>, <span class="keyword">const</span> <span class="built_in">string</span>&amp;, <span class="keyword">const</span> <span class="built_in">string</span>&amp; = <span class="string">"s"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; make_plural(<span class="number">1</span>, <span class="string">"success"</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; make_plural(<span class="number">2</span>, <span class="string">"success"</span>, <span class="string">"es"</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; make_plural(<span class="number">2</span>, <span class="string">"failure"</span>) &lt;&lt; <span class="built_in">endl</span>;	<span class="comment">//输出failures</span></span><br><span class="line">	<span class="comment">//隐藏了外层的声明</span></span><br><span class="line">	<span class="function"><span class="built_in">string</span> <span class="title">make_plural</span><span class="params">(<span class="keyword">size_t</span>, <span class="keyword">const</span> <span class="built_in">string</span>&amp; word = <span class="string">"dog"</span>, <span class="keyword">const</span> <span class="built_in">string</span>&amp; = <span class="string">"p"</span>)</span></span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; make_plural(<span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//输出dogp</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">make_plural</span><span class="params">(<span class="keyword">size_t</span> c, <span class="keyword">const</span> <span class="built_in">string</span>&amp; word, <span class="keyword">const</span> <span class="built_in">string</span>&amp; ending)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (c &gt; <span class="number">1</span>) ? word + ending : word;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>局部变量不能作为默认实参。除此之外，只要表达式的类型能转换成形参所需的类型就能作为默认实参。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sz wd = <span class="number">80</span>;</span><br><span class="line"><span class="keyword">char</span> def = ‘ ’;</span><br><span class="line"><span class="function">sz <span class="title">ht</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">screen</span><span class="params">(sz=ht(), sz=wd, <span class="keyword">char</span>=def)</span></span>;</span><br></pre></td></tr></table></figure>
<p>用作默认实参的名字在函数声明所在的作用域内解析：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>&#123;</span><br><span class="line">	def=’*’;					<span class="comment">//改变默认实参的值</span></span><br><span class="line">	sz wd = <span class="number">100</span>;				</span><br><span class="line">	window = screen();			<span class="comment">//调用screen(ht(), 80, ‘*’) def实参被改变了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="内联函数和constexpr函数"><a href="#内联函数和constexpr函数" class="headerlink" title="内联函数和constexpr函数"></a>内联函数和constexpr函数</h3><p>内联函数可以避免函数调用的开销：将函数指定为内联inline，通常就是将他在每个调用点上内联的展开。内联说明只是向编译器发出的一个请求，编译器可以忽略。一般用于优化规模小、流程直接、调用频繁的函数。</p>
<h4 id="constexpr函数"><a href="#constexpr函数" class="headerlink" title="constexpr函数"></a>constexpr函数</h4><p>constexpr函数是指能用于常量表达式的函数，它的函数返回类型以及所有的形参类型都得是<strong>字面值</strong>类型，而且只能有一条return语句。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">new_sz</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="number">42</span>;&#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> foo = new_sz();				<span class="comment">//正确foo是一个常量表达式</span></span><br></pre></td></tr></table></figure>
<p>在初始化变量时候，编译器会验证new_sz函数返回值是否是常量表达式，如果是那么就能初始化成功。</p>
<p>为了能在编译过程中随时展开，constexpr函数被隐式的指定为内联函数。</p>
<p><strong>允许constexpr的返回值不是常量</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> size_t <span class="title">scale</span><span class="params">(<span class="keyword">size_t</span> cnt)</span></span>&#123;<span class="keyword">return</span> new_sz()*cnt;&#125;</span><br><span class="line"><span class="keyword">int</span> arr[scale(<span class="number">2</span>)];		<span class="comment">//正确			</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> a2[scale(i)];		<span class="comment">//错误</span></span><br></pre></td></tr></table></figure>
<p>如上，数组初始化值只能是常量表达式，当传入一个字面值是2的常量表达式时scale函数返回的也是常量表达式，反之传入非常量表达式i返回的也是非常量表达式。那么编译器会发出错误信息。</p>
<p><strong>constexpr函数和内联函数放在头文件内</strong></p>
<p>和其他函数不一样，这两个函数能定义多次，但是它的多个定义必须一致。所以放在头文件中。</p>
<h3 id="assert预处理宏和NDEBUG预处理变量"><a href="#assert预处理宏和NDEBUG预处理变量" class="headerlink" title="assert预处理宏和NDEBUG预处理变量"></a>assert预处理宏和NDEBUG预处理变量</h3><p>assert是一个预处理宏，行为类似内联函数。使用一个表达式作为他的条件：</p>
<p>assert(expr)；</p>
<p>如果表达式为假(即0)，那么assert输出信息并且终止程序的运行。</p>
<p>assert定义在 cassert头文件中，预处理变量和宏名字在程序内都唯一不需要提供using声明。不能定义assert为名字的其他变量或者函数名。</p>
<p>NDEBUG：</p>
<p>如果定义了NDEBUG预处理变量，那么assert就不会被检查。也就是失效</p>
<p>预处理定义了几个对程序调试很有用的名字：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func__			<span class="comment">//存放函数名的const char数组</span></span><br><span class="line"></span><br><span class="line">__FILE__		<span class="comment">//存放文件名的字符串字面值</span></span><br><span class="line"></span><br><span class="line">__LINE__		<span class="comment">//存放当前行号的整型字面值</span></span><br><span class="line"></span><br><span class="line">__TIME__		<span class="comment">//存放编译时间的字符串字面值</span></span><br><span class="line"></span><br><span class="line">__DATE__		<span class="comment">//存放文件编译日期的字符串字面值</span></span><br></pre></td></tr></table></figure>
<h2 id="函数匹配"><a href="#函数匹配" class="headerlink" title="函数匹配"></a>函数匹配</h2><p>当几个重载函数的形参数量相等以及某些形参的类型可以由其他类型转换得来时，进行函数匹配的流程如下：</p>
<ol>
<li>选定本次调用的<strong>候选函数</strong>：<ol>
<li>与被调用函数同名</li>
<li>其声明在调用点可</li>
</ol>
</li>
<li>选出<strong>可行函数</strong>：<ol>
<li>其形参数量跟本次调用实参数量相等</li>
<li>每个实参对应的类型相同或者能转换成形参类型</li>
</ol>
</li>
<li>寻找最佳匹配：基本思想是实参类型与形参类型越接近，它们<strong>匹配的越好（实参类型转换）</strong>。满足下面两个条件才算匹配成功：<ol>
<li>该函数每个实参的匹配的都不劣于其他可行函数需要的匹配</li>
<li>至少有一个实参的匹配优于其他可行函数提供的匹配</li>
</ol>
</li>
</ol>
<p>例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> , <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">double</span>, <span class="keyword">double</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">f(<span class="number">5</span>,<span class="number">2.3</span>);</span><br></pre></td></tr></table></figure>
<p>上面这个调用会产生二义性，因为在第一个参数上匹配int精确匹配，但是在第二个参数上需要转成int；或者匹配double，第一个参数需要转。</p>
<p>调用重载函数尽量避免强制转换。如果需要则说明设计不合理。</p>
<h4 id="实参类型转换"><a href="#实参类型转换" class="headerlink" title="实参类型转换"></a>实参类型转换</h4><p>为了确定最佳匹配，编译器将实参类型到形参类型的转换划分为几个等级如下：</p>
<ol>
<li><p>精确匹配：</p>
<p>(1) 实参类型和形参类型相同</p>
<p>(2) 实参从数组类型或函数类型转换成对应的指针类型</p>
<p>(3) 向实参添加顶层const或者从实参中删除顶层const</p>
</li>
<li><p>通过const转换实现的匹配</p>
</li>
<li><p>通过类型提升(char-&gt;int)</p>
</li>
<li><p>通过算数类型转换(int -&gt; long)</p>
</li>
<li><p>通过类类型转换实现的匹配</p>
</li>
</ol>
<p>第4点：所有算术类型转换的级别都一样。比如从int到unsigned int或者double的级别是一样的。一个double如果能转到long跟float那么存在二义性</p>
<p>第2点：函数匹配和const实参：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Account&amp;)</span></span>;</span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Account&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Account a;</span><br><span class="line">Account b;</span><br><span class="line"></span><br><span class="line">lookup(a);		<span class="comment">//调用lookup(const 	Account&amp;)</span></span><br><span class="line">lookup(b);		<span class="comment">//调用lookup(Account&amp;)</span></span><br></pre></td></tr></table></figure>
<p>第二个调用中传入b。对于这个调用来说两个函数都是可行的，我们可以用b初始化常量引用。但是需要转换。所以精确匹配到了非常量引用的函数</p>
<h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>函数指针指向的是函数而非对象。函数的类型由返回类型和形参类型决定：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> (*pf) (<span class="keyword">const</span> <span class="built_in">string</span>&amp;, <span class="keyword">const</span> <span class="built_in">string</span>&amp;);</span><br></pre></td></tr></table></figure>
<p>pf是一个指向函数的指针，这个函数返回bool并且参数列表是两个const string &amp;</p>
<p>把函数名作为值使用时，自动转成指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pf = lengthCompare;</span><br><span class="line">pf = &amp; lengthCompare;		<span class="comment">//等价的赋值</span></span><br></pre></td></tr></table></figure>
<p>在使用指针的时候也可以不需要解引用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> b1 = pf();</span><br><span class="line"><span class="keyword">bool</span> b2 = (*pf)();			<span class="comment">//等价的调用函数</span></span><br></pre></td></tr></table></figure>
<p>在指向不同函数类型间不存在转换规则，但是可以指向nullptr。</p>
<p>使用重载函数时，必须清晰的界定选用那个函数，必须精确匹配。</p>
<h4 id="函数形参"><a href="#函数形参" class="headerlink" title="函数形参"></a>函数形参</h4><p>和数组类似，函数不能定义成形参，但是形参可以是指向函数的指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">useBigger</span><span class="params">(<span class="keyword">bool</span> pf(<span class="keyword">const</span> <span class="built_in">string</span>&amp;,<span class="keyword">const</span> <span class="built_in">string</span>&amp;))</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">useBigger</span><span class="params">(<span class="keyword">bool</span> (*pf)(<span class="keyword">const</span> <span class="built_in">string</span>&amp;,<span class="keyword">const</span> <span class="built_in">string</span>&amp;))</span></span>;	<span class="comment">//等价的声明</span></span><br></pre></td></tr></table></figure>
<p>我们可以直接把函数当成实参使用，他会自动转成指针。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useBigger(lengthCompare);</span><br></pre></td></tr></table></figure>
<p>使用typedef别名能简化函数名：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">bool</span> <span class="title">Func</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;,<span class="keyword">const</span> <span class="built_in">string</span>&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(lengthCompare)</span> Func2</span>;		<span class="comment">//同上，func2是函数类型</span></span><br></pre></td></tr></table></figure>
<p>在上述func前加*就是函数指针。</p>
<h4 id="返回函数的指针"><a href="#返回函数的指针" class="headerlink" title="返回函数的指针"></a>返回函数的指针</h4><p>和数组一样，不能直接返回一个函数但是可以返回函数指针。</p>
<p>使用类型别名显得方便：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> F = <span class="keyword">int</span>(<span class="keyword">int</span>*, <span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">using</span> PF = <span class="keyword">int</span>(*)(<span class="keyword">int</span>*, <span class="keyword">int</span>);		<span class="comment">//PF是指针类型</span></span><br><span class="line"></span><br><span class="line"><span class="function">PF <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span></span>;			<span class="comment">//正确：PF是指向函数的指针</span></span><br><span class="line"><span class="function">F <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span></span>;			<span class="comment">//错误：不能返回函数</span></span><br><span class="line"><span class="function">F *<span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span></span>;			<span class="comment">//正确：显示声明指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> (*f1(<span class="keyword">int</span>))(<span class="keyword">int</span>*, <span class="keyword">int</span>);<span class="comment">//同上声明</span></span><br></pre></td></tr></table></figure>
<p>由内向外阅读：f1是一个函数，返回的是一个指针类型。指针类型指向的是返回int的函数，参数列表是(int *，int)</p>
<p><strong>使用尾置返回类型的方式显得更加完整</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto f1(int) -&gt; int (*)(int*, int);</span><br></pre></td></tr></table></figure>
<p>同时如果知道返回类型指向的是哪个函数就可以使用decltype:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(sunLength) *getFcn(<span class="keyword">const</span> <span class="built_in">string</span>&amp;);	<span class="comment">//注意需要加*</span></span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/04/statement/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HuaRongxie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HuaRongxie's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/04/statement/" itemprop="url">语句</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-04T21:26:46+08:00">
                2018-11-04
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/C-Primer笔记/" itemprop="url" rel="index">
                    <span itemprop="name">C++Primer笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h1><h3 id="简单语句"><a href="#简单语句" class="headerlink" title="简单语句"></a>简单语句</h3><p>c++中大多数语句都以分号结束，一个表达式，比如<code>ival + 5</code>，末尾加上分号就变成了<strong>表达式语句</strong>。</p>
<p>表达式语句的作用是执行表达式并丢弃掉求值结果：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ival + <span class="number">5</span>;			<span class="comment">//一条没什么用的表达式</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ival;		<span class="comment">//一条输出表达式</span></span><br></pre></td></tr></table></figure>
<h4 id="空语句"><a href="#空语句" class="headerlink" title="空语句"></a>空语句</h4><p>最简单的语句是<strong>空语句(null statement)</strong>，只有一个单独的分号:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;	<span class="comment">//空语句</span></span><br></pre></td></tr></table></figure>
<p>如果在某个地方，语法上需要一条空语句而逻辑上不需要，此时应该使用空语句。</p>
<p>例：当循环的全部工作在条件部分完成时，通常用到空语句。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重复读入数据直至到达文件末尾或依次输入的值等于sought</span></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span>&gt;&gt;s &amp;&amp; s!=sought)</span><br><span class="line">	;	<span class="comment">//空语句</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是，因为空语句也是一条语句，所以可用在任何需要语句的地方。所以，要是多了个分号有可能会造成严重错误，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//出现糟糕的情况：额外的分号，循环体是空语句</span></span><br><span class="line"><span class="keyword">while</span>( iter!=sevc.end()) ;</span><br><span class="line">	++iter;</span><br></pre></td></tr></table></figure>
<p>虽然while下面那行有缩进，但是他的循环体是后面的空语句，会造成死循环。</p>
<h4 id="复合语句-块"><a href="#复合语句-块" class="headerlink" title="复合语句(块)"></a>复合语句(块)</h4><p>复合语句(compound statement)是指用花括号{}括起来(可能是空的)的语句和声明的序列，也被称作块(block)。同样的在块中定义的名字只能在块内部以及嵌套在块中的子块访问。</p>
<p>如果在程序的某个地方，语法上需要一条语句，但是逻辑上需要多条语句，则应该使用复合语句。</p>
<p><strong>例如while和for的循环体必须是一条语句</strong>，但是我们常常需要做很多事情，因此需要将多条语句用花括号括起来变成复合语句，<strong>将语句序列变成块</strong>。</p>
<h3 id="语句作用域"><a href="#语句作用域" class="headerlink" title="语句作用域"></a>语句作用域</h3><p>可以在if、switch、while、for语句的控制结构内定义变量，这些变量只有在语句的内部可见，一旦语句结束，会自动销毁。</p>
<p>如果其他代码也需要访问控制变量，则变量必须定义在语句的外部。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">int</span> i = get_num())	<span class="comment">//每次迭代创建并初始化i</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">i = <span class="number">0</span>;	<span class="comment">//错误，外部无法访问i</span></span><br></pre></td></tr></table></figure>
<h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><p>c++提供了两种按条件执行的语句。</p>
<ul>
<li>一种是if语句，他根据条件决定控制流；</li>
<li>第二种是switch语句，它计算一个整型表达式的值，然后根据这个值从几条执行路径中选择一条。</li>
</ul>
<h4 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h4><p>if语句的作用：判断一个条件是否为真，根据判断结果决定是否执行另一条。</p>
<p>它有两种形式，一种有else，另一种没有：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition)</span><br><span class="line">	statement</span><br></pre></td></tr></table></figure>
<p><strong>if else</strong>语句的形式是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition)</span><br><span class="line">	statement1</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	statement2</span><br></pre></td></tr></table></figure>
<p>如果condition为真，执行statement1；如果为假，执行statement2。</p>
<p><strong>悬垂else</strong></p>
<p>当一个if语句嵌套在另一个if语句内部时，很可能if比else多，那么如何对应else是哪个if的呢，这个问题叫做悬垂else。</p>
<p><strong>c++规定else与离它最近尚未匹配的if匹配，从而消除了二义性。</strong></p>
<p><strong>使用花括号控制执行路径</strong></p>
<p>通常使用花括号来控制if与else匹配以达到我们想要的结果。例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (condition1)&#123;</span><br><span class="line">    if(condition2)</span><br><span class="line">    	statement1</span><br><span class="line">&#125;else				//这个花括号让else与最外层if匹配。</span><br><span class="line">	statement2</span><br></pre></td></tr></table></figure>
<h4 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h4><p>switch语句适用于在若干固定选项中做出选择。例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(ch)&#123;</span><br><span class="line">	<span class="keyword">case</span> ‘a’:</span><br><span class="line">		++aCnt;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> ‘b’:</span><br><span class="line">		++bCnt;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> ‘c’:</span><br><span class="line">		++cCnt;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		++count;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>switch的执行流程：</p>
<ol>
<li>首先对括号里的表达式进行求值，该表达式紧跟在关键字switch后面，可以是初始化的变量声明，如: int ch = get_char()</li>
<li>表达式的值转换成整数类型，然后与每个case标签的值比较</li>
<li>如果匹配成功，程序从该标签之后的第一条语句开始执行，直到break或者switch结尾。</li>
<li>如果没有匹配上，则跳到switch之后的第一条语句。</li>
</ol>
<p>case关键字和它对应的值一起被称为case标签(case label)。</p>
<ul>
<li>case标签的值必须是<strong>整型常量表达式</strong></li>
<li>任意两个case标签的值不能相同</li>
</ul>
<p><strong>default</strong></p>
<p>如果没有任何一个case标签能够匹配上switch表达式的值，程序将执行default标签后面的语句。</p>
<p>即时不准备在default标签下 做任何工作，定义一个default标签也是有用的。如果switch结构以一个空的default标签作为结束，则该default标签后面必须跟上一条空语句或一个空块。</p>
<p><strong>switch内部的变量定义</strong></p>
<p>switch的执行流程有可能会跨过某些case标签。如果跳转到了某个特定的case，而在之前忽略的case里面有变量的初始化，那么是非法行为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="literal">true</span>:</span><br><span class="line">	<span class="built_in">string</span> file_name;		<span class="comment">//错误，控制流绕过一个隐式初始化的变量</span></span><br><span class="line">	<span class="keyword">int</span> ival = <span class="number">0</span>;			<span class="comment">//错误，控制流绕过一个显示初始化的变量</span></span><br><span class="line">	<span class="keyword">int</span> jval;				<span class="comment">//正确：jval没有被初始化</span></span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="literal">false</span>:</span><br><span class="line">	<span class="comment">//变量jval在作用域内 但是没有被初始化。</span></span><br><span class="line">	jval = next_num();</span><br><span class="line">	<span class="keyword">if</span>(file_name.empty());</span><br></pre></td></tr></table></figure>
<p><strong>所以我们应该把变量的定义放在块内，这样保证了每个case里的变量有自己的作用域 。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="literal">true</span>:</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">string</span> file_name = get_file_name();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h3 id="迭代语句"><a href="#迭代语句" class="headerlink" title="迭代语句"></a>迭代语句</h3><p>迭代语句通常称为循环，它重复执行操作直到满足某个条件才停止。</p>
<p>while循环特别适用于条件保持不变。反复执行操作的情况，例如，当未达到文件末尾时不断读取下一个值。</p>
<p>for循环更像在按步骤迭代，它的索引值在某个范围内依次变化，<strong>结构严谨</strong>。</p>
<h4 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h4><p>只要条件为真，while语句就一直执行，语法形式如下：</p>
<p>while(condition){<br>    statement<br>}</p>
<p><strong>定义在while条件部分或者循环体内的变量每次迭代都经历从创建到销毁的过程。</strong></p>
<p><strong>不定数量的输入：</strong></p>
<p>while(cin&gt;&gt;value) : 当使用一个istream作为条件时其效果检测流的状态。当遇到end-if-file，或无效输入(值不为整数),istream状态会变为无效。则条件为假.<br>文件结束符end-of-file: windows 为Ctrl+Z，unix为Ctrl+D</p>
<h4 id="传统的for语句"><a href="#传统的for语句" class="headerlink" title="传统的for语句"></a>传统的for语句</h4><p>for语句的语法形式是</p>
<p>for(init-statement;condition;expression)</p>
<p>​    statement</p>
<p><strong>传统for循环的执行流程</strong></p>
<ol>
<li>循环开始时，执行一次init-statement。</li>
<li>接下来判断condition。如果为真则执行，否则终止循环。</li>
<li>最后执行expression。</li>
</ol>
<p><strong>for语句头中的多重定义</strong></p>
<p>init-statement可以定义多个对象。但是它只能有一条声明语句，因此所有变量的基本类型必须相同。</p>
<p><strong>省略for语句头中的某些部分</strong></p>
<p>for 语句能省略三个里面的任何一个或者全部：</p>
<ol>
<li>如果无需初始化，我们可以使用一条空语句作为init-statement</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> beg = v.begin();</span><br><span class="line"><span class="keyword">for</span>( ; beg!=v.end() &amp;&amp; *beg&gt;<span class="number">0</span>; ++beg)</span><br><span class="line">	;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>省略condition相当于在条件部分写了一个true。所以我们必须在循环体内有语句负责退出循环。</li>
<li>省略掉expression，就要求在条件部分或者循环体内改变迭代变量的值。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i; <span class="built_in">cin</span>&gt;&gt;i ; )</span><br><span class="line">	v.push_back(i);</span><br></pre></td></tr></table></figure>
<h4 id="范围for语句"><a href="#范围for语句" class="headerlink" title="范围for语句"></a>范围for语句</h4><p>这种语句可以遍历容器或其他序列的所有元素。语法形式如下：</p>
<p>for (declaration : expression)</p>
<p>​    statement</p>
<p>expression表示的必须是一个序列，比如用花括号括起来的初始值列表、数组、vector或string等类型的对象，这些类型的共同特点是拥有能返回<strong>迭代器的begin和end</strong>成员。</p>
<p>declaration 定义一个变量，序列中每个元素都能转换成该变量的类型。</p>
<p>如果需要对序列中元素执行写操作，循环变量必须声明成引用类型。</p>
<p>例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;r : v)</span><br><span class="line">	r*=<span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>在范围for中预存了end()的值，如果在序列中添加或删除元素，end函数的值就可能变的无效了。</p>
<h4 id="do-while语句"><a href="#do-while语句" class="headerlink" title="do while语句"></a>do while语句</h4><p>do while语句和while语句非常相似，唯一的区别是do while语句先执行循环体后检查条件。不管条件的值如何，我们都至少执行一次。do while的语法形式如下：</p>
<p>do</p>
<p>​    statement</p>
<p>while(condition);</p>
<p>对于do while语句来说限制性语句块，后判断条件。<strong>所以不允许在条件部分定义变量。</strong></p>
<p>例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ival = <span class="number">1</span>;	<span class="comment">//condition中的变量只能定义在do while之外。</span></span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">	ival = get_num();</span><br><span class="line">&#125;<span class="keyword">while</span>(ival);</span><br></pre></td></tr></table></figure>
<h3 id="跳转语句"><a href="#跳转语句" class="headerlink" title="跳转语句"></a>跳转语句</h3><p>跳转语句中断当前的执行过程。c++语言提供了4种跳转语句：break、continue、goto和return。</p>
<h4 id="break语句"><a href="#break语句" class="headerlink" title="break语句"></a>break语句</h4><p>break语句负责终止离他最近的while、do while、for或switch语句。</p>
<h4 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h4><p>终止最近的循环中的当前迭代并开始下一次迭代，只能出现在for、while和do while循环的内部。</p>
<p>对于while 和 do while来说，继续判断条件的值;对于传统for，继续执行expression；对于范围for则是用序列中的下一个元素循环控制变量。</p>
<h4 id="goto-不要使用"><a href="#goto-不要使用" class="headerlink" title="goto(不要使用)"></a>goto(不要使用)</h4><p>goto语句的作用是从goto语句无条件跳转到同一函数内的另一条语句。</p>
<p><strong><u>注意：不要在程序中使用goto语句，因为它使得程序既难理解又难修改。</u></strong></p>
<p>语法形式如下：</p>
<p>goto label;    </p>
<p>label是用于标识一条语句的标识符。    带标签语句是一种特殊的语句，在它之前有一个标示符以及一个冒号：</p>
<p>end: return;        //end是标签后面跟语句</p>
<p>和switch一样他也不能将程序的控制权冲变量的作用域之外转移到作用域之内：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">goto</span> end;</span><br><span class="line"><span class="keyword">int</span> ix = <span class="number">10</span>;		<span class="comment">//错误：goto语句桡骨了一个带初始化的变量定义</span></span><br><span class="line">end:</span><br><span class="line">	ix = <span class="number">42</span>;		<span class="comment">//错误：此处需要用到ix 但是goto跳过了声明</span></span><br></pre></td></tr></table></figure>
<p>goto跳回到定义变量之前是合法的，相当于销毁后重新定义。</p>
<h3 id="try语句块和异常处理"><a href="#try语句块和异常处理" class="headerlink" title="try语句块和异常处理"></a><strong>try语句块和异常处理</strong></h3><p>异常是指存在于运行时的反常行为，这些行为超出了函数正常功能的范围。典型的异常包括失去数据库连接以及遇到意外输入等。</p>
<p>异常处理机制为程序中<strong>异常检测和异常处理</strong>这两部分的协作提供支持。</p>
<p>异常处理机制包括：</p>
<ul>
<li><strong>throw表达式</strong>，异常检测部分用throw表达式来表示它遇到了无法处理的问题。我们说throw引发了异常。</li>
<li><strong>try语句块</strong>，异常处理部分使用try语句块处理异常，try语句块以关键字try开始，并以一个或多个catch子句结束。try语句块中抛出的异常通常会被某个catch子句处理。因为catch子句处理异常，所以它们也被称作<strong>异常处理代码</strong></li>
<li>一套<strong>异常类</strong>，用于在throw表达式和相关的catch子句之间传递异常的具体信息。</li>
</ul>
<h4 id="throw表达式"><a href="#throw表达式" class="headerlink" title="throw表达式"></a>throw表达式</h4><p>检测部分用throw表达式引发一个异常。throw表达式包含关键字throw和紧随其后的一个表达式，其中表达式的类型就是抛出的异常类型。</p>
<p>例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> runtime_error(“Data must refer to same ISBN”);</span><br></pre></td></tr></table></figure>
<h4 id="try语句块"><a href="#try语句块" class="headerlink" title="try语句块"></a><strong>try语句块</strong></h4><p>try语句块的语法形式：</p>
<p><strong>try{</strong></p>
<p>​    program-statement</p>
<p><strong>} catch (exception-declaration){</strong></p>
<p>​    handler-statement</p>
<p><strong>} catch (exception-declaration){</strong></p>
<p>​    handler-statement</p>
<p><strong>}</strong>//…</p>
<p>try后面跟一个或多个catch，try语句块内有检测异常的代码。catch后面的括号是一个异常声明，捕获到之后执行所在的语句块来处理异常。</p>
<p>寻找处理代码的过程跟函数调用链刚好相反。当异常被抛出时，首先搜索抛出该异常的函数。如果没有匹配到catch子句，终止该函数，并且在调用该函数的函数中寻找。如果找不到则转到名为 terminate的标准库函数。</p>
<h4 id="标准异常"><a href="#标准异常" class="headerlink" title="标准异常"></a><strong>标准异常</strong></h4><p>c++标准库定义了一组异常类，分别定义在4个头文件中：</p>
<ol>
<li>exception头文件定义了最通用的异常类exception。它至报告异常发生，不提供任何额外信息。</li>
<li>stdexcept头文件定义了下表的几种异常类。</li>
<li>new头文件定义了bad_alloc异常类型12.1.2</li>
<li>type_info 定义了bad_cast异常类型19.2</li>
</ol>
<p><img src="/2018/11/04/statement/stdexcept.png" alt=""></p>
<p>exception、bad_alloc和bad_cast对象只能以默认初始化方式进行初始化；</p>
<p>而其他异常类型洽洽相反，因使用string对象或者c风格字符串初始化，并且不允许默认初始化方式。创建此类对象必须提供<strong>初始值</strong>，这个对象初始值是用于提示异常的文本信息。</p>
<p>异常类型值定义了一个名为what的成员函数，该函数没有任何参数，返回值是一个C风格字符串的const char*。对于其他无初始值的异常类型 what返回的内容由编译器决定。</p>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/27/io/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HuaRongxie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HuaRongxie's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/27/io/" itemprop="url">IO(流)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-27T21:04:42+08:00">
                2018-10-27
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/C-Primer笔记/" itemprop="url" rel="index">
                    <span itemprop="name">C++Primer笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>ps：先是简单的介绍一下IO类、文件的输入输出以及string流。看到之后章节再记录拓展~</p>
<h1 id="IO库"><a href="#IO库" class="headerlink" title="IO库"></a>IO库</h1><h3 id="基本介绍："><a href="#基本介绍：" class="headerlink" title="基本介绍："></a>基本介绍：</h3><h4 id="include："><a href="#include：" class="headerlink" title="#include："></a><strong>#include：</strong></h4><p>#include指令用于添加头文件。通常情况下，它必须出现现在所有函数之外。一般将他放在源文件最开始的位置。</p>
<ul>
<li>#include &lt;&gt;:尖括号用于添加<strong>标准库头文件</strong></li>
<li>#include “”:双引号用于添加<strong>自己定义</strong>的头文件</li>
</ul>
<h4 id="lt-lt-、-gt-gt-左侧、右侧运算符"><a href="#lt-lt-、-gt-gt-左侧、右侧运算符" class="headerlink" title="&lt;&lt;、&gt;&gt;左侧、右侧运算符:"></a><strong>&lt;&lt;、&gt;&gt;左侧、右侧运算符:</strong></h4><p>&lt;&lt;左侧的对象必须是一个ostream对象，返回一个ostream对象。&gt;&gt;左侧的对象必须是一个istream对象，返回一个istream对象。</p>
<h4 id=""><a href="#" class="headerlink" title="::"></a><strong>::</strong></h4><p>作用域运算符::用来表示某个作用域。</p>
<h4 id="部分IO库设施："><a href="#部分IO库设施：" class="headerlink" title="部分IO库设施："></a>部分IO库设施：</h4><table>
<thead>
<tr>
<th>istream(输入流)</th>
<th>提供输入操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>ostream(输出流)</td>
<td>提供输出操作</td>
</tr>
<tr>
<td>cin</td>
<td>从标准输入读取数据</td>
</tr>
<tr>
<td>cout</td>
<td>从标准输出写入数据</td>
</tr>
<tr>
<td>cerr</td>
<td>通常用于输出程序错误信息，写入到标准错误</td>
</tr>
<tr>
<td>运算符&gt;&gt;</td>
<td>用来从一个istream对象读取输入数据</td>
</tr>
<tr>
<td>运算符&lt;&lt;</td>
<td>用来从一个ostream对象写入输出数据</td>
</tr>
<tr>
<td>getline函数</td>
<td>从一个给定的istream读取一行数据存入一个给定的string对象中</td>
</tr>
</tbody>
</table>
<h3 id="IO类"><a href="#IO类" class="headerlink" title="IO类"></a>IO类</h3><p>为了继承不同种类的IO操作，标准库还定义了其他一些IO类型。分别定义在三个头文件中：</p>
<ol>
<li>iostream定义了用于读写流的基本类型。<ol>
<li>istream、wistream从流读取数据</li>
<li>ostream、wostream向流写入数据</li>
<li>iostream、wiostream读写流</li>
</ol>
</li>
<li><p>fstream定义了读写命名文件的类型</p>
<ol>
<li>ifstream、wifstream从文件读取数据</li>
<li>ofstream、wofstream向文件写入数据</li>
<li>iofstream、wiofstream读写文件</li>
</ol>
</li>
<li><p>sstream定义了读写内存string对象的类型</p>
<ol>
<li>istringstream、wistringstream从string读取数据</li>
<li>ostringstream、wostringstream向string写入数据</li>
<li>iostringstream、wiostringstream读写string</li>
</ol>
</li>
</ol>
<p>以上w开头是为了支持宽字符w_char类型的数据。wcin、wcout、wcerr对应cin、cout、cerr等等。</p>
<p><strong>而fstream和sstream都是继承iostream的</strong></p>
<h4 id="IO对象无法拷贝或赋值"><a href="#IO对象无法拷贝或赋值" class="headerlink" title="IO对象无法拷贝或赋值"></a>IO对象无法拷贝或赋值</h4><p>IO对象无法拷贝，因此不能将形参或者返回值定为流类型，但是可以定义为流的引用类型。</p>
<h4 id="流的条件状态"><a href="#流的条件状态" class="headerlink" title="流的条件状态"></a>流的条件状态</h4><p>IO操作有可能发生错误。有些是可以恢复的而有些是不可恢复的，因此下表列出了一些<strong>函数和标志</strong>来帮助我们访问和操纵 流的<strong>条件状态(condition state)</strong>：下表中strm是表示一种流类型(上表所列出的)，s表示一个流</p>
<table>
<thead>
<tr>
<th>strm:iostate</th>
<th>iostate是一种机器相关的类型，提供了表达条件状态的完整功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>strm:badbit</td>
<td>用来指出流已崩溃/第四位</td>
</tr>
<tr>
<td>strm:failbit</td>
<td>用来指出一个IO操作失败/第三位</td>
</tr>
<tr>
<td>strm:eofbit</td>
<td>用来指出流到达了文件结束/第二位</td>
</tr>
<tr>
<td>strm:goodbit</td>
<td>用来指出流未处于错误状态/第1位(从右往左)</td>
</tr>
<tr>
<td>s.eof()</td>
<td>若流s的eofbit置位，则返回true</td>
</tr>
<tr>
<td>s.fail()</td>
<td>若failbit或badbit置位，则返回true</td>
</tr>
<tr>
<td>s.bad()</td>
<td>若badbit置位，返回true</td>
</tr>
<tr>
<td>s.good()</td>
<td>若s处于有效状态，则返回true</td>
</tr>
<tr>
<td>s.clear()</td>
<td>将流s中所有条件状态复位，将流状态置为有效。返回void</td>
</tr>
<tr>
<td>s.clear(flags)</td>
<td>根据给定flags标志位，将流s中对应状态置为有效。flags类型为strm::iostate，返回void</td>
</tr>
<tr>
<td>s.setstate(flags)</td>
<td>根据给定flags标志位，将流s中对应状态置位。flags类型为strm::iostate，返回void</td>
</tr>
<tr>
<td>s.rdstate()</td>
<td>返回流s的当前条件状态，返回类型为iostate</td>
</tr>
</tbody>
</table>
<p>例：如果在一个int类型中输入字符时，读操作就会失败。类似的输入一个文件结束符时。cin也会进入错误状态。</p>
<h4 id="查询流的状态"><a href="#查询流的状态" class="headerlink" title="查询流的状态"></a>查询流的状态</h4><p><strong>标准库定义的类型：</strong></p>
<p>上表中定义了4个iostate类型的constexpr值，表示特定的位模式。意思就是每一个值用一位二进制来表示，例如他们初始值为1110，右边第一位表示goodbit，第二位是eofbit…</p>
<p>badbit：表示系统级错误，不可恢复。</p>
<p>failbit：表示可以恢复的错误，例如期望读取int类型却读出了字符等错误。流可以被修正，能继续使用。</p>
<p>eofbit：如果达到文件结尾，eofbit和failbit都会被置位</p>
<p>goodbit：值为0表示流未发生错误</p>
<p>如果badbit、failbit、eofbit三个其中一个发生错误，则流检测状态的条件会失败。</p>
<p><strong>标准库定义的函数：</strong></p>
<p>good():在所有错误未置位的情况下返回true</p>
<p>bad、fail、eof 则在对应类型被置位下返回true。</p>
<p>此外在badbit被置位时fail也会返回true。因此使用good或fail是确定流总体状态的正确方法。实际上我们用的<strong>条件while(cin)就等于!fail()</strong></p>
<h4 id="管理条件状态"><a href="#管理条件状态" class="headerlink" title="管理条件状态"></a>管理条件状态</h4><p>clear() :将所有状态复位。</p>
<p>clear(flags)：将指定状态复位。flags是iostate类型。<strong>例：</strong></p>
<p>​    初始值1110.加入产生了错误导致failbit和badbit置位，iostate变成0010.如果想单独将failbit置位那么就需要传入0110。这时代码可写成clear(s.rdstate() &amp; ~s.failbit)</p>
<h4 id="管理输出缓冲"><a href="#管理输出缓冲" class="headerlink" title="管理输出缓冲"></a>管理输出缓冲</h4><p>每个输出流都管理一个缓冲区，用来保存程序读写的数据。有了缓冲机制，操作系统就可以将程序的多个输出操作组合成单一的系统级写操作。提升很大的性能。</p>
<p><strong>导致缓冲刷新的原因：</strong></p>
<ul>
<li>程序正常结束，作为main的return操作的一部分，缓冲刷新</li>
<li>缓冲区满的时候</li>
<li>可以使用操纵符endl来显式刷新</li>
<li>在每个输出操作之后，用操纵符unitbuf设置流的内部状态，来清空缓冲区。默认情况对cerr是设置unitbuf的。</li>
<li>一个输出流可以被关联到另一个流。在这种情况下，当读写被关联的流时，关联到的流缓冲区会被刷新。例如：cin和cerr都关联到cout。因此读cin或写cerr都会导致cout缓冲区被刷新。</li>
</ul>
<p><strong>刷新输出缓冲区：</strong></p>
<p>endl: 输出内容和一个换行，刷新缓冲区</p>
<p>flush:输出内容，刷新缓冲区</p>
<p>ends:出书内容和一个空字符，刷新缓冲区</p>
<p><strong>unitbuf操纵符：</strong></p>
<p>如果想每次输出后都刷新缓冲区可以使用unitbuf操纵符。它告诉流在每次写操作之后进行一次flush操作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; unitbuf;	<span class="comment">//所有输出操作后都会刷新缓冲区</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; nounitbuf;	<span class="comment">//回到正常缓冲方式</span></span><br></pre></td></tr></table></figure>
<p><strong>关联输入输出流：</strong></p>
<p>一个输出流可以被关联到另一个流。在这种情况下，当读写被关联的流时，关联到的流缓冲区会被刷新。例如：cin和cerr都关联到cout。因此读cin或写cerr都会导致cout缓冲区被刷新。</p>
<p>NOTE:交互式系统通常关联输入流与输出流。这意味这所有输出都会在写入之前打印出来。</p>
<p><strong>tie：</strong>tie函数有两个版本：</p>
<ul>
<li>一个无参版本，返回指向输出流的指针。如果本对象关联一个输出流，返回的就是这个流的指针，否则未关联则返回空指针；</li>
<li>tie的第二个版本接受一个<strong>指向ostream</strong>的指针，将自己关联到此ostream，即：x.tie(&amp;o)将流x关联到o</li>
</ul>
<p>我们可以将istream关联到ostream也可以将ostream关联到ostream。每个流只能关联一个流，但是一个流可以被多个流关联。</p>
<h3 id="文件输入输出"><a href="#文件输入输出" class="headerlink" title="文件输入输出"></a>文件输入输出</h3><p>之前有说到，头文件<strong>fstream</strong>定义了三个类型来支持文件IO：ifstream从一个给定文件读取数据；ofstream向一个给定文件写入数据； fstream能读写文件。这三个类型的操作与之前一样，能用IO运算符(&lt;&lt;和&gt;&gt;)来读写文件，可用getline()来获取行数据。</p>
<p>除了继承自iostream类型的行为之外，它还定义了新的成员来管理文件流。如下：fstream是头文件fstream中定义的一个类型</p>
<table>
<thead>
<tr>
<th>fstream fstrm;</th>
<th>创建一个未绑定的文件流</th>
</tr>
</thead>
<tbody>
<tr>
<td>fstream fstrm(s);</td>
<td>创建一个fstream并打开名为s的文件(加后缀)。s可以是string或指向c风格字符串的指针。这些构造函数都是explicit的。默认文件模式mode依赖于fstream的类型</td>
</tr>
<tr>
<td>fstream fstrm(s, mode);</td>
<td>与前一个<strong>构造函数</strong>相似，但指定了mode</td>
</tr>
<tr>
<td>fstrm.open(s)</td>
<td>打开名为s的文件，并将文件与fstrm绑定。返回void</td>
</tr>
<tr>
<td>fstrm.close()</td>
<td>关闭与fstrm绑定的文件。返回void</td>
</tr>
<tr>
<td>fstrm.is_open()</td>
<td>返回一个bool值，指出与fstrm关联的文件是否成功打开并且未关闭</td>
</tr>
</tbody>
</table>
<p>上表中前三个是构造函数，用于创建一个文件流并且可以选择<strong>是否绑定文件</strong>以及打开文件的<strong>模式</strong>。</p>
<h4 id="使用文件流对象"><a href="#使用文件流对象" class="headerlink" title="使用文件流对象"></a>使用文件流对象</h4><p><strong>创建文件流：</strong></p>
<p>我们可以先定义一个文件流并且与文件相关联，也可以只先定义一个文件流对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">in</span><span class="params">(file.txt)</span></span>;		<span class="comment">//构造一个ifstream并打开文件</span></span><br><span class="line">ofstream out;				<span class="comment">//定义一个输出文件流未关联文件</span></span><br></pre></td></tr></table></figure>
<p>文件名可以是string对象，也可以是C风格字符数组。</p>
<p><strong>函数open和close：</strong></p>
<p>如果定义了一个空文件流对象，可以随后调用open来将它与文件相关联。比如上述输出文件流out：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">out.open(<span class="string">"file.txt"</span>);		<span class="comment">//打开指定文件</span></span><br></pre></td></tr></table></figure>
<p>如果调用open失败，failbit会置位。</p>
<p><strong><u>自动构造和析构:</u></strong>如果将创建流定义在while里面，那么while的每一步都会创建与销毁文件流，当一个fstream对象被销毁的时候，会自动调用close函数。</p>
<h4 id="文件模式"><a href="#文件模式" class="headerlink" title="文件模式"></a>文件模式</h4><p>在上表中的第三个构造函数中有个mode参数，这是流关联的文件模式。在调用open打开文件时也可以，不论显示隐式 都会调用一种模式。</p>
<table>
<thead>
<tr>
<th>in</th>
<th>以读方式打开</th>
</tr>
</thead>
<tbody>
<tr>
<td>out</td>
<td>以写方式打开</td>
</tr>
<tr>
<td>app</td>
<td>每次<strong>写操作</strong>前均定位到文件末尾</td>
</tr>
<tr>
<td>ate</td>
<td>打开文件后立即定位到文件末尾</td>
</tr>
<tr>
<td>trunc</td>
<td>截断文件</td>
</tr>
<tr>
<td>binary</td>
<td>以二进制方式进行IO</td>
</tr>
</tbody>
</table>
<ul>
<li>只可以对ostream设定out模式</li>
<li>只可以对istream设定in模式</li>
<li>只有当out也被设定时才可以设定trunc模式</li>
<li>只要没有设定trunc就可以设定app模式。在app模式下没有设定out也会默认out模式。</li>
<li>默认情况下没有指定trunc，以out模式打开的文件也会被截断。如果要保留文件内容，必须指定app模式，或者同时指定in模式。</li>
<li>ate和binary模式可以用于任何类型的文件，并且能与其他模式组合使用。</li>
</ul>
<p>当不指定时，文件流使用默认的文件模式，ifstream是in模式；ofstream是out模式；fstream是in和out模式。</p>
<h4 id="以out打开会丢弃数据"><a href="#以out打开会丢弃数据" class="headerlink" title="以out打开会丢弃数据"></a>以out打开会丢弃数据</h4><p>当一个文件以out模式打开时，会被截断，文件的内容会被丢弃。阻止此行为的方法是指定app模式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ofstream <span class="title">out</span><span class="params">(<span class="string">"file.txt"</span>)</span></span>;			<span class="comment">//隐含以输出模式打开并截断</span></span><br><span class="line"><span class="function">ofstream <span class="title">out2</span><span class="params">(<span class="string">"file.txt"</span>, ofstream::out)</span></span>;		<span class="comment">//隐含截断文件</span></span><br><span class="line"><span class="function">ofstream <span class="title">out3</span><span class="params">(<span class="string">"file.txt"</span>, ofstream::out|ofstream::trunc)</span></span>;</span><br></pre></td></tr></table></figure>
<p>指定app模式则能保留文件：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ofstream <span class="title">app</span><span class="params">(<span class="string">"file.txt"</span>，ofstream::app)</span></span>;		<span class="comment">//隐含为out模式</span></span><br><span class="line"><span class="function">ofstream <span class="title">app</span><span class="params">(<span class="string">"file.txt"</span>，ofstream::out | ofstream::app)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="string流"><a href="#string流" class="headerlink" title="string流"></a>string流</h3><p>类似的，sstream头文件定义了三个类型来支持内存IO：istringstream从string读取数据，ostringstream向string写入数据，stringstream可以读写数据。sstream除了继承来的操作，还定义了一些成员来管理string流。</p>
<table>
<thead>
<tr>
<th>sstream strm;</th>
<th>sstream是头文件sstream中定义的一个类型，strm是一个未绑定的stringstream对象</th>
</tr>
</thead>
<tbody>
<tr>
<td>sstream strm(s);</td>
<td>strm是一个sstream对象，保存string s的一个拷贝。此构造函数是explicit的</td>
</tr>
<tr>
<td>strm.str();</td>
<td>返回strm所保存的string的拷贝</td>
</tr>
<tr>
<td>strm.str(s);</td>
<td>将string s拷贝到strm中。返回void</td>
</tr>
</tbody>
</table>
<h4 id="使用istringstream"><a href="#使用istringstream" class="headerlink" title="使用istringstream"></a>使用istringstream</h4><p>当我们的某些工作是对整行文本进行处理，而其他的一些工作是处理行内的某个单词时，通常能用istringstream。</p>
<p><strong>定义：</strong></p>
<p>可以将一个istringstream与string对象绑定，也可以只定义一个istringstream。然后用str(s)方法绑定</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">istringstream</span> <span class="title">in</span><span class="params">(s)</span></span>;	<span class="comment">//定义一个istringstream与string s绑定</span></span><br><span class="line"><span class="built_in">istringstream</span> in2;		<span class="comment">//定义一个未绑定的流in2</span></span><br><span class="line">in2.str(s);				<span class="comment">//将流in2与string s绑定</span></span><br></pre></td></tr></table></figure>
<p><strong>例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> line = <span class="string">"hello world"</span>, word;</span><br><span class="line"><span class="function"><span class="built_in">istringstream</span> <span class="title">in</span><span class="params">(line)</span></span>;</span><br><span class="line">in &gt;&gt; word;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; word &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<h4 id="使用ostringstream"><a href="#使用ostringstream" class="headerlink" title="使用ostringstream"></a>使用ostringstream</h4><p>当我们逐步构造输出，希望最后一起打印时，ostringstream是很有用的。</p>
<p><strong>定义：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">ostringstream</span> <span class="title">out</span><span class="params">(s)</span></span>;	<span class="comment">//定义一个ostringstream 并将s写入</span></span><br><span class="line"><span class="built_in">ostringstream</span> in2;		<span class="comment">//定义ostringstream </span></span><br><span class="line">in2.str(s);				<span class="comment">//将s写入内存中</span></span><br></pre></td></tr></table></figure>
<p><strong>例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">ostringstream</span> <span class="title">os</span><span class="params">(<span class="string">"hello world"</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; os.str();</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/23/vector/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HuaRongxie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HuaRongxie's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/23/vector/" itemprop="url">标准库类型vector</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-23T21:14:37+08:00">
                2018-10-23
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/C-Primer笔记/" itemprop="url" rel="index">
                    <span itemprop="name">C++Primer笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="标准库类型vector"><a href="#标准库类型vector" class="headerlink" title="标准库类型vector"></a>标准库类型vector</h1><p>vector表示对象的集合，其中所有对象的类型都相同。它是一个容器。</p>
<p>想要使用vector需要添加头文件：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span></span><br></pre></td></tr></table></figure>
<p>同时vector也是一个<strong>类模板</strong>,因此需要提供额外信息指定模板实例化成什么样的类。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec;				<span class="comment">//ivec保存int类型的对象</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; file;	<span class="comment">//该向量的元素是vector对象</span></span><br></pre></td></tr></table></figure>
<h3 id="vector的初始化"><a href="#vector的初始化" class="headerlink" title="vector的初始化"></a>vector的初始化</h3><p><strong>常用初始化vector对象的方法:</strong></p>
<table>
<thead>
<tr>
<th>vector<t> v1</t></th>
<th>v1是一个空vector，它潜在元素是T类型的，执行默认初始化</th>
</tr>
</thead>
<tbody>
<tr>
<td>vector<t> v2(v1)</t></td>
<td>v2中包含有v1所有元素的副本</td>
</tr>
<tr>
<td>vector<t> v2 = v1</t></td>
<td>等价于v2(v1)</td>
</tr>
<tr>
<td>vector<t> v3(n, val)</t></td>
<td>v3包含了n个重复的元素，每个元素的值都是val</td>
</tr>
<tr>
<td>vector<t> v4(n)</t></td>
<td>v4包含了n个重复的执行了值初始化的对象</td>
</tr>
<tr>
<td>vector<t> v5{a, b, c…}</t></td>
<td>v5包含了初始值个数的元素，每个元素都被赋予相应的初始值</td>
</tr>
<tr>
<td>vector<t> v5 = {a, b, c…}</t></td>
<td>等价于v5{a, b, c…}</td>
</tr>
</tbody>
</table>
<h4 id="列表初始化vector对象："><a href="#列表初始化vector对象：" class="headerlink" title="列表初始化vector对象："></a>列表初始化vector对象：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; articles = &#123;“a”, “an”, “the”&#125;; <span class="comment">//花括号</span></span><br></pre></td></tr></table></figure>
<h4 id="创建指定元素的数量："><a href="#创建指定元素的数量：" class="headerlink" title="创建指定元素的数量："></a>创建指定元素的数量：</h4><p>用vector对象容纳的<strong>元素数量</strong>，和<strong>元素统一初始值</strong>来初始化vector。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec(<span class="number">10</span>, <span class="number">-1</span>); 		<span class="comment">//10个int类型的元素，值都为-1</span></span><br></pre></td></tr></table></figure>
<h4 id="值初始化："><a href="#值初始化：" class="headerlink" title="值初始化："></a>值初始化：</h4><p>通常情况下，我们可以只提供vector元素的数量。那么库会创建一个<strong>值初始化</strong>的元素初值，由vector对象的类型决定。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec(<span class="number">10</span>);		<span class="comment">//10个元素都是0</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; svec(<span class="number">10</span>);	<span class="comment">//10个每个都是空的string对象</span></span><br></pre></td></tr></table></figure>
<p>这种初始化有两个限制：</p>
<ul>
<li>其一，有些类要求明确必须提供初始值(2.2.1)。</li>
<li>其二，只提供元素的数量而没有设定初始值只能用直接初始化,而不是拷贝初始化。</li>
</ul>
<h4 id="初始化的圆括号-，与花括号"><a href="#初始化的圆括号-，与花括号" class="headerlink" title="初始化的圆括号()，与花括号{}"></a>初始化的圆括号()，与花括号{}</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1(<span class="number">10</span>);		<span class="comment">//v1有10个元素，每个都是0 </span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2&#123;<span class="number">10</span>&#125;;		<span class="comment">//v2有1个元素是10  </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v3(<span class="number">10</span>, <span class="number">1</span>)	<span class="comment">//v3 10个元素每个是1</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v4&#123;<span class="number">10</span>,<span class="number">1</span>&#125; 	<span class="comment">//v3 有个2个元素。10和1</span></span><br></pre></td></tr></table></figure>
<p> 可以说：</p>
<ol>
<li>如果用的是圆括号，可以说提供的值是用来构造vector对象。</li>
<li>如果是用花括号，首先是表述为想用列表初始化该vector对象，除非当提供的值无法进行列表初始化，那么它会考虑其他初始化方式，比如下列：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; svec&#123;<span class="number">10</span>, “hi”&#125;;		<span class="comment">//花括号，会初始化为10个”hi”</span></span><br></pre></td></tr></table></figure>
<p>上述代码可以看出，int值无法初始化string对象，所以当编译器确定了无法执行列表初始化后，会尝试用默认值初始化vector对象。</p>
<h3 id="vector的操作："><a href="#vector的操作：" class="headerlink" title="vector的操作："></a>vector的操作：</h3><p><strong>vector支持的操作：</strong></p>
<table>
<thead>
<tr>
<th>v.empty()</th>
<th>如果v中不含有元素，返回真；否则返回假</th>
</tr>
</thead>
<tbody>
<tr>
<td>v.size()</td>
<td>返回v中元素的个数</td>
</tr>
<tr>
<td>v.push_back(t)</td>
<td>向v的尾端添加一个值为t的元素</td>
</tr>
<tr>
<td>v[n]</td>
<td>返回v中第n个位置上元素的引用</td>
</tr>
<tr>
<td>v1 = v2</td>
<td>用v2中元素拷贝替换v1中元素</td>
</tr>
<tr>
<td>v1 = {a, b, c…}</td>
<td>用列表中元素拷贝替换v1中元素</td>
</tr>
<tr>
<td>v1 == v2、 v1 != v2</td>
<td>v1和v2相等 当且仅当 它们的元素数量相同且对应位置元素值相同</td>
</tr>
<tr>
<td>&lt;, &lt;=, &gt;, &gt;=</td>
<td>以字典顺序比较</td>
</tr>
</tbody>
</table>
<h4 id="v-size-："><a href="#v-size-：" class="headerlink" title="v.size()："></a>v.size()：</h4><p>类似string类，v.size()返回的是 <strong>vector<t>::size_type</t></strong>类型</p>
<h4 id="vector不能用下标形式添加元素："><a href="#vector不能用下标形式添加元素：" class="headerlink" title="vector不能用下标形式添加元素："></a><strong>vector不能用下标形式添加元素：</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec;		<span class="comment">//空vector</span></span><br><span class="line">ivec[<span class="number">0</span>] = <span class="number">1</span>;			<span class="comment">//错误，ivec不包含任何元素</span></span><br></pre></td></tr></table></figure>
<p>空的vector不包含任何元素，自然不能用下标访问不存在的元素，正确的方法是用push_back。 否则会造成缓冲区溢出(buffer overflow)</p>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">HuaRongxie</p>
              <p class="site-description motion-element" itemprop="description">默而识之，学而不厌，诲人不倦，何有于我哉？</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">25</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">34</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">HuaRongxie</span>

  
</div>


 



  



 




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>