<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="默而识之，学而不厌，诲人不倦，何有于我哉？">
<meta property="og:type" content="website">
<meta property="og:title" content="HuaRongxie&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="HuaRongxie&#39;s Blog">
<meta property="og:description" content="默而识之，学而不厌，诲人不倦，何有于我哉？">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="HuaRongxie&#39;s Blog">
<meta name="twitter:description" content="默而识之，学而不厌，诲人不倦，何有于我哉？">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>HuaRongxie's Blog</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">HuaRongxie's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/01/expression-operate/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HuaRongxie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HuaRongxie's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/01/expression-operate/" itemprop="url">expression-operate</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-01T19:57:07+08:00">
                2019-03-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/C-Primer笔记/" itemprop="url" rel="index">
                    <span itemprop="name">C++Primer笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="表达式与运算符-附表"><a href="#表达式与运算符-附表" class="headerlink" title="表达式与运算符(附表)"></a>表达式与运算符(附表)</h1><p>表达式由一个或多个运算对象组成，对表达式求值将得到一个结果。</p>
<p><strong>字面值</strong>和<strong>变量</strong>是最简单的表达式，其结果就是它们的值。</p>
<p>把一个运算符和一个或多个运算对象组合起来可以生成较复杂的表达式。</p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>c++定义了一元运算符和二元运算符，作用于一个运算对象的运算符是一元比如说取地址符(&amp;)和解引用符(*)。</p>
<p>作用于两个对象的是二元比如乘法运算符(*)。</p>
<p>此外还有作用于三个运算对象的三元运算符。</p>
<p>函数调用也是一种特殊的运算符，它对运算对象的数量没有限制。</p>
<h4 id="组合运算符和运算对象"><a href="#组合运算符和运算对象" class="headerlink" title="组合运算符和运算对象"></a>组合运算符和运算对象</h4><p><strong>对于含有多个运算符和运算对象的复杂表达式来说，得先理解运算符的优先级、结合律以及求值顺序</strong>。</p>
<h4 id="运算对象转换"><a href="#运算对象转换" class="headerlink" title="运算对象转换"></a>运算对象转换</h4><p>在表达时求值中，运算对象常常由一种类型转换成另一种类型。例如：</p>
<p>整数和浮点数能互相转换，而通常小整数(bool、char、short等)会被提升成较大的整数类型，主要是int。更多了解——<strong><a href="../type-conversion.md">类型转换</a></strong></p>
<h4 id="重载运算符"><a href="#重载运算符" class="headerlink" title="重载运算符"></a>重载运算符</h4><p>当运算符作用于类类型的对象时用户可以自行定义其含义。称之为重载运算符，比如IO库的&gt;&gt;和&lt;&lt;运算符以及string、vector对象和迭代器使用的运算符都是。</p>
<p>重载运算符时，其包括运算对象的类型和返回值的类型，都是由该运算符定义的；<strong>但是运算对象的个数、运算符的优先级和结合律都是无法改变的</strong>。</p>
<h4 id="求值顺序"><a href="#求值顺序" class="headerlink" title="求值顺序"></a>求值顺序</h4><p>优先级规定了运算对象的组合方式，但是没有说明运算对象按照什么顺序求值。在大多数情况下不会明确求值顺序。对于如下表达式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = f1() * f2();</span><br></pre></td></tr></table></figure>
<p>我们不知道f1()和f2()哪个先调用。</p>
<p>对于那些没有指定执行顺序的运算符来说，如果表达式指向了同一个对象，将会引发错误并产生未定义的行为。例如&lt;&lt;:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; i &lt;&lt; “ ”&lt;&lt; ++i &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>我们不知道是先++i还是先输出i再++。编译器可能先求++i的值那么结果是1 1，也可能先输出i那么结果是0 1。因为此表达式的行为不可预知，因此编译器生成什么样的代码程序都是错误的。</p>
<p><strong>但是有四种运算符明确规定了运算对象的求值顺序。 逻辑与(&amp;&amp;)、逻辑或(||)、条件(?:)、逗号(,)。</strong></p>
<h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p><img src="/2019/03/01/expression-operate/C:/Users/pjn/Desktop/expression-operate/arithmetic.png" alt=""></p>
<p>按照运算符的优先级分组，一元运算符最高。上面所有运算符都满足左结合律。</p>
<p>取余：如果m和n是整数且n非0，则表达式(m/n)*n+m%n的求值结果与m相等:</p>
<p>m%(-n) 就是 m%n、 -m%n 就是-(m%n)。</p>
<h4 id="逻辑-和-关系运算符"><a href="#逻辑-和-关系运算符" class="headerlink" title="逻辑 和 关系运算符"></a>逻辑 和 关系运算符</h4><p><img src="/2019/03/01/expression-operate/C:/Users/pjn/Desktop/expression-operate/logic.png" alt=""></p>
<p>逻辑与(&amp;&amp;)：当且仅当两个运算对象都为真适才为真；逻辑或(||)：只要有一个为真结果就为真。</p>
<p>逻辑与和逻辑或都是先算左边运算对象值，如果无法确定表达式结果才算右侧运算对象的值。—称为短路求值</p>
<ul>
<li>对于逻辑与(&amp;&amp;)运算符来说，当且仅当左侧运算对象为真时才对右侧对象求值</li>
<li>对于逻辑或(||)运算符来说，当且仅当左侧运算对象为假时才对右侧对象求值</li>
</ul>
<h4 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h4><p><strong>赋值运算符的左侧对象必须是一个可修改的左值(更多了解——<a href="">左值与右值</a>)。</strong></p>
<p>下面的赋值语句都是非法的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>,k=<span class="number">0</span>; 			<span class="comment">//初始化非赋值</span></span><br><span class="line"><span class="number">1024</span> = k;					<span class="comment">//错误：字面值是右值</span></span><br><span class="line">(<span class="keyword">const</span>类型)ci = k;		   <span class="comment">//错误：ci是常量不可修改的左值</span></span><br></pre></td></tr></table></figure>
<p>也允许用花括号括起来的初始值列表来赋值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">k=&#123;<span class="number">3.14</span>&#125;					<span class="comment">//错误：窄化转换</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line">vi = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;	<span class="comment">//vi现在有10个元素了</span></span><br></pre></td></tr></table></figure>
<p><strong>赋值运算满足右结合律:</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line">a = b = <span class="number">0</span>;					<span class="comment">//正确：都被赋值为0</span></span><br></pre></td></tr></table></figure>
<p>对于多重赋值运算，必须是可以由右边对象的类型转换得到：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ival, *pval;</span><br><span class="line">ival = pval = <span class="number">0</span>; 			<span class="comment">//错误：不能把指针的值赋给int</span></span><br></pre></td></tr></table></figure>
<h4 id="递增和递减运算符-–"><a href="#递增和递减运算符-–" class="headerlink" title="递增和递减运算符(++/–)"></a>递增和递减运算符(++/–)</h4><p>递增和递减运算符有两种形式：前置版本和后置版本。</p>
<p>这两种运算符必须作用于左值运算对象。</p>
<p>前置版本将运算对象加减1然后将<strong>改变后的运算对象</strong>作为求值结果(左值)，而后置版本则返回运算对象<strong>改变之前的值</strong>的副本(右值)。</p>
<p><strong><u>建议</u></strong>：使用前置版本可以避免了拷贝对象的额外开销。</p>
<p>例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span>&lt;&lt;*iter++&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>由于递增运算符高于解引用运算符，所以上述代码等于*(iter++)。先将iter的值加1但是返回的是iter原来的值。等同于：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span>&lt;&lt;*iter&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">++iter;</span><br></pre></td></tr></table></figure>
<p>如果使用的是++iter 那么是先将iter+1再参与运算。</p>
<p><strong>运算对象可按任意顺序求值：</strong></p>
<p>一般情况没影响。然而如果一条子表达式改变了某个运算对象的值，另一条子表达式又要用该值的话，那就要提防在复合表达式中错用这两个运算符。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it = s.begin();it!=s.end()&amp;&amp;!<span class="built_in">isspace</span>(*it);++it)&#123;</span><br><span class="line">	*it = <span class="built_in">toupper</span>(*it);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果将上述代码改为下面这条，则会有问题：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(it!=s.end()&amp;&amp;!<span class="built_in">isspace</span>(*it))&#123;</span><br><span class="line">	*it = <span class="built_in">toupper</span>(*it++);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这将产生未定义的行为，问题在于：赋值运算左右两端的运算对象都用到了it，并且右侧运算对象还改变了it的值，编译器可能按照任意一种思路处理该表达式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*it = <span class="built_in">toupper</span>(*it);			<span class="comment">//如果先求左侧的值</span></span><br><span class="line">*(it+<span class="number">1</span>) = <span class="built_in">toupper</span>(*it);		<span class="comment">//如果先求右侧的值</span></span><br></pre></td></tr></table></figure>
<h4 id="成员访问运算符"><a href="#成员访问运算符" class="headerlink" title="成员访问运算符"></a><strong>成员访问运算符</strong></h4><p>点运算符(.) 和 箭头运算符(-&gt;)都可以用于访问成员，其中点运算符是获取类对象的一个成员；箭头运算符和点运算符有关  :  <strong>prt-&gt;mem</strong> 等价于 <strong>(*ptr).mem</strong>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s1 = “a <span class="built_in">string</span>”, *p=&amp;s1;</span><br><span class="line"><span class="keyword">auto</span> n = s1.size();</span><br><span class="line">n = (*p).size();		<span class="comment">//运行p所指对象的size成员</span></span><br><span class="line">n = p-&gt;size();			<span class="comment">//等价于(*p).size()</span></span><br></pre></td></tr></table></figure>
<p>点运算符优先于解引用运算符，所以当*p.size()需要括号 (*p).size。</p>
<p>箭头运算符作用于一个指针类型的运算对象，结果是一个左值。</p>
<p>点运算符分情况：如果成员所属的对象是左值，那么结果是左值；反之，结果是右值。</p>
<h4 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符(?:)"></a>条件运算符(?:)</h4><p>条件运算符允许我们把简单的if-else逻辑嵌入到单个表达式中，条件运算符按照如下形式使用：</p>
<p>cond? expr1 : expr2;</p>
<p>cond是判断条件的表达式，而expr1和expr2是两个类型相同或可能转换为某个公共类型的表达式。当这两个表达式都是左值或者能转换成同一种左值类型时，运算的结果是左值；否则运算的结果是右值。</p>
<p>例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> finalgrade = (grade&lt;<span class="number">60</span>) ?<span class="string">"fail"</span> : <span class="string">"pass"</span>;</span><br></pre></td></tr></table></figure>
<p>条件运算符的优先级很低，比cout还低，所以最好加括号。</p>
<h4 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h4><p><img src="/2019/03/01/expression-operate/C:/Users/pjn/Desktop/expression-operate/bit.png" alt=""></p>
<p><strong>移位运算符(&lt;&lt; 、&gt;&gt;)：</strong></p>
<p>一般来说，运算对象是小整型会被提升成大整型，左移运算符在右侧插入值为0的二进制位。右移行为依赖左侧运算对象的类型:如果对象是无符号类型，在左侧插入0；如果带符号，在左侧插入符号位的副本或值为0的二进制位。</p>
<p>移位超出的直接被舍弃。</p>
<p><strong>位与、位或、异或：</strong></p>
<p>位与运算符(&amp;): 两个对象都为1则结果为1，否则为0</p>
<p>位或运算符(|): 其中有一个对象为1则结果就为1，否则为0</p>
<p>异或运算符(^): 有且只有一个对象为1，这结果为1，否则为0</p>
<p>例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">quizl |= <span class="number">1U</span>L &lt;&lt; <span class="number">27</span>；				<span class="comment">//第27个人的值赋为1</span></span><br><span class="line">quizl &amp;= `(<span class="number">1U</span>L&lt;&lt;<span class="number">27</span>);			<span class="comment">//除了27别的值都不变</span></span><br><span class="line"><span class="keyword">bool</span> status = quizl&amp;(<span class="number">1U</span>L&lt;&lt;<span class="number">27</span>);  <span class="comment">//然后返回的值是0或者1，那么可以用bool接收</span></span><br></pre></td></tr></table></figure>
<h4 id="sizeof运算符"><a href="#sizeof运算符" class="headerlink" title="sizeof运算符"></a>sizeof运算符</h4><p>sizeof运算符返回一条表达式或一个类型名字所占的字节数。满足右结合律，返回size_t类型的常量表达式。运算符的运算对象有两种表达形式：</p>
<p>sizeof (type)</p>
<p>sizeof expr            </p>
<p>第二种形式中，返回表达式结果 类型的大小。sizeof并不实际计算其运算对象的值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Sales_data data, *p;</span><br><span class="line"><span class="keyword">sizeof</span>(Sales_data);		<span class="comment">//Sales_data类型的对象所占空间的大小</span></span><br><span class="line"><span class="keyword">sizeof</span> data;			<span class="comment">//同上</span></span><br><span class="line"><span class="keyword">sizeof</span> p;				<span class="comment">//指针所占空间的大小</span></span><br><span class="line"><span class="keyword">sizeof</span> *p;				<span class="comment">//p所指类型空间大小，也就是Sales_data</span></span><br></pre></td></tr></table></figure>
<p>sizeof运算符的结果部分的依赖于其作用的类型：</p>
<ul>
<li>对char或者类型为char的表达式执行sizeof运算，结果得1</li>
<li>对引用类型执行sizeof运算得到被引用对象所占空间的大小</li>
<li>对指针执行sizeof运算得到指针指向的对象所占空间的大小</li>
<li>对解引用指针执行sizeof运算得到指针指向的对象所占空间大小，指针不需有效</li>
<li>对数组执行sizeof运算得到整个数组所占空间的大小。</li>
<li>对string或vector执行sizeof运算只会得到固定类型的大小，不会计算元素所占空间大小。</li>
</ul>
<h4 id="逗号运算符"><a href="#逗号运算符" class="headerlink" title="逗号运算符"></a>逗号运算符</h4><p>含有两个运算对象，求值左侧表达式然后将结果丢掉，真正结果是右侧表达式，如果值是左值那结果也是左值。</p>
<h3 id="运算符优先级表"><a href="#运算符优先级表" class="headerlink" title="运算符优先级表"></a>运算符优先级表</h3><table>
<thead>
<tr>
<th>结合律</th>
<th>运算符</th>
<th>功能</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>左</td>
<td>::</td>
<td>全局作用域</td>
<td>::name</td>
</tr>
<tr>
<td>左</td>
<td>::</td>
<td>类作用域</td>
<td>class::name</td>
</tr>
<tr>
<td>左</td>
<td>::</td>
<td>命名空间作用域</td>
<td>namespace::name</td>
</tr>
<tr>
<td>左</td>
<td>.</td>
<td>成员选择</td>
<td>object.member</td>
</tr>
<tr>
<td>左</td>
<td>-&gt;</td>
<td>成员选择</td>
<td>point-&gt;member</td>
</tr>
<tr>
<td>左</td>
<td>[]</td>
<td>下标</td>
<td>expr[expr]</td>
</tr>
<tr>
<td>左</td>
<td>()</td>
<td>函数调用</td>
<td>name(expr_list)</td>
</tr>
<tr>
<td>左</td>
<td>()</td>
<td>类型构造</td>
<td>type(expr_list)</td>
</tr>
<tr>
<td>右</td>
<td>++</td>
<td>后置递增运算</td>
<td>lvalue++</td>
</tr>
<tr>
<td>右</td>
<td>–</td>
<td>后置递减运算</td>
<td>lvalue–</td>
</tr>
<tr>
<td>右</td>
<td>typeid</td>
<td>类型ID</td>
<td>typeid(type)</td>
</tr>
<tr>
<td>右</td>
<td>typeid</td>
<td>运行时类型ID</td>
<td>typeid(expr)</td>
</tr>
<tr>
<td>右</td>
<td>explicit cast</td>
<td>类型转换</td>
<td>cast_name&lt; type&gt;(expr)</td>
</tr>
<tr>
<td>右</td>
<td>++</td>
<td>前置递增运算</td>
<td>++lvalue</td>
</tr>
<tr>
<td>右</td>
<td>–</td>
<td>前置递减运算</td>
<td>–lvalue</td>
</tr>
<tr>
<td>右</td>
<td>~</td>
<td>位求反</td>
<td>~expr</td>
</tr>
<tr>
<td>右</td>
<td>!</td>
<td>逻辑非</td>
<td>!expr</td>
</tr>
<tr>
<td>右</td>
<td>-</td>
<td>一元负号</td>
<td>-expr</td>
</tr>
<tr>
<td>右</td>
<td>+</td>
<td>一元正号</td>
<td>+expr</td>
</tr>
<tr>
<td>右</td>
<td>*</td>
<td>解引用</td>
<td>*expr</td>
</tr>
<tr>
<td>右</td>
<td>&amp;</td>
<td>取地址</td>
<td>&amp;expr</td>
</tr>
<tr>
<td>右</td>
<td>()</td>
<td>类型转换</td>
<td>(type)expr</td>
</tr>
<tr>
<td>右</td>
<td>sizeof</td>
<td>对象大小</td>
<td>sizeof expr</td>
</tr>
<tr>
<td>右</td>
<td>sizeof</td>
<td>类型的大小</td>
<td>sizeof（type)</td>
</tr>
<tr>
<td>右</td>
<td>Sizeof…</td>
<td>参数包的大小</td>
<td>sizeof…(name)</td>
</tr>
<tr>
<td>右</td>
<td>new</td>
<td>创建对象</td>
<td>new type</td>
</tr>
<tr>
<td>右</td>
<td>new[]</td>
<td>创建数组</td>
<td>new type[size]</td>
</tr>
<tr>
<td>右</td>
<td>delete</td>
<td>释放对象</td>
<td>delete expr</td>
</tr>
<tr>
<td>右</td>
<td>delete[]</td>
<td>释放数组</td>
<td>delete[] expr</td>
</tr>
<tr>
<td>右</td>
<td>noexcept</td>
<td>能否抛出异常</td>
<td>noexcept (expr)</td>
</tr>
<tr>
<td>左</td>
<td>-&gt;*</td>
<td>指向成员选择的指针</td>
<td>ptr-&gt;*ptr_to_member</td>
</tr>
<tr>
<td>左</td>
<td>.*</td>
<td>指向成员选择的指针</td>
<td>obj.*ptr_to_member</td>
</tr>
<tr>
<td>左</td>
<td>*</td>
<td>乘法</td>
<td>expr*expr</td>
</tr>
<tr>
<td>左</td>
<td>/</td>
<td>除法</td>
<td>expr/expr</td>
</tr>
<tr>
<td>左</td>
<td>%</td>
<td>取模(取余)</td>
<td>expr%expr</td>
</tr>
<tr>
<td>左</td>
<td>+</td>
<td>加法</td>
<td>expr+expr</td>
</tr>
<tr>
<td>左</td>
<td>-</td>
<td>减法</td>
<td>expr-expr</td>
</tr>
<tr>
<td>左</td>
<td>&lt;&lt;</td>
<td>向左移位</td>
<td>expr&lt;&lt;expr</td>
</tr>
<tr>
<td>左</td>
<td>&gt;&gt;</td>
<td>向右移位</td>
<td>expr&gt;&gt;expr</td>
</tr>
<tr>
<td>左</td>
<td>&lt;</td>
<td>小于</td>
<td>expr&lt;expr</td>
</tr>
<tr>
<td>左</td>
<td>&lt;=</td>
<td>小于等于</td>
<td>expr&lt;=expr</td>
</tr>
<tr>
<td>左</td>
<td>&gt;</td>
<td>大于</td>
<td>expr&gt;expr</td>
</tr>
<tr>
<td>左</td>
<td>&gt;=</td>
<td>大于等于</td>
<td>expr&gt;=expr</td>
</tr>
<tr>
<td>左</td>
<td>==</td>
<td>相等</td>
<td>expr==expr</td>
</tr>
<tr>
<td>左</td>
<td>!=</td>
<td>不相等</td>
<td>expr!=expr</td>
</tr>
<tr>
<td>左</td>
<td>&amp;</td>
<td>位与</td>
<td>expr&amp;expr</td>
</tr>
<tr>
<td>左</td>
<td>^</td>
<td>位异或</td>
<td>expr^expr</td>
</tr>
<tr>
<td>左</td>
<td>\</td>
<td></td>
<td>位或</td>
<td>expr\</td>
<td>expr</td>
</tr>
<tr>
<td>左</td>
<td>&amp;&amp;</td>
<td>逻辑与</td>
<td>expr&amp;&amp;expr</td>
</tr>
<tr>
<td>左</td>
<td>\</td>
<td>\</td>
<td></td>
<td>逻辑或</td>
<td>expr\</td>
<td>\</td>
<td>expr</td>
</tr>
<tr>
<td>左</td>
<td>?:</td>
<td>条件</td>
<td>expr ? expr : expr</td>
</tr>
<tr>
<td>右</td>
<td>=</td>
<td>赋值</td>
<td>lvalue=expr</td>
</tr>
<tr>
<td>右</td>
<td>*=, /=, %=</td>
<td>复合赋值</td>
<td>lvalue += expr等</td>
</tr>
<tr>
<td>右</td>
<td>+=, -=</td>
<td></td>
<td></td>
</tr>
<tr>
<td>右</td>
<td>&lt;&lt;=, &gt;&gt;=</td>
<td></td>
<td></td>
</tr>
<tr>
<td>右</td>
<td>&amp;=, \</td>
<td>=, ^=</td>
<td></td>
<td></td>
</tr>
<tr>
<td>右</td>
<td>throw</td>
<td>抛出异常</td>
<td>throw</td>
</tr>
<tr>
<td>右</td>
<td>,</td>
<td>逗号</td>
<td>expr , expr</td>
</tr>
</tbody>
</table>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/27/io/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HuaRongxie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HuaRongxie's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/27/io/" itemprop="url">IO(流)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-27T21:04:42+08:00">
                2019-02-27
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/C-Primer笔记/" itemprop="url" rel="index">
                    <span itemprop="name">C++Primer笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>ps：先是简单的介绍一下IO类、文件的输入输出以及string流。看到之后章节再记录拓展~</p>
<h1 id="IO库"><a href="#IO库" class="headerlink" title="IO库"></a>IO库</h1><h3 id="基本介绍："><a href="#基本介绍：" class="headerlink" title="基本介绍："></a>基本介绍：</h3><h4 id="include："><a href="#include：" class="headerlink" title="#include："></a><strong>#include：</strong></h4><p>#include指令用于添加头文件。通常情况下，它必须出现现在所有函数之外。一般将他放在源文件最开始的位置。</p>
<ul>
<li>#include &lt;&gt;:尖括号用于添加<strong>标准库头文件</strong></li>
<li>#include “”:双引号用于添加<strong>自己定义</strong>的头文件</li>
</ul>
<h4 id="lt-lt-、-gt-gt-左侧、右侧运算符"><a href="#lt-lt-、-gt-gt-左侧、右侧运算符" class="headerlink" title="&lt;&lt;、&gt;&gt;左侧、右侧运算符:"></a><strong>&lt;&lt;、&gt;&gt;左侧、右侧运算符:</strong></h4><p>&lt;&lt;左侧的对象必须是一个ostream对象，返回一个ostream对象。&gt;&gt;左侧的对象必须是一个istream对象，返回一个istream对象。</p>
<h4 id=""><a href="#" class="headerlink" title="::"></a><strong>::</strong></h4><p>作用域运算符::用来表示某个作用域。</p>
<h4 id="部分IO库设施："><a href="#部分IO库设施：" class="headerlink" title="部分IO库设施："></a>部分IO库设施：</h4><table>
<thead>
<tr>
<th>istream(输入流)</th>
<th>提供输入操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>ostream(输出流)</td>
<td>提供输出操作</td>
</tr>
<tr>
<td>cin</td>
<td>从标准输入读取数据</td>
</tr>
<tr>
<td>cout</td>
<td>从标准输出写入数据</td>
</tr>
<tr>
<td>cerr</td>
<td>通常用于输出程序错误信息，写入到标准错误</td>
</tr>
<tr>
<td>运算符&gt;&gt;</td>
<td>用来从一个istream对象读取输入数据</td>
</tr>
<tr>
<td>运算符&lt;&lt;</td>
<td>用来从一个ostream对象写入输出数据</td>
</tr>
<tr>
<td>getline函数</td>
<td>从一个给定的istream读取一行数据存入一个给定的string对象中</td>
</tr>
</tbody>
</table>
<h3 id="IO类"><a href="#IO类" class="headerlink" title="IO类"></a>IO类</h3><p>为了继承不同种类的IO操作，标准库还定义了其他一些IO类型。分别定义在三个头文件中：</p>
<ol>
<li>iostream定义了用于读写流的基本类型。<ol>
<li>istream、wistream从流读取数据</li>
<li>ostream、wostream向流写入数据</li>
<li>iostream、wiostream读写流</li>
</ol>
</li>
<li><p>fstream定义了读写命名文件的类型</p>
<ol>
<li>ifstream、wifstream从文件读取数据</li>
<li>ofstream、wofstream向文件写入数据</li>
<li>iofstream、wiofstream读写文件</li>
</ol>
</li>
<li><p>sstream定义了读写内存string对象的类型</p>
<ol>
<li>istringstream、wistringstream从string读取数据</li>
<li>ostringstream、wostringstream向string写入数据</li>
<li>iostringstream、wiostringstream读写string</li>
</ol>
</li>
</ol>
<p>以上w开头是为了支持宽字符w_char类型的数据。wcin、wcout、wcerr对应cin、cout、cerr等等。</p>
<p><strong>而fstream和sstream都是继承iostream的</strong></p>
<h4 id="IO对象无法拷贝或赋值"><a href="#IO对象无法拷贝或赋值" class="headerlink" title="IO对象无法拷贝或赋值"></a>IO对象无法拷贝或赋值</h4><p>IO对象无法拷贝，因此不能将形参或者返回值定为流类型，但是可以定义为流的引用类型。</p>
<h4 id="流的条件状态"><a href="#流的条件状态" class="headerlink" title="流的条件状态"></a>流的条件状态</h4><p>IO操作有可能发生错误。有些是可以恢复的而有些是不可恢复的，因此下表列出了一些<strong>函数和标志</strong>来帮助我们访问和操纵 流的<strong>条件状态(condition state)</strong>：下表中strm是表示一种流类型(上表所列出的)，s表示一个流</p>
<table>
<thead>
<tr>
<th>strm:iostate</th>
<th>iostate是一种机器相关的类型，提供了表达条件状态的完整功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>strm:badbit</td>
<td>用来指出流已崩溃/第四位</td>
</tr>
<tr>
<td>strm:failbit</td>
<td>用来指出一个IO操作失败/第三位</td>
</tr>
<tr>
<td>strm:eofbit</td>
<td>用来指出流到达了文件结束/第二位</td>
</tr>
<tr>
<td>strm:goodbit</td>
<td>用来指出流未处于错误状态/第1位(从右往左)</td>
</tr>
<tr>
<td>s.eof()</td>
<td>若流s的eofbit置位，则返回true</td>
</tr>
<tr>
<td>s.fail()</td>
<td>若failbit或badbit置位，则返回true</td>
</tr>
<tr>
<td>s.bad()</td>
<td>若badbit置位，返回true</td>
</tr>
<tr>
<td>s.good()</td>
<td>若s处于有效状态，则返回true</td>
</tr>
<tr>
<td>s.clear()</td>
<td>将流s中所有条件状态复位，将流状态置为有效。返回void</td>
</tr>
<tr>
<td>s.clear(flags)</td>
<td>根据给定flags标志位，将流s中对应状态置为有效。flags类型为strm::iostate，返回void</td>
</tr>
<tr>
<td>s.setstate(flags)</td>
<td>根据给定flags标志位，将流s中对应状态置位。flags类型为strm::iostate，返回void</td>
</tr>
<tr>
<td>s.rdstate()</td>
<td>返回流s的当前条件状态，返回类型为iostate</td>
</tr>
</tbody>
</table>
<p>例：如果在一个int类型中输入字符时，读操作就会失败。类似的输入一个文件结束符时。cin也会进入错误状态。</p>
<h4 id="查询流的状态"><a href="#查询流的状态" class="headerlink" title="查询流的状态"></a>查询流的状态</h4><p><strong>标准库定义的类型：</strong></p>
<p>上表中定义了4个iostate类型的constexpr值，表示特定的位模式。意思就是每一个值用一位二进制来表示，例如他们初始值为1110，右边第一位表示goodbit，第二位是eofbit…</p>
<p>badbit：表示系统级错误，不可恢复。</p>
<p>failbit：表示可以恢复的错误，例如期望读取int类型却读出了字符等错误。流可以被修正，能继续使用。</p>
<p>eofbit：如果达到文件结尾，eofbit和failbit都会被置位</p>
<p>goodbit：值为0表示流未发生错误</p>
<p>如果badbit、failbit、eofbit三个其中一个发生错误，则流检测状态的条件会失败。</p>
<p><strong>标准库定义的函数：</strong></p>
<p>good():在所有错误未置位的情况下返回true</p>
<p>bad、fail、eof 则在对应类型被置位下返回true。</p>
<p>此外在badbit被置位时fail也会返回true。因此使用good或fail是确定流总体状态的正确方法。实际上我们用的<strong>条件while(cin)就等于!fail()</strong></p>
<h4 id="管理条件状态"><a href="#管理条件状态" class="headerlink" title="管理条件状态"></a>管理条件状态</h4><p>clear() :将所有状态复位。</p>
<p>clear(flags)：将指定状态复位。flags是iostate类型。<strong>例：</strong></p>
<p>​    初始值1110.加入产生了错误导致failbit和badbit置位，iostate变成0010.如果想单独将failbit置位那么就需要传入0110。这时代码可写成clear(s.rdstate() &amp; ~s.failbit)</p>
<h4 id="管理输出缓冲"><a href="#管理输出缓冲" class="headerlink" title="管理输出缓冲"></a>管理输出缓冲</h4><p>每个输出流都管理一个缓冲区，用来保存程序读写的数据。有了缓冲机制，操作系统就可以将程序的多个输出操作组合成单一的系统级写操作。提升很大的性能。</p>
<p><strong>导致缓冲刷新的原因：</strong></p>
<ul>
<li>程序正常结束，作为main的return操作的一部分，缓冲刷新</li>
<li>缓冲区满的时候</li>
<li>可以使用操纵符endl来显式刷新</li>
<li>在每个输出操作之后，用操纵符unitbuf设置流的内部状态，来清空缓冲区。默认情况对cerr是设置unitbuf的。</li>
<li>一个输出流可以被关联到另一个流。在这种情况下，当读写被关联的流时，关联到的流缓冲区会被刷新。例如：cin和cerr都关联到cout。因此读cin或写cerr都会导致cout缓冲区被刷新。</li>
</ul>
<p><strong>刷新输出缓冲区：</strong></p>
<p>endl: 输出内容和一个换行，刷新缓冲区</p>
<p>flush:输出内容，刷新缓冲区</p>
<p>ends:出书内容和一个空字符，刷新缓冲区</p>
<p><strong>unitbuf操纵符：</strong></p>
<p>如果想每次输出后都刷新缓冲区可以使用unitbuf操纵符。它告诉流在每次写操作之后进行一次flush操作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; unitbuf;	<span class="comment">//所有输出操作后都会刷新缓冲区</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; nounitbuf;	<span class="comment">//回到正常缓冲方式</span></span><br></pre></td></tr></table></figure>
<p><strong>关联输入输出流：</strong></p>
<p>一个输出流可以被关联到另一个流。在这种情况下，当读写被关联的流时，关联到的流缓冲区会被刷新。例如：cin和cerr都关联到cout。因此读cin或写cerr都会导致cout缓冲区被刷新。</p>
<p>NOTE:交互式系统通常关联输入流与输出流。这意味这所有输出都会在写入之前打印出来。</p>
<p><strong>tie：</strong>tie函数有两个版本：</p>
<ul>
<li>一个无参版本，返回指向输出流的指针。如果本对象关联一个输出流，返回的就是这个流的指针，否则未关联则返回空指针；</li>
<li>tie的第二个版本接受一个<strong>指向ostream</strong>的指针，将自己关联到此ostream，即：x.tie(&amp;o)将流x关联到o</li>
</ul>
<p>我们可以将istream关联到ostream也可以将ostream关联到ostream。每个流只能关联一个流，但是一个流可以被多个流关联。</p>
<h3 id="文件输入输出"><a href="#文件输入输出" class="headerlink" title="文件输入输出"></a>文件输入输出</h3><p>之前有说到，头文件<strong>fstream</strong>定义了三个类型来支持文件IO：ifstream从一个给定文件读取数据；ofstream向一个给定文件写入数据； fstream能读写文件。这三个类型的操作与之前一样，能用IO运算符(&lt;&lt;和&gt;&gt;)来读写文件，可用getline()来获取行数据。</p>
<p>除了继承自iostream类型的行为之外，它还定义了新的成员来管理文件流。如下：fstream是头文件fstream中定义的一个类型</p>
<table>
<thead>
<tr>
<th>fstream fstrm;</th>
<th>创建一个未绑定的文件流</th>
</tr>
</thead>
<tbody>
<tr>
<td>fstream fstrm(s);</td>
<td>创建一个fstream并打开名为s的文件(加后缀)。s可以是string或指向c风格字符串的指针。这些构造函数都是explicit的。默认文件模式mode依赖于fstream的类型</td>
</tr>
<tr>
<td>fstream fstrm(s, mode);</td>
<td>与前一个<strong>构造函数</strong>相似，但指定了mode</td>
</tr>
<tr>
<td>fstrm.open(s)</td>
<td>打开名为s的文件，并将文件与fstrm绑定。返回void</td>
</tr>
<tr>
<td>fstrm.close()</td>
<td>关闭与fstrm绑定的文件。返回void</td>
</tr>
<tr>
<td>fstrm.is_open()</td>
<td>返回一个bool值，指出与fstrm关联的文件是否成功打开并且未关闭</td>
</tr>
</tbody>
</table>
<p>上表中前三个是构造函数，用于创建一个文件流并且可以选择<strong>是否绑定文件</strong>以及打开文件的<strong>模式</strong>。</p>
<h4 id="使用文件流对象"><a href="#使用文件流对象" class="headerlink" title="使用文件流对象"></a>使用文件流对象</h4><p><strong>创建文件流：</strong></p>
<p>我们可以先定义一个文件流并且与文件相关联，也可以只先定义一个文件流对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">in</span><span class="params">(file.txt)</span></span>;		<span class="comment">//构造一个ifstream并打开文件</span></span><br><span class="line">ofstream out;				<span class="comment">//定义一个输出文件流未关联文件</span></span><br></pre></td></tr></table></figure>
<p>文件名可以是string对象，也可以是C风格字符数组。</p>
<p><strong>函数open和close：</strong></p>
<p>如果定义了一个空文件流对象，可以随后调用open来将它与文件相关联。比如上述输出文件流out：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">out.open(<span class="string">"file.txt"</span>);		<span class="comment">//打开指定文件</span></span><br></pre></td></tr></table></figure>
<p>如果调用open失败，failbit会置位。</p>
<p><strong><u>自动构造和析构:</u></strong>如果将创建流定义在while里面，那么while的每一步都会创建与销毁文件流，当一个fstream对象被销毁的时候，会自动调用close函数。</p>
<h4 id="文件模式"><a href="#文件模式" class="headerlink" title="文件模式"></a>文件模式</h4><p>在上表中的第三个构造函数中有个mode参数，这是流关联的文件模式。在调用open打开文件时也可以，不论显示隐式 都会调用一种模式。</p>
<table>
<thead>
<tr>
<th>in</th>
<th>以读方式打开</th>
</tr>
</thead>
<tbody>
<tr>
<td>out</td>
<td>以写方式打开</td>
</tr>
<tr>
<td>app</td>
<td>每次<strong>写操作</strong>前均定位到文件末尾</td>
</tr>
<tr>
<td>ate</td>
<td>打开文件后立即定位到文件末尾</td>
</tr>
<tr>
<td>trunc</td>
<td>截断文件</td>
</tr>
<tr>
<td>binary</td>
<td>以二进制方式进行IO</td>
</tr>
</tbody>
</table>
<ul>
<li>只可以对ostream设定out模式</li>
<li>只可以对istream设定in模式</li>
<li>只有当out也被设定时才可以设定trunc模式</li>
<li>只要没有设定trunc就可以设定app模式。在app模式下没有设定out也会默认out模式。</li>
<li>默认情况下没有指定trunc，以out模式打开的文件也会被截断。如果要保留文件内容，必须指定app模式，或者同时指定in模式。</li>
<li>ate和binary模式可以用于任何类型的文件，并且能与其他模式组合使用。</li>
</ul>
<p>当不指定时，文件流使用默认的文件模式，ifstream是in模式；ofstream是out模式；fstream是in和out模式。</p>
<h4 id="以out打开会丢弃数据"><a href="#以out打开会丢弃数据" class="headerlink" title="以out打开会丢弃数据"></a>以out打开会丢弃数据</h4><p>当一个文件以out模式打开时，会被截断，文件的内容会被丢弃。阻止此行为的方法是指定app模式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ofstream <span class="title">out</span><span class="params">(<span class="string">"file.txt"</span>)</span></span>;			<span class="comment">//隐含以输出模式打开并截断</span></span><br><span class="line"><span class="function">ofstream <span class="title">out2</span><span class="params">(<span class="string">"file.txt"</span>, ofstream::out)</span></span>;		<span class="comment">//隐含截断文件</span></span><br><span class="line"><span class="function">ofstream <span class="title">out3</span><span class="params">(<span class="string">"file.txt"</span>, ofstream::out|ofstream::trunc)</span></span>;</span><br></pre></td></tr></table></figure>
<p>指定app模式则能保留文件：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ofstream <span class="title">app</span><span class="params">(<span class="string">"file.txt"</span>，ofstream::app)</span></span>;		<span class="comment">//隐含为out模式</span></span><br><span class="line"><span class="function">ofstream <span class="title">app</span><span class="params">(<span class="string">"file.txt"</span>，ofstream::out | ofstream::app)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="string流"><a href="#string流" class="headerlink" title="string流"></a>string流</h3><p>类似的，sstream头文件定义了三个类型来支持内存IO：istringstream从string读取数据，ostringstream向string写入数据，stringstream可以读写数据。sstream除了继承来的操作，还定义了一些成员来管理string流。</p>
<table>
<thead>
<tr>
<th>sstream strm;</th>
<th>sstream是头文件sstream中定义的一个类型，strm是一个未绑定的stringstream对象</th>
</tr>
</thead>
<tbody>
<tr>
<td>sstream strm(s);</td>
<td>strm是一个sstream对象，保存string s的一个拷贝。此构造函数是explicit的</td>
</tr>
<tr>
<td>strm.str();</td>
<td>返回strm所保存的string的拷贝</td>
</tr>
<tr>
<td>strm.str(s);</td>
<td>将string s拷贝到strm中。返回void</td>
</tr>
</tbody>
</table>
<h4 id="使用istringstream"><a href="#使用istringstream" class="headerlink" title="使用istringstream"></a>使用istringstream</h4><p>当我们的某些工作是对整行文本进行处理，而其他的一些工作是处理行内的某个单词时，通常能用istringstream。</p>
<p><strong>定义：</strong></p>
<p>可以将一个istringstream与string对象绑定，也可以只定义一个istringstream。然后用str(s)方法绑定</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">istringstream</span> <span class="title">in</span><span class="params">(s)</span></span>;	<span class="comment">//定义一个istringstream与string s绑定</span></span><br><span class="line"><span class="built_in">istringstream</span> in2;		<span class="comment">//定义一个未绑定的流in2</span></span><br><span class="line">in2.str(s);				<span class="comment">//将流in2与string s绑定</span></span><br></pre></td></tr></table></figure>
<p><strong>例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> line = <span class="string">"hello world"</span>, word;</span><br><span class="line"><span class="function"><span class="built_in">istringstream</span> <span class="title">in</span><span class="params">(line)</span></span>;</span><br><span class="line">in &gt;&gt; word;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; word &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<h4 id="使用ostringstream"><a href="#使用ostringstream" class="headerlink" title="使用ostringstream"></a>使用ostringstream</h4><p>当我们逐步构造输出，希望最后一起打印时，ostringstream是很有用的。</p>
<p><strong>定义：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">ostringstream</span> <span class="title">out</span><span class="params">(s)</span></span>;	<span class="comment">//定义一个ostringstream 并将s写入</span></span><br><span class="line"><span class="built_in">ostringstream</span> in2;		<span class="comment">//定义ostringstream </span></span><br><span class="line">in2.str(s);				<span class="comment">//将s写入内存中</span></span><br></pre></td></tr></table></figure>
<p><strong>例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">ostringstream</span> <span class="title">os</span><span class="params">(<span class="string">"hello world"</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; os.str();</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/23/array/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HuaRongxie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HuaRongxie's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/23/array/" itemprop="url">数组</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-23T21:15:12+08:00">
                2019-02-23
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/C-Primer笔记/" itemprop="url" rel="index">
                    <span itemprop="name">C++Primer笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>数组是一种类似于标准库类型vector的数据结构。</p>
<ul>
<li>与vector相似的是，数组也是存放类型相同的对象的容器，这些对象本身没有名字，需要通过位置访问。</li>
<li>与vector不同的是，数组的大小确定不变，不能随意向数组中增加元素。<ul>
<li>改变长度只能创建一个新数组，我们也不能像vector一样用size函数直接获取长度，char数组用strlen 而别的数组只能sizeof(array)/sizeof(array[0])</li>
</ul>
</li>
</ul>
<h3 id="定义和初始化数组"><a href="#定义和初始化数组" class="headerlink" title="定义和初始化数组"></a>定义和初始化数组</h3><h4 id="数组的定义："><a href="#数组的定义：" class="headerlink" title="数组的定义："></a>数组的定义：</h4><p>数组是一种复合类型。数组的声明形如a[d]，其中a是数组名字，d是数组的维度。</p>
<ol>
<li>维度就是个数，因此必须大于0。</li>
<li>数组中元素的个数属于数组类型的一部分，编译时是已知的。因此维度必须是一个常量表达式。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> cnt = <span class="number">42</span>;			<span class="comment">//不是常量表达式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">unsigned</span> sz = <span class="number">42</span>; <span class="comment">//是常量表达式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>];				<span class="comment">//含有10个整数的数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *parr[sz];				<span class="comment">//含有42个整型指针的数组</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> bad[cnt];			<span class="comment">//错误，cnt不是常量表达式</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> strs[get_size()];	<span class="comment">//当get_size()是constexpr时正确</span></span><br></pre></td></tr></table></figure>
<p>和内置类型的变量一样，如果在函数内部定义了某种内置类型的数组，那么默认初始化会令数组含有未定义的值。</p>
<p>必须指定数组的类型(不允许用auto由初始化列表推断)。</p>
<p>和vector一样，数组的元素应为对象，因此不存在引用的数组。</p>
<h4 id="显式初始化数组元素："><a href="#显式初始化数组元素：" class="headerlink" title="显式初始化数组元素："></a>显式初始化数组元素：</h4><p><strong>可以对数组的元素进行列表初始化，此时忽略数组维度</strong>。</p>
<ul>
<li>如果在声明时没有指明维度，编译器会根据初始值的数量计算出来</li>
<li>如果定义了维度并且比列表大，那么剩下的元素会被初始化为默认值。</li>
<li>如果定义了维度并且比列表小，那么编译错误</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> sz = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ial[sz] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;		 <span class="comment">//含有3个元素，012</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a2[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;			 <span class="comment">//同上</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a3[<span class="number">5</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;		 <span class="comment">//等价于a3[] = &#123;0,1,2,0,0&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> a4[<span class="number">3</span>] = &#123;“hi”, “bye”&#125;;<span class="comment">//等价于a4[] = &#123;“hi”, “bye”, “”&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a5[<span class="number">2</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;		 <span class="comment">//错误，维度比初始值小</span></span><br></pre></td></tr></table></figure>
<h4 id="字符数组-的特殊性："><a href="#字符数组-的特殊性：" class="headerlink" title="字符数组 的特殊性："></a>字符数组 的特殊性：</h4><p>字符数组可以用<strong>字符串字面值</strong>进行初始化。当使用这种方式一定要注意字符串字面值<strong>结尾处还有一个空字符</strong>，要预留一个空间。如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a1[] = &#123;‘c’, ‘+’, ‘+’&#125;;	<span class="comment">//列表初始化，没有空字符</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> a2[]=&#123;‘c’, ‘+’, ‘+’, ‘\<span class="number">0</span>’&#125;;<span class="comment">//显式的空字符</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> a3[] = “c++”;				<span class="comment">//自动添加表示字符串结束的空字符</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> a4[<span class="number">6</span>] = “Daniel”;	<span class="comment">//错误，没有空间放空字符</span></span><br></pre></td></tr></table></figure>
<h4 id="数组不允许拷贝和赋值："><a href="#数组不允许拷贝和赋值：" class="headerlink" title="数组不允许拷贝和赋值："></a>数组不允许拷贝和赋值：</h4><p>不能将数组的内容拷贝给其他数组作为其初始值，也不能用数组为其他数组赋值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a1[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a2[] = a1; 			<span class="comment">//错误：不允许使用一个数组初始化另一个数组</span></span><br><span class="line"></span><br><span class="line">a2 = a ;				<span class="comment">//错误，不能把一个数组直接赋值给另一个数组</span></span><br></pre></td></tr></table></figure>
<p>(某些<strong>编译器扩展</strong>可以支持数组赋值，不过最好避免)</p>
<h4 id="复杂的数组声明-数组-指针、引用等-："><a href="#复杂的数组声明-数组-指针、引用等-：" class="headerlink" title="复杂的数组声明(数组+指针、引用等)："></a>复杂的数组声明(数组+指针、引用等)：</h4><p>数组可以存放对象，就可以定义指针对象。而数组本身是一个对象，那么可以有引用和指针，如下(可从内向外再从右向左阅读)：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *ptrs[<span class="number">10</span>];				<span class="comment">//ptrs是有10个整型指针的数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> &amp;refs[<span class="number">10</span>]; 				<span class="comment">//错误，数组不能放引用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> (*Parray)[<span class="number">10</span>] = &amp;arr	<span class="comment">//Parray是一个指针，指向一个整型数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> (&amp;arrRef)[<span class="number">10</span>] = arr;	<span class="comment">//arrRef是一个引用，引用一个整型数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *(&amp;arrRef)[<span class="number">10</span>] = ptrs;	<span class="comment">//arrRef 是一个引用，指向一个含有10个int类型指针的数组</span></span><br></pre></td></tr></table></figure>
<h3 id="访问数组元素"><a href="#访问数组元素" class="headerlink" title="访问数组元素"></a>访问数组元素</h3><p>数组的访问跟vector基本类似。也可以用范围for语句或下标运算符来访问。</p>
<p>在使用下标的时候通常将其定义为<strong>size_t</strong>类型。</p>
<p>size_t 是一种机器相关的无符号类型。它的定义在<strong>cstddef</strong>头文件中。</p>
<h3 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a>指针和数组</h3><p>通常情况下，使用取地址符来获取指向某个对象的指针。数组的元素也是对象，因此对数组的元素使用取地址符就能得到指向该元素的指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> nums[] = &#123;“one”, “two”, “three”&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> *p = &amp;nums[<span class="number">0</span>]; 		<span class="comment">//p指向nums的第一个元素</span></span><br></pre></td></tr></table></figure>
<p><strong>然而数组有个特性：在很多用到数组名字的地方，编译器会自动的将其转换为一个指向数组首元素的指针。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> *p2 = nums;			<span class="comment">//等价于p2 = &amp;nums[0]</span></span><br></pre></td></tr></table></figure>
<h4 id="对数组使用auto和decltype的不同点："><a href="#对数组使用auto和decltype的不同点：" class="headerlink" title="对数组使用auto和decltype的不同点："></a>对数组使用auto和decltype的不同点：</h4><p>由上可知，在一些情况下数组的操作实际上是指针的操作：</p>
<ol>
<li>当使用一个数组作为一个auto变量的初始值时，推断出的类型是指针而非数组</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ia2</span><span class="params">(ia)</span></span>;			<span class="comment">//ia2是一个整型指针，指向ia的第一个元素，同 ia2(&amp;ia[0])</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>然而当使用decltype(ia)返回的是一个数组。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(ia) ia3 = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">ia3[<span class="number">4</span>] = i;			<span class="comment">//给ia3的第三个元素赋值</span></span><br></pre></td></tr></table></figure>
<h4 id="指针也是迭代器："><a href="#指针也是迭代器：" class="headerlink" title="指针也是迭代器："></a>指针也是迭代器：</h4><p>迭代器可用的运算 指针都能用。也可以使用指针遍历数组。</p>
<p>同时c++给了两个标准库函数取尾后指针，<strong>begin 和 end</strong>，定义在iterator头文件中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *pbeg = begin(arr);		<span class="comment">//指向arr的首元素</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *pend = end(arr);		<span class="comment">//指向尾后元素</span></span><br></pre></td></tr></table></figure>
<h4 id="解引用与指针运算交互："><a href="#解引用与指针运算交互：" class="headerlink" title="解引用与指针运算交互："></a>解引用与指针运算交互：</h4><p>迭代器有的运算操作指针都有，两个指针相减的结果类型是ptrdiff_t， 与size_t一样。</p>
<p>如果两个指针分别指向不相关的对象，则不能比较它们。</p>
<p>空指针也可以相减，值为0。</p>
<p><strong>下标和指针：</strong></p>
<p>当对数组使用下标运算符时，编译器会自动转换成指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[] = &#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> last = *(ia + <span class="number">4</span>);		<span class="comment">//正确：等同于 ia[4]</span></span><br></pre></td></tr></table></figure>
<p>从上可知，对数组下标运算其实是对指向数组元素的指针执行下标运算：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = &amp;ia[<span class="number">2</span>];	<span class="comment">//p指向索引为2的元素</span></span><br><span class="line"><span class="keyword">int</span> j = p[<span class="number">1</span>]; 		<span class="comment">//p[1]等价于*(p + 1),就是ia[3]表示的那个元素</span></span><br><span class="line"><span class="keyword">int</span> k = p[<span class="number">-2</span>]; 		<span class="comment">//p[-2]等价于*(p - 2),就是ia[0]表示的那个元素</span></span><br></pre></td></tr></table></figure>
<p>数组的下标运算与 标准库类型限定使用的下标运算有所不同。<strong>标准库类型的下标必须是无符号类型，而内置的下标则无此要求。</strong></p>
<h3 id="C风格字符串"><a href="#C风格字符串" class="headerlink" title="C风格字符串"></a>C风格字符串</h3><p>尽管c++支持c风格字符串，但还是不要使用它们。因为用起来不太方便，而且极易引发程序漏洞。</p>
<p><strong>字符串字面值</strong>是一种通用结构的实例，即是由c继承而来的c风格字符串。</p>
<p>c通常把字符串存放在字符数组中并以空字符结束(‘\0’)。一般用指针来操作这些字符串。</p>
<h4 id="C标准库string函数"><a href="#C标准库string函数" class="headerlink" title="C标准库string函数"></a>C标准库string函数</h4><p>下表函数定义在cstring头文件中。</p>
<table>
<thead>
<tr>
<th>strlen(p)</th>
<th style="text-align:left">返回p的长度，空字符不计算在内</th>
</tr>
</thead>
<tbody>
<tr>
<td>strcmp(p1, p2)</td>
<td style="text-align:left">比较p1和p2的相等性。如果p1==p2，返回0；如果p1&gt;p2,返回一个正值；返回0；如果p1&lt;p2,返回一个负值</td>
</tr>
<tr>
<td>strcat(p1, p2)</td>
<td style="text-align:left">和炮</td>
</tr>
<tr>
<td>strcpy(p1, p2)</td>
<td style="text-align:left">将p2拷贝给p1， 返回p1</td>
</tr>
</tbody>
</table>
<p><strong>上表所列的函数不负责验证字符串参数。</strong></p>
<p>传入此类函数的指针必须指向以空字符作为结束的数组：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ca[] = &#123;‘c’, ‘+’, ‘+’&#125;;		<span class="comment">//不以空字符结束</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; <span class="built_in">strlen</span>(ca) &lt;&lt;<span class="built_in">endl</span>;			<span class="comment">//严重错误：ca没有以空字符结束</span></span><br></pre></td></tr></table></figure>
<p>上面代码不是以空字符结束，它可能沿着ca在内存中的位置不断向前直到遇到空字符。</p>
<h4 id="比较字符串："><a href="#比较字符串：" class="headerlink" title="比较字符串："></a>比较字符串：</h4><p>比较两个c风格字符串的方法与标准库string对象的方法大相径庭。</p>
<p>标准库string对象的比较用的是普通关系运算符和相等性运算符，如 &lt;、==；</p>
<p>而c风格字符串，实际比较的是两个指针而不是字符串本身：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> ca1[] = “A <span class="built_in">string</span> example”;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> ca2[] = “A different <span class="built_in">string</span>”;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( ca1 &lt; ca2)&#123;&#125;;		<span class="comment">//未定义的：试图比较两个无关地址，相当于比较const char*</span></span><br></pre></td></tr></table></figure>
<p>所以上述ca1和ca2相比其实是两个const char*的值，这两个指针指向的不是一个对象，因此得到未定义的结果。</p>
<p>如果想要比较两个c风格字符串则需要调用strcmp函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(ca1, ca2) &lt; <span class="number">0</span>) <span class="comment">//相等返回0，前面大返回正值，否则负值。</span></span><br></pre></td></tr></table></figure>
<h4 id="c风格字符串的连接拷贝："><a href="#c风格字符串的连接拷贝：" class="headerlink" title="c风格字符串的连接拷贝："></a>c风格字符串的连接拷贝：</h4><p>使用strcpy 和 ctrcat函数来进行连接、拷贝，如果使用则需要提供一个用于存放结果的数组，必须足够大容纳下结果字符串以及<strong>末尾的空字符</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strcpy</span>(largeStr, ca1);		<span class="comment">//cal拷贝给largeStr</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">strcat</span>(largeStr, “ ”);</span><br><span class="line"></span><br><span class="line"><span class="built_in">strcat</span>(largeStr, ca2);		<span class="comment">//ca2连接到largeStr后面</span></span><br></pre></td></tr></table></figure>
<p>ps：在vs中使用c风格字符串的函数时，会报错。因为c库的函数内部进行参数检验，所以vs提出警告要求使用vs改写的函数。报错：</p>
<table>
<thead>
<tr>
<th>错误</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>C4996</td>
<td>‘strcpy’: This function or variable may be unsafe. Consider using strcpy_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.</td>
</tr>
</tbody>
</table>
<p>需要改写成：</p>
<table>
<thead>
<tr>
<th>老接口</th>
<th>新接口</th>
</tr>
</thead>
<tbody>
<tr>
<td>mkdir</td>
<td>_mkdir</td>
</tr>
<tr>
<td>fopen</td>
<td>fopen_s</td>
</tr>
<tr>
<td>strcmp</td>
<td>strcmp_s</td>
</tr>
<tr>
<td>strcpy</td>
<td>strcpy_s</td>
</tr>
<tr>
<td>strcat</td>
<td>strcat_s</td>
</tr>
</tbody>
</table>
<h3 id="与旧代码的接口"><a href="#与旧代码的接口" class="headerlink" title="与旧代码的接口"></a>与旧代码的接口</h3><p>很多c++程序在标准库出现之前就已经写成了，因此c++专门提供了一组功能来衔接c++程序与数组/c风格字符串的代码。</p>
<h4 id="混用string对象和C风格字符串："><a href="#混用string对象和C风格字符串：" class="headerlink" title="混用string对象和C风格字符串："></a>混用string对象和C风格字符串：</h4><p><strong>任何出现字符串字面值的地方都可以用空字符结束的字符数组来替代：</strong></p>
<ol>
<li>允许使用以空字符结束的字符数组来初始化string对象或赋值。</li>
<li>在string对象的加法运算中允许使用空字符结束的字符数组作为其中一个运算对象(不能两个都是)；</li>
</ol>
<p>反之不行，不能用string对象来代替c风格字符串。为了完成这个功能，string专门提供了一个函数<strong>c_str</strong>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *str = s;				 <span class="comment">//错误，不能用string对象初始化char*</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *str = s.c_str(); <span class="comment">//正确</span></span><br></pre></td></tr></table></figure>
<p>c_str()函数返回值是一个以空字符结束的字符数组的指针。指针类型是const char*。但如果后续操作改变了s的值那么之前返回的数组失去作用。</p>
<p>所以：如果执行完c_str()函数后想一直使用，那么最好拷贝一份。</p>
<h4 id="使用数组初始化vector对象："><a href="#使用数组初始化vector对象：" class="headerlink" title="使用数组初始化vector对象："></a>使用数组初始化vector对象：</h4><p>用数组初始化vector对象只需指明拷贝区域的<strong>首元素地址和尾后地址</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> int_arr[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec(begin(arr), end(arr));</span><br></pre></td></tr></table></figure>
<p>同样可以只拷贝数组的一部分：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; subVec(arr + <span class="number">1</span>, arr + <span class="number">4</span>);	<span class="comment">//拷贝arr[1],arr[2],arr[3]</span></span><br></pre></td></tr></table></figure>
<h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><p>多维数组就是数组的数组。</p>
<h4 id="多维数组的初始化："><a href="#多维数组的初始化：" class="headerlink" title="多维数组的初始化："></a>多维数组的初始化：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">4</span>] = &#123;		<span class="comment">//3个元素，每个元素都是大小为4 的数组</span></span><br><span class="line">	&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">	&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;,</span><br><span class="line">	&#123;<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中内嵌花括号不是必需的，例如下面：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>&#125;;		<span class="comment">//功能同上</span></span><br></pre></td></tr></table></figure>
<p>类似一维数组，初始化时并非所有元素都包含在初始化列表内：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//显式的初始化每行的首元素</span></span><br><span class="line"><span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">0</span>&#125;,&#123;<span class="number">4</span>&#125;,&#123;<span class="number">8</span>&#125;&#125;;</span><br><span class="line"><span class="comment">//显式初始化第一行</span></span><br><span class="line"><span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="多维数组下标引用："><a href="#多维数组下标引用：" class="headerlink" title="多维数组下标引用："></a>多维数组下标引用：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (&amp;row)[<span class="number">4</span>] = ia[<span class="number">1</span>]; 		<span class="comment">//row是含有4个元素的数组的引用，引用ia数组的第二个四元数组上</span></span><br></pre></td></tr></table></figure>
<h4 id="使用范围for处理多维数组："><a href="#使用范围for处理多维数组：" class="headerlink" title="使用范围for处理多维数组："></a>使用范围for处理多维数组：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">使用范围<span class="keyword">for</span>处理多维数组：</span><br><span class="line"><span class="keyword">size_t</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;row : ia)&#123;		<span class="comment">//对于外层数组的每一个元素，row是int[4]类型的引用</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> &amp;col : row)&#123;	<span class="comment">//对于内层数组的每一个元素</span></span><br><span class="line">		col = cnt;</span><br><span class="line">		++cnt;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上<strong>row必需声明为引用类型</strong>，这是因为如果不用引用类型那么auto会变为指向数组内首元素的指针，那么遍历指针就不合法了。所以除了最内层的循环，其他的循环变量都为引用类型。</p>
<h4 id="指针和多维数组："><a href="#指针和多维数组：" class="headerlink" title="指针和多维数组："></a>指针和多维数组：</h4><p>定义指向多维数组的指针，就是指向指针的指针。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> (*p)[<span class="number">4</span>] = ia;		<span class="comment">//指向ia第一个四元素数组的指针</span></span><br><span class="line">p = &amp;ia[<span class="number">2</span>];				<span class="comment">//指向ia的第三个元素</span></span><br></pre></td></tr></table></figure>
<p>通过使用auto或者decltype可以避免在数组面前加一个指针类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> p = begin(ia);p!=end(ia);++p)&#123; 		<span class="comment">//p指向ia的内层数组</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> q = begin(*p);q!=end(*p);++q)&#123;		<span class="comment">//q指向*p的数组的首元素</span></span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;*q&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="类型别名简化多维数组的指针："><a href="#类型别名简化多维数组的指针：" class="headerlink" title="类型别名简化多维数组的指针："></a>类型别名简化多维数组的指针：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> int_array = <span class="keyword">int</span>[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> int_array[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(int_array p = begin(ia);p!=end(ia);++p)&#123; 		<span class="comment">//p指向ia的内层数组</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> q = begin(*p);q!=end(*p);++q)&#123;		<span class="comment">//q指向*p的数组的首元素</span></span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;*q&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/23/iterator/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HuaRongxie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HuaRongxie's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/23/iterator/" itemprop="url">迭代器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-23T21:14:57+08:00">
                2019-02-23
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/C-Primer笔记/" itemprop="url" rel="index">
                    <span itemprop="name">C++Primer笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><h3 id="迭代器的介绍"><a href="#迭代器的介绍" class="headerlink" title="迭代器的介绍"></a>迭代器的介绍</h3><p>迭代器是一种比下标运算符访问元素更通用的机制。</p>
<p>所有标准库容器都可以使用<strong>迭代器</strong>，但是只有少数几种才同时支持<strong>下标运算符</strong>。</p>
<h4 id="迭代器类型："><a href="#迭代器类型：" class="headerlink" title="迭代器类型："></a>迭代器类型：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it1;		<span class="comment">//能读写vector&lt;int&gt;的元素</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span>::iterator it2;			<span class="comment">//能读写string对象中的元素</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator it3;<span class="comment">//只能读vector&lt;int&gt;的元素</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span>::const_iterator it4;		<span class="comment">//只能读string对象中的元素</span></span><br></pre></td></tr></table></figure>
<p>跟常量指针差不多，如果vector对象或string对象不是常量，那么既可以用iterator也可以用const_iterator。</p>
<h4 id="迭代器成员begin和end："><a href="#迭代器成员begin和end：" class="headerlink" title="迭代器成员begin和end："></a>迭代器成员begin和end：</h4><p>有迭代器的类型同时拥有返回迭代器的成员。比如这些类型都拥有名为begin和end的成员，其中begin成员负责返回指向第一个元素的迭代器。如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> a = v.begin(), b =v.end();</span><br></pre></td></tr></table></figure>
<p>迭代器b被称作尾后迭代器。它指向的是尾元素的下一个位置，本不存在的位置。</p>
<p><strong>如果容器为空，那么begin和end返回的是同一个尾后迭代器。</strong></p>
<p>如果容器对象的类型是常量，那么begin 和end返回的类型是const_iterator。如果不是则返回iterator：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cv;</span><br><span class="line"><span class="keyword">auto</span> it1 = v.begin();	<span class="comment">//it1的类型是vector&lt;int&gt;::iterator</span></span><br><span class="line"><span class="keyword">auto</span> it2 = cv.begin();	<span class="comment">//it2的类型是vector&lt;int&gt;::const_iterator</span></span><br></pre></td></tr></table></figure>
<p>如果对象只需读操作，那么我们可以使用两个新函数:</p>
<p><strong>cbegin</strong>和<strong>cend</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> it3 = v.cbegin(); 		<span class="comment">//it3的类型是const_iterator</span></span><br></pre></td></tr></table></figure>
<h3 id="迭代器运算符-操作-："><a href="#迭代器运算符-操作-：" class="headerlink" title="迭代器运算符(操作)："></a>迭代器运算符(操作)：</h3><table>
<thead>
<tr>
<th>*iter</th>
<th>返回迭代器iter所指元素的引用</th>
</tr>
</thead>
<tbody>
<tr>
<td>iter-&gt;mem</td>
<td>解引用iter并获取该元素的名为mem的成员，等价于(*iter).mem</td>
</tr>
<tr>
<td>++iter</td>
<td>令iter指示容器中的下一个元素</td>
</tr>
<tr>
<td>–iter</td>
<td>令iter指示容器中的上一个元素</td>
</tr>
<tr>
<td>iter1 == iter2、iter1 != iter2</td>
<td>判断两个迭代器是否相等(不相等)，如果两个迭代器指示的是同一个元素或者它们是同一个容器的尾后迭代器，则相等。</td>
</tr>
</tbody>
</table>
<h4 id="解引用和成员访问："><a href="#解引用和成员访问：" class="headerlink" title="解引用和成员访问："></a>解引用和成员访问：</h4><p>和指针一样，迭代器也能被解引用来获取所指示的元素，当然前提是迭代器合法并且确实指示某一个元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">"some string"</span>)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (s.begin() != s.end())&#123;	<span class="comment">//确保s非空</span></span><br><span class="line">    <span class="keyword">auto</span> it = s.begin();	<span class="comment">//it指示s的第一个字符</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; *it &lt;&lt;<span class="built_in">endl</span>;		<span class="comment">//解引用获取元素输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解引用可以获得迭代器所指的对象，如果对象的类型刚好是类，就能进一步<strong>访问它的成员</strong>。例如vector<string>想要检查元素是否为空就可以用：</string></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(*it).empty();	<span class="comment">//此处的括号必须要加</span></span><br></pre></td></tr></table></figure>
<p>然后为了简化上述操作，c++定义了 箭头运算符(-&gt;)。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">it-&gt;empty();		<span class="comment">//和上面意思相同</span></span><br></pre></td></tr></table></figure>
<h4 id="迭代器的移动："><a href="#迭代器的移动：" class="headerlink" title="迭代器的移动："></a>迭代器的移动：</h4><p>将迭代器从一个元素移到另外一个元素：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s= “some thing”;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it = s.begin();it!=s.end &amp;&amp; !<span class="built_in">isspace</span>(*it);++it)&#123;</span><br><span class="line">	*it = <span class="built_in">toupper</span>(*it); <span class="comment">//将当前字符大写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>在for里不用&lt;而用!= 的原因是因为迭代器使然</strong>，之前说只有string和vector等一些标准库类型有下标运算符，并非全部如此。与之类似，所有标准库容器的迭代器都定义了==和!=，但是大多数没有&lt;运算符。</p>
<h4 id="某些对vector对象操作会使迭代器失效："><a href="#某些对vector对象操作会使迭代器失效：" class="headerlink" title="某些对vector对象操作会使迭代器失效："></a>某些对vector对象操作会使迭代器失效：</h4><p>vector是动态增长，但也有副作用。已知的一个限制是不能在范围for循环中向vector对象添加元素。另外一个是任何一种可能改变vector容量的操作，比如push_back。都会使迭代器失效。9.3.6</p>
<h4 id="迭代器运算："><a href="#迭代器运算：" class="headerlink" title="迭代器运算："></a><strong>迭代器运算：</strong></h4><p>迭代器的算术运算(必须是两个迭代器指向同一个容器中的元素)：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">iter += n;	<span class="comment">//向前移动了n个元素</span></span><br><span class="line"></span><br><span class="line">iter -= n;		<span class="comment">//向后移动了n个元素</span></span><br><span class="line"></span><br><span class="line">iter1 - iter2; <span class="comment">//两个迭代器相减就是他们的距离</span></span><br><span class="line"></span><br><span class="line">&lt;、&gt;、&lt;=、&gt;=;<span class="comment">//两个迭代器的前后位置比较</span></span><br></pre></td></tr></table></figure>
<p>只要两个迭代器指向的是同一个容器或者尾元素，就能相减。距离是指右侧迭代器向前移动多少位就能追上左侧迭代器，其类型名是<strong>difference_type</strong>的带符号整型数。</p>
<p>ps：还需拓展</p>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/23/vector/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HuaRongxie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HuaRongxie's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/23/vector/" itemprop="url">标准库类型vector</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-23T21:14:37+08:00">
                2019-02-23
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/C-Primer笔记/" itemprop="url" rel="index">
                    <span itemprop="name">C++Primer笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="标准库类型vector"><a href="#标准库类型vector" class="headerlink" title="标准库类型vector"></a>标准库类型vector</h1><p>vector表示对象的集合，其中所有对象的类型都相同。它是一个容器。</p>
<p>想要使用vector需要添加头文件：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span></span><br></pre></td></tr></table></figure>
<p>同时vector也是一个<strong>类模板</strong>,因此需要提供额外信息指定模板实例化成什么样的类。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec;				<span class="comment">//ivec保存int类型的对象</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; file;	<span class="comment">//该向量的元素是vector对象</span></span><br></pre></td></tr></table></figure>
<h3 id="vector的初始化"><a href="#vector的初始化" class="headerlink" title="vector的初始化"></a>vector的初始化</h3><p><strong>常用初始化vector对象的方法:</strong></p>
<table>
<thead>
<tr>
<th>vector<t> v1</t></th>
<th>v1是一个空vector，它潜在元素是T类型的，执行默认初始化</th>
</tr>
</thead>
<tbody>
<tr>
<td>vector<t> v2(v1)</t></td>
<td>v2中包含有v1所有元素的副本</td>
</tr>
<tr>
<td>vector<t> v2 = v1</t></td>
<td>等价于v2(v1)</td>
</tr>
<tr>
<td>vector<t> v3(n, val)</t></td>
<td>v3包含了n个重复的元素，每个元素的值都是val</td>
</tr>
<tr>
<td>vector<t> v4(n)</t></td>
<td>v4包含了n个重复的执行了值初始化的对象</td>
</tr>
<tr>
<td>vector<t> v5{a, b, c…}</t></td>
<td>v5包含了初始值个数的元素，每个元素都被赋予相应的初始值</td>
</tr>
<tr>
<td>vector<t> v5 = {a, b, c…}</t></td>
<td>等价于v5{a, b, c…}</td>
</tr>
</tbody>
</table>
<h4 id="列表初始化vector对象："><a href="#列表初始化vector对象：" class="headerlink" title="列表初始化vector对象："></a>列表初始化vector对象：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; articles = &#123;“a”, “an”, “the”&#125;; <span class="comment">//花括号</span></span><br></pre></td></tr></table></figure>
<h4 id="创建指定元素的数量："><a href="#创建指定元素的数量：" class="headerlink" title="创建指定元素的数量："></a>创建指定元素的数量：</h4><p>用vector对象容纳的<strong>元素数量</strong>，和<strong>元素统一初始值</strong>来初始化vector。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec(<span class="number">10</span>, <span class="number">-1</span>); 		<span class="comment">//10个int类型的元素，值都为-1</span></span><br></pre></td></tr></table></figure>
<h4 id="值初始化："><a href="#值初始化：" class="headerlink" title="值初始化："></a>值初始化：</h4><p>通常情况下，我们可以只提供vector元素的数量。那么库会创建一个<strong>值初始化</strong>的元素初值，由vector对象的类型决定。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec(<span class="number">10</span>);		<span class="comment">//10个元素都是0</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; svec(<span class="number">10</span>);	<span class="comment">//10个每个都是空的string对象</span></span><br></pre></td></tr></table></figure>
<p>这种初始化有两个限制：</p>
<ul>
<li>其一，有些类要求明确必须提供初始值(2.2.1)。</li>
<li>其二，只提供元素的数量而没有设定初始值只能用直接初始化,而不是拷贝初始化。</li>
</ul>
<h4 id="初始化的圆括号-，与花括号"><a href="#初始化的圆括号-，与花括号" class="headerlink" title="初始化的圆括号()，与花括号{}"></a>初始化的圆括号()，与花括号{}</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1(<span class="number">10</span>);		<span class="comment">//v1有10个元素，每个都是0 </span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2&#123;<span class="number">10</span>&#125;;		<span class="comment">//v2有1个元素是10  </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v3(<span class="number">10</span>, <span class="number">1</span>)	<span class="comment">//v3 10个元素每个是1</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v4&#123;<span class="number">10</span>,<span class="number">1</span>&#125; 	<span class="comment">//v3 有个2个元素。10和1</span></span><br></pre></td></tr></table></figure>
<p> 可以说：</p>
<ol>
<li>如果用的是圆括号，可以说提供的值是用来构造vector对象。</li>
<li>如果是用花括号，首先是表述为想用列表初始化该vector对象，除非当提供的值无法进行列表初始化，那么它会考虑其他初始化方式，比如下列：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; svec&#123;<span class="number">10</span>, “hi”&#125;;		<span class="comment">//花括号，会初始化为10个”hi”</span></span><br></pre></td></tr></table></figure>
<p>上述代码可以看出，int值无法初始化string对象，所以当编译器确定了无法执行列表初始化后，会尝试用默认值初始化vector对象。</p>
<h3 id="vector的操作："><a href="#vector的操作：" class="headerlink" title="vector的操作："></a>vector的操作：</h3><p><strong>vector支持的操作：</strong></p>
<table>
<thead>
<tr>
<th>v.empty()</th>
<th>如果v中不含有元素，返回真；否则返回假</th>
</tr>
</thead>
<tbody>
<tr>
<td>v.size()</td>
<td>返回v中元素的个数</td>
</tr>
<tr>
<td>v.push_back(t)</td>
<td>向v的尾端添加一个值为t的元素</td>
</tr>
<tr>
<td>v[n]</td>
<td>返回v中第n个位置上元素的引用</td>
</tr>
<tr>
<td>v1 = v2</td>
<td>用v2中元素拷贝替换v1中元素</td>
</tr>
<tr>
<td>v1 = {a, b, c…}</td>
<td>用列表中元素拷贝替换v1中元素</td>
</tr>
<tr>
<td>v1 == v2、 v1 != v2</td>
<td>v1和v2相等 当且仅当 它们的元素数量相同且对应位置元素值相同</td>
</tr>
<tr>
<td>&lt;, &lt;=, &gt;, &gt;=</td>
<td>以字典顺序比较</td>
</tr>
</tbody>
</table>
<h4 id="v-size-："><a href="#v-size-：" class="headerlink" title="v.size()："></a>v.size()：</h4><p>类似string类，v.size()返回的是 <strong>vector<t>::size_type</t></strong>类型</p>
<h4 id="vector不能用下标形式添加元素："><a href="#vector不能用下标形式添加元素：" class="headerlink" title="vector不能用下标形式添加元素："></a><strong>vector不能用下标形式添加元素：</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec;		<span class="comment">//空vector</span></span><br><span class="line">ivec[<span class="number">0</span>] = <span class="number">1</span>;			<span class="comment">//错误，ivec不包含任何元素</span></span><br></pre></td></tr></table></figure>
<p>空的vector不包含任何元素，自然不能用下标访问不存在的元素，正确的方法是用push_back。 否则会造成缓冲区溢出(buffer overflow)</p>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/20/string/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HuaRongxie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HuaRongxie's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/20/string/" itemprop="url">标准库类型string</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-20T06:44:44+08:00">
                2019-02-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/C-Primer笔记/" itemprop="url" rel="index">
                    <span itemprop="name">C++Primer笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="标准库类型string"><a href="#标准库类型string" class="headerlink" title="标准库类型string"></a>标准库类型string</h1><p>string表示可变长的字符序列。</p>
<ul>
<li>使用string类型必须首先包含头文件</li>
<li>作为标准库的一部分，string定义在命名空间std中。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br></pre></td></tr></table></figure>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>一个类可以定义很多种初始化对象的方式，但是这些方式之间必须有所区别：</p>
<ul>
<li>或者是初始值数量不同</li>
<li>或者是初始值类型不同</li>
</ul>
<p><strong>以下是初始化string的方式：</strong></p>
<ol>
<li>默认初始化</li>
</ol>
<p>通过默认的方式初始化一个string对象，得到的s1是个空字符串。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s1;			<span class="comment">//默认初始化</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>用另一个string进行初始化</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(s1)</span></span>;		<span class="comment">//s2是s1的副本</span></span><br><span class="line"><span class="built_in">string</span> s2 = s1;		<span class="comment">//等价于s2(s1)</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>给定一个字符串字面值</li>
</ol>
<p>则该字面值中除了最后一个空字符外其他所有的字符都被拷贝到新创建的string对象中去。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s3</span><span class="params">(“value”)</span></span>;	<span class="comment">//s3是字面值”value”的副本，除了字面值最后一个空字符外</span></span><br><span class="line"><span class="built_in">string</span> s3 = “value”;	<span class="comment">//同上</span></span><br></pre></td></tr></table></figure>
<ol start="4">
<li>给定一个数字和一个字符</li>
</ol>
<p>则string对象的内容是给定字符连续重复若干次后得到的序列。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s4</span><span class="params">(n,’c’)</span></span>;		<span class="comment">//把s4初始化为由连续n个字符c组成的串</span></span><br></pre></td></tr></table></figure>
<h4 id="直接初始化和拷贝初始化"><a href="#直接初始化和拷贝初始化" class="headerlink" title="直接初始化和拷贝初始化"></a>直接初始化和拷贝初始化</h4><p>像用“=”等号初始化一个变量是拷贝初始化，反之则是直接初始化。</p>
<p>而像上面的s4那样初始化用到的值有多个，一般来说只能使用直接初始化的方式。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s5 = <span class="string">"hi"</span>;		<span class="comment">//拷贝初始化</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s6</span><span class="params">(<span class="string">"hi"</span>)</span></span>;		<span class="comment">//直接初始化</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s7</span><span class="params">(<span class="number">10</span>, <span class="string">'C'</span>)</span></span>;		<span class="comment">//直接初始化，s7为cccccccccc</span></span><br></pre></td></tr></table></figure>
<h4 id="string对象上的操作"><a href="#string对象上的操作" class="headerlink" title="string对象上的操作:"></a><strong>string对象上的操作:</strong></h4><p>以下是大多数操作：</p>
<table>
<thead>
<tr>
<th>os&lt;&lt;s</th>
<th>将s写到输出流os中，返回os</th>
</tr>
</thead>
<tbody>
<tr>
<td>is&gt;&gt;s</td>
<td>将is中读出字符串赋给s，字符串以<strong>空白分隔</strong>，返回is</td>
</tr>
<tr>
<td>getline(is,s)</td>
<td>从is中读取一行赋给s，返回is</td>
</tr>
<tr>
<td>s.empty()</td>
<td>s为空返回true，否则返回false</td>
</tr>
<tr>
<td>s.size()</td>
<td>返回s中字符的个数</td>
</tr>
<tr>
<td>s[n]</td>
<td>返回s中第n个字符的引用，位置从0计起</td>
</tr>
<tr>
<td>s1+s2</td>
<td>返回s1和s2连接后的结果</td>
</tr>
<tr>
<td>s1=s2</td>
<td>用s2的副本代替s1中原来的字符</td>
</tr>
<tr>
<td>s1==s2</td>
<td>如果s1和s2中所含的字符完全一样，则他们相等</td>
</tr>
<tr>
<td>s1!=s2</td>
<td>与上相反</td>
</tr>
<tr>
<td>&lt;,&lt;=,&gt;,&gt;=</td>
<td>利用字符在字典中的顺序进行比较，对大小写敏感</td>
</tr>
</tbody>
</table>
<h4 id="读写string对象"><a href="#读写string对象" class="headerlink" title="读写string对象"></a>读写string对象</h4><p>可以使用io操作符读写string对象:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s1, s2;			<span class="comment">//空字符串</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s1 &gt;&gt; s2;		<span class="comment">//将string对象读入s，遇到空白停止</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; s1 &lt;&lt; s2 &lt;&lt;<span class="built_in">endl</span>;	<span class="comment">//输出s</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在执行读取操作时，string对象会自动<strong>忽略开头的空白</strong>(即空格符、换行符、制表符等)并从第一个真正的字符读起，直到<strong>遇见下一处空白</strong>。</p>
<p>例如输入”    hello world    “，那么输出会是”hello”和”world”，不会有空白。</p>
<h5 id="使用getline-读取一整行："><a href="#使用getline-读取一整行：" class="headerlink" title="使用getline()读取一整行："></a>使用getline()读取一整行：</h5><p>有时我们希望最终得到的字符串中保留输入时的空白符，那么用getline()代替原来的&gt;&gt;运算符。他的参数是一个输入流和一个string对象，函数从给定的输入流中读入内容，直到遇到换行符位置(换行符也读入)，然后将内容存到string(不存换行符)。随后返回它的流参数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> line;</span><br><span class="line">getline(<span class="built_in">cin</span>, line);			<span class="comment">//读入一整行</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; line &lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<h5 id="string-size-type类型："><a href="#string-size-type类型：" class="headerlink" title="string::size_type类型："></a>string::size_type类型：</h5><p>对于size()函数来说，返回一个int类型或者unsigned似乎都是合情合理的。但是size函数返回的是一个string::size_type类型的值。</p>
<p>string类以及其他大多数标准库类型都定义了几种配套的类型，为了体现标准库类型与机器无关。</p>
<p>它是一个<strong>无符号类型</strong>的值，而且<strong>足够存放</strong>下任何string对象的大小。</p>
<h5 id="比较string对象："><a href="#比较string对象：" class="headerlink" title="比较string对象："></a>比较string对象：</h5><p>相等性运算符(== 、!=)和关系运算符(&lt;、&lt;=、&gt;、&gt;=)都按照字典顺序：</p>
<ol>
<li><p>如果两个string对象的长度不同，而且较短string对象的每个字符都与较长string对象对应位置上字符相同，就说较短string小于较长string</p>
</li>
<li><p>如果两个string对象在某些对应位置上不一致，则string对象比较的结果其实是string对象中第一对不同字符比较的结果</p>
</li>
</ol>
<p>例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str = <span class="string">"Hello"</span>;</span><br><span class="line"><span class="built_in">string</span> phrase = <span class="string">"Hello World"</span>;</span><br><span class="line"><span class="built_in">string</span> slang = <span class="string">"Hiya"</span>;</span><br></pre></td></tr></table></figure>
<p>根据规则1，str&lt;phrase。根据规则2, slang&gt;phrase 也 &gt;str。</p>
<h5 id="字面值和string对象相加："><a href="#字面值和string对象相加：" class="headerlink" title="字面值和string对象相加："></a>字面值和string对象相加：</h5><p>标准库允许把字符字面值和字符串字面值转换成string对象。但必须确保每个加法运算符(+)两侧运算对象至少有一个是string：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s3 = s1 + <span class="string">"value"</span>;					<span class="comment">//正确 </span></span><br><span class="line"><span class="built_in">string</span> s4 = <span class="string">"value"</span> + <span class="string">","</span>;					<span class="comment">//错误 两个都不是string</span></span><br><span class="line"><span class="built_in">string</span> s5 = s1 + <span class="string">"value"</span> + <span class="string">","</span> + <span class="string">"dog"</span>; 	<span class="comment">//正确，每个加法都有一个string</span></span><br><span class="line"><span class="built_in">string</span> s6 = <span class="string">"value"</span> + <span class="string">","</span> + s1;				<span class="comment">//错误，不能把字面值相加</span></span><br></pre></td></tr></table></figure>
<p><strong><u>注意</u>：字符串字面值与string是不同的类型。</strong></p>
<h5 id="string处理字符的一些函数"><a href="#string处理字符的一些函数" class="headerlink" title="string处理字符的一些函数:"></a>string处理字符的一些函数:</h5><p><strong>表:cctype头文件的函数</strong></p>
<table>
<thead>
<tr>
<th>isalnum(c)</th>
<th>当c是字母或数字时为真</th>
</tr>
</thead>
<tbody>
<tr>
<td>isalpha(c)</td>
<td>当c是字母时为真</td>
</tr>
<tr>
<td>iscntrl(c)</td>
<td>当c是控制字符为真</td>
</tr>
<tr>
<td>isdigit(c)</td>
<td>当c是数字时为真</td>
</tr>
<tr>
<td>isgraph(c)</td>
<td>当c不是空格但可打印时为真</td>
</tr>
<tr>
<td>islower(c)</td>
<td>当c是小写字母时为真</td>
</tr>
<tr>
<td>isprint(c)</td>
<td>当c是可打印字符时为真(即c是空格或c具有可视形式)</td>
</tr>
<tr>
<td>ispunct(c)</td>
<td>当c是标点符号时为真(即c不是控制字符、数字、字母、可打印空白中的一种)</td>
</tr>
<tr>
<td>isspace(c)</td>
<td>当c是空白时为真(即c是空格、横向制表符、纵向制表符、回车符、换行符、进纸符中的一种)</td>
</tr>
<tr>
<td>isupper(c)</td>
<td>当c是大写字母时为真</td>
</tr>
<tr>
<td>isxdigit(c)</td>
<td>当c是十六进制数字时为真</td>
</tr>
<tr>
<td>tolower(c)</td>
<td>如果c是大写字母，输出对应的小写字母；否则原样输出c</td>
</tr>
<tr>
<td>toupper(c)</td>
<td>如果c是小写字母，输出对应的大写字母；否则原样输出c</td>
</tr>
</tbody>
</table>
<p><strong><u>建议</u>使用c++的兼容c的标准库头文件</strong>。c语言头文件为name.h而c++则将命名为cname。</p>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/19/variable-type/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HuaRongxie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HuaRongxie's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/19/variable-type/" itemprop="url">变量、基本类型和类型别名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-19T22:32:03+08:00">
                2019-02-19
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/C-Primer笔记/" itemprop="url" rel="index">
                    <span itemprop="name">C++Primer笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="变量、基本类型和类型别名"><a href="#变量、基本类型和类型别名" class="headerlink" title="变量、基本类型和类型别名"></a><strong>变量、基本类型和类型别名</strong></h1><p><strong>任何编程语言都具备一组公共语法特征，基本特征包括</strong>：</p>
<ul>
<li>整型、字符型等内置类型</li>
<li>变量，用来为对象命名</li>
<li>表达式和语句，用于操纵上述数据类型的具体值</li>
<li>if或while等控制结构，这些结构允许我们有选择的执行一些语句。</li>
<li>函数，用于定义可供随时调用的计算单元</li>
</ul>
<p><strong>大多数变成语言通过两种方式来进一步补充其基本特征</strong>：</p>
<ol>
<li>赋予程序员自定义数据类型的权利，从而实现扩展</li>
<li>将一些有用的功能封装成库函数提供使用</li>
</ol>
<h2 id="基本内置类型"><a href="#基本内置类型" class="headerlink" title="基本内置类型"></a>基本内置类型</h2><p>C++定义了一套包括算术类型(arithmetic type)和空类型(void)在内的基本数据类型。其中算术类型包括字符、整型数、布尔值和浮点数。</p>
<h3 id="C-基本类型大小"><a href="#C-基本类型大小" class="headerlink" title="C++基本类型大小"></a>C++基本类型大小</h3><p>int，long int，short int的宽度都可能随编译器而异。但有几条铁定的原则（ANSI/ISO制订的）：</p>
<ul>
<li>sizeof(short int) &lt;= sizeof(int)</li>
<li>sizeof(int) &lt;= sizeof(long int)</li>
<li>short int至少应为16位（2字节）</li>
<li>long int至少应为32位。</li>
</ul>
<p><strong>表：c++算数类型</strong></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>含义</th>
<th>最小尺寸</th>
</tr>
</thead>
<tbody>
<tr>
<td>bool</td>
<td>布尔类型(true,false)</td>
<td>未定义</td>
</tr>
<tr>
<td>char</td>
<td>字符</td>
<td>8位</td>
</tr>
<tr>
<td>wchar_t</td>
<td>宽字符</td>
<td>16位</td>
</tr>
<tr>
<td>char16_t</td>
<td>Unicode字符</td>
<td>16位</td>
</tr>
<tr>
<td>char32_t</td>
<td>Unicode字符</td>
<td>32位</td>
</tr>
<tr>
<td>short</td>
<td>短整型</td>
<td>16位</td>
</tr>
<tr>
<td>int</td>
<td>整型</td>
<td>16位</td>
</tr>
<tr>
<td>long</td>
<td>长整型</td>
<td>32位</td>
</tr>
<tr>
<td>long long</td>
<td>长整型</td>
<td>64位</td>
</tr>
<tr>
<td>float</td>
<td>单精度浮点数</td>
<td>6位有效数字</td>
</tr>
<tr>
<td>double</td>
<td>双精度浮点数</td>
<td>10位有效数字</td>
</tr>
<tr>
<td>long double</td>
<td>扩展进度浮点数</td>
<td>10位有效数字</td>
</tr>
</tbody>
</table>
<p>c++标准制定了一个浮点数有效位数的最小值，然而大多数编译器实现了更高的进度。通常float以1个字节(32位)来表示，double以2个字节表示，long double以3或4个字节表示。</p>
<h4 id="带符号和不带符号类型"><a href="#带符号和不带符号类型" class="headerlink" title="带符号和不带符号类型"></a>带符号和不带符号类型</h4><p>除去布尔型和扩展的字符型之外，其他可以划分为带符号的(signed)和不带符号的(unsigned)。带符号可表示正数、负数或0，无符号仅能表示大于等于0的值。</p>
<p>类型int、short、long、long long都是带符号的，在前添加unsigned就是不带符号的类型，unsigned int可以缩写为unsigned。</p>
<p>与其他整型不同 char被分为三种 char 、signed char、unsigned char。尽管字符型有3种但是字符的表现形式只有两种：带符号和无符号。类型char会表现为以上两种，具体由编译器决定。</p>
<p>例：8bit的signed char表示范围定为-128~127。</p>
<p><u><strong>建议：选择类型</strong></u></p>
<ul>
<li>当明确数值为正时，选用无符号类型</li>
<li>使用int执行整数运算。在应用中，short常常太小而long一般和int一样的尺寸。如果数值超过了int表示范围。选用long long</li>
<li>算数表达式中不要使用char 或 bool，只有在存放字符或布尔时使用它们。因为类型char在一些机器上是有符号而另一些是无符号，容易出问题。如果需要使用一个不大的整数明确是unsigned char 还是 signed char。</li>
<li>执行浮点数运算选用double，因为float通常精度不够而且双精度浮点数和单精度浮点数计算代价相差无几。事实上对于某些机器来说双精度运算更快。</li>
</ul>
<h3 id="字面值常量（literal）"><a href="#字面值常量（literal）" class="headerlink" title="字面值常量（literal）"></a>字面值常量（literal）</h3><p>一个形如42的值被称作<strong>字面值常量</strong>，这样的值一望而知。每个字面值常量都对应一种数据类型，由它的形式和值决定。</p>
<h4 id="整数和浮点型字面值："><a href="#整数和浮点型字面值：" class="headerlink" title="整数和浮点型字面值："></a><strong>整数和浮点型字面值：</strong></h4><p> 整型字面值写成 十进制、八进制、十六进制。以0开头的整数代表八进制数，以0x、0X代表十六进制。例如：</p>
<p> 20  (十进制 )             024 (八进制)             0x14 (十六进制)</p>
<p>整型字面值的数据类型由他的值和符号决定。默认情况，十进制字面值带符号数，八进制和十六进制带符号不带符号都可能。十进制是int、long、long long中能容纳下当前值的最小尺寸（例如三者最小是int）。八进制和十六进制是int 、unsigned int、…unsigned long long 中容纳下当前值的最小尺寸。如果一个字面值与之关联的最大数据类型都放不下则产生错误。short无字面值。</p>
<p>负号字面值只是 字面值取反。例如-42，负号不在字面值内，它的作用仅仅是对字面值取负值而已。</p>
<p>浮点数字面值表示为 小数或带e的科学计数法的指数。默认是double</p>
<h4 id="字符和字符串字面值："><a href="#字符和字符串字面值：" class="headerlink" title="字符和字符串字面值："></a>字符和字符串字面值：</h4><p>字符：‘a’</p>
<p>字符串：“hello”</p>
<p>字符串字面值是由常量字符组成的数组，<strong>最后有个‘\0’空字符</strong>。如果两个字符串字面值由空格、缩进、换行符分隔，实际上是一个字符串。</p>
<h4 id="布尔和指针字面值："><a href="#布尔和指针字面值：" class="headerlink" title="布尔和指针字面值："></a>布尔和指针字面值：</h4><p>布尔：true、false</p>
<p>指针：nullptr</p>
<h4 id="转义序列："><a href="#转义序列：" class="headerlink" title="转义序列："></a>转义序列：</h4><p>有两类字符程序员不能直接使用：</p>
<ol>
<li>不可打印的字符，如退格或其他控制字符</li>
<li>在c++语言中含有特殊含义的字符（引号、问号等）</li>
</ol>
<p>这时候就需要用到转义序列。</p>
<table>
<thead>
<tr>
<th>换行符</th>
<th>\n</th>
<th>横向制表符</th>
<th style="text-align:left">\t</th>
<th>报警符</th>
<th>\a</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>纵向制表符</strong></td>
<td><strong>\v</strong></td>
<td><strong>退格符</strong></td>
<td style="text-align:left">\b</td>
<td>双引号</td>
<td>\“</td>
</tr>
<tr>
<td><strong>反斜线</strong></td>
<td>\ \</td>
<td>问号</td>
<td style="text-align:left">\?</td>
<td><strong>单引号</strong></td>
<td>\‘</td>
</tr>
<tr>
<td><strong>回车符</strong></td>
<td><strong>\r</strong></td>
<td><strong>进纸符</strong></td>
<td style="text-align:left">\f</td>
<td></td>
</tr>
</tbody>
</table>
<p>也可以用泛化的转义序列，有下两种形式：</p>
<ol>
<li>\x 后紧跟1个或多个十六进制数字（一般超过8位的十六进制字符都是与下表中的某个前缀开头的扩展字符集一起使用的）</li>
<li>\ 后紧跟1~3个八进制数字</li>
</ol>
<h4 id="指定字面值的类型："><a href="#指定字面值的类型：" class="headerlink" title="指定字面值的类型："></a>指定字面值的类型：</h4><p><strong>表：字符和字符串字面值：</strong></p>
<table>
<thead>
<tr>
<th>前缀</th>
<th>含义</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>u</td>
<td>Unicode16字符</td>
<td>char16_t</td>
</tr>
<tr>
<td>U</td>
<td>Unicode32字符</td>
<td>char32_t</td>
</tr>
<tr>
<td>L</td>
<td>宽字符</td>
<td>wchar_t</td>
</tr>
<tr>
<td>u8</td>
<td>UTF-8（仅用于字符串字面常量）</td>
<td>char</td>
</tr>
</tbody>
</table>
<p><strong>表：整型字面值</strong>                            </p>
<table>
<thead>
<tr>
<th>后缀</th>
<th>最小匹配类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>u or U</td>
<td>unsigned</td>
</tr>
<tr>
<td>l or L</td>
<td>long</td>
</tr>
<tr>
<td>ll or LL</td>
<td>long long</td>
</tr>
</tbody>
</table>
<p><strong>表：浮点型字面值</strong></p>
<table>
<thead>
<tr>
<th>后缀</th>
<th>最小匹配类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>f or F</td>
<td>float</td>
</tr>
<tr>
<td>l or L</td>
<td>long double</td>
</tr>
</tbody>
</table>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量提供一个具名的、可供程序操作的存储空间。C++中的每个变量都有其数据类型，数据类型决定着变量所占空间的大小和布局方式、该空间存储值的范围，以及变量能参与的运算。</p>
<h4 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h4><p>变量定义的基本形式：类型说明符 变量名，变量名；</p>
<p>例：int a=0,b;</p>
<h4 id="变量初始化"><a href="#变量初始化" class="headerlink" title="变量初始化"></a>变量初始化</h4><p>初始化的含义是创建变量时赋予一个初始值。而赋值这是把对象的当前值擦除，用一个新值代替。</p>
<ol>
<li>列表初始化</li>
<li>默认初始化: 如果定义变量时没有指定初值，则变量被<strong>默认初始化</strong>。内置类型在函数体外定义的话初始化为0， 函数体内则不被初始化. string 在函数内外都是默认为空字符串</li>
</ol>
<h4 id="变量的声明与定义（extern关键字）"><a href="#变量的声明与定义（extern关键字）" class="headerlink" title="变量的声明与定义（extern关键字）"></a>变量的声明与定义（extern关键字）</h4><p>C++语言支持分离式编译机制，该机制允许每个文件独立编译。为了支持分离时编译，C++将声明与定义区分开来。<strong>声明</strong>使得名字为程序所知，<strong>定义</strong>创建与名字相关联的实体。</p>
<p>定义区别于声明是定义除了规定了变量的类型和名字，还会申请存储空间与赋初始值。</p>
<p>在变量名前加关键字(extern)是声明但不要显示地初始化。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> i; <span class="comment">//声明非定义</span></span><br><span class="line"><span class="keyword">int</span> i ; <span class="comment">//声明且定义</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> i = <span class="number">2</span>; <span class="comment">//定义</span></span><br></pre></td></tr></table></figure>
<p>变量只能被定义一次，但可以被多次声明。在函数内部如果试图初始化一个extern关键字标记的变量会引发错误。</p>
<h4 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h4><p>标识符由字母数字下划线组成，必须以字母下划线开始，对长度无限制大小写敏感，不得使用c++关键字，不得连续两个下划线或下划线后加大写字母。</p>
<p><img src="/2019/02/19/variable-type/identifier.png" alt="c++关键字"></p>
<h4 id="作用域（scope）："><a href="#作用域（scope）：" class="headerlink" title="作用域（scope）："></a><strong>作用域（scope）：</strong></h4><p>作用域是程序的一部分，C++语言中大多数作用域都以花括号分隔。</p>
<p>同一个名字在不同的作用域中可能指向不同的实体。名字的有效区域始于名字的声明语句，以声明语句所在的作用域末端为结束。</p>
<p>外层作用域的变量能被能层作用域使用，当内层同样定义了一个相同的变量时会覆盖外层的变量，如需使用则要显示的调用，用<strong>作用域符号</strong>   “<strong>::</strong>“</p>
<h3 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h3><p>复合类型是指基于其他类型定义的类型。最常见的两种是<strong>引用</strong>和<strong>指针</strong>。</p>
<h4 id="复合类型的声明"><a href="#复合类型的声明" class="headerlink" title="复合类型的声明"></a>复合类型的声明</h4><p>变量的定义包括一个基本数据类型和一组声明符。在一条定义语句中，基本数据类型只有一个但是声明符的不同可以定义出不同类型的变量。</p>
<p>例：int i = 1024, *p = &amp;i, &amp;r = i;        //i是一个int数， p是int型指针， r是int型引用</p>
<h4 id="指针和引用的区别："><a href="#指针和引用的区别：" class="headerlink" title="指针和引用的区别："></a><strong>指针和引用的区别：</strong></h4><ol>
<li>指针指向内存中的某个对象，引用直接绑定对象。</li>
<li>指针本身是一个对象，允许指针赋值拷贝，在生命周期内可以指向不同的对象；引用不是对象，无法令引用重新绑定到其他对象。</li>
<li>指针无须在定义时赋初值，和其他内置类型一样，在块作用域内如果没有被初始化则将拥有一个不确定的值；引用则必须在定义时赋初值。</li>
</ol>
<h3 id="类型的处理"><a href="#类型的处理" class="headerlink" title="类型的处理"></a>类型的处理</h3><h4 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h4><p>类型别名用于简化一些复杂的类型名字。有typedef (类型别名)和 using (别名声明)两种方法。</p>
<p><strong>typedef：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> wages;	<span class="comment">//wages是double的同义词</span></span><br><span class="line"><span class="keyword">typedef</span> wages base, *p;	<span class="comment">//base是double的同义词，p是double*的同义词</span></span><br></pre></td></tr></table></figure>
<p><strong>using:</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> db = <span class="keyword">double</span>;		<span class="comment">//db是double的同义词</span></span><br></pre></td></tr></table></figure>
<p><strong><u>注意</u>的是某个类型别名指代的是符合类型或常量，那么用到声明语句就会产生意想不到的后果。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *pstring;</span><br><span class="line"><span class="keyword">const</span> pstring cstr = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>上面定义了pstring为char*类型，而const是对给定类型的修饰。所以const是修饰指针类型，cstr则是指向char的常量指针。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *cstr = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>而这处const修饰的是char，则cstr是指向常量char的指针。</p>
<h4 id="auto类型说明符"><a href="#auto类型说明符" class="headerlink" title="auto类型说明符"></a>auto类型说明符</h4><p>auto 类型说明符可以让编译器通过初始值去推算类型。因此auto定义的变量必须有初始值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> item = val1 + val2;	<span class="comment">//val1、val2相加的结果推出item的类型</span></span><br></pre></td></tr></table></figure>
<p>使用auto也能在一条语句中声明多个变量。但是一条声明语句只能有一个基本数据类型，所以语句中变量的初始基本类型都必须一样。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> i = <span class="number">0</span>, *p = &amp;i;	<span class="comment">//正确：i是整数、p是整型指针</span></span><br><span class="line"><span class="keyword">auto</span> sz = <span class="number">0</span>, pi = <span class="number">3.14</span>;	<span class="comment">//错误：sz和pi的类型不一致</span></span><br></pre></td></tr></table></figure>
<p><strong>编译器推断出来的auto类型有时候和初始值的类型并不完全一样。</strong></p>
<p>例如<strong>引用</strong>，编译器会以引用对象的类型来作为auto的类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, r = &amp;i;</span><br><span class="line"><span class="keyword">auto</span> a = r;				<span class="comment">//a是一个int类型的整数</span></span><br></pre></td></tr></table></figure>
<p>其次一般会忽略掉顶层const，而底层const会保留下来:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = i;</span><br><span class="line"><span class="keyword">auto</span> b = ci;			<span class="comment">//b是整数(ci的顶层const被忽略)</span></span><br><span class="line"><span class="keyword">auto</span> c = &amp;i;			<span class="comment">//c是整型指针(整数的地址就是指向整数的指针)</span></span><br><span class="line"><span class="keyword">auto</span> d = &amp;ci; 			<span class="comment">//d是指向整数常量的指针(对常量对象取地址是底层const)</span></span><br></pre></td></tr></table></figure>
<p>如果希望推出的是顶层const则需要明确定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> e = ci；</span><br></pre></td></tr></table></figure>
<h4 id="decltype类型指示符"><a href="#decltype类型指示符" class="headerlink" title="decltype类型指示符:"></a><strong>decltype类型指示符:</strong></h4><p>decltype说明符能从表达式的类型推断出要定义的变量的类型。在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(f()) sum = x;	<span class="comment">//sum的类型就是函数f的返回类型</span></span><br></pre></td></tr></table></figure>
<p>decltype处理顶层const与auto有些不同。</p>
<p>如果decltype使用的表达式是一个变量，则decltype返回的类型包括<strong>顶层const</strong>和<strong>引用</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">0</span>, &amp;cj = ci;	</span><br><span class="line"><span class="keyword">decltype</span>(ci) x = <span class="number">0</span>;		<span class="comment">//x的类型是const int</span></span><br><span class="line"><span class="keyword">decltype</span>(cj) y = x;		<span class="comment">//y的类型是const int&amp;，y绑定到变量x</span></span><br><span class="line"><span class="keyword">decltype</span>(cj) z;			<span class="comment">//错误，z是引用，必须初始化</span></span><br></pre></td></tr></table></figure>
<p><strong>需要指出的是，引用从来都是作为所指对象的同义词出现，只有用在decltype处是个例外。</strong></p>
<p>如果decltype使用的表达式不是一个变量，则decltype返回表达式结果对应的类型：</p>
<p>如果表达式求值的结果是一个<strong>左值</strong>(参看左值与右值)，那么decltype返回的是一个引用类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>, *p = &amp;i, &amp;r = i;</span><br><span class="line"><span class="keyword">decltype</span>(r + <span class="number">0</span>) b;		<span class="comment">//正确：加法的结果是int，因此b是一个int</span></span><br><span class="line"><span class="keyword">decltype</span>(*p) c;			<span class="comment">//错误：c是int&amp;，必须初始化</span></span><br></pre></td></tr></table></figure>
<p>解释一下上面代码。因为r是一个引用，因此decltype(r)的结果是引用类型，如果想让结果是r所指的类型，可以把r作为表达式的一部分。显然这个表达式的结果是一个具体值。</p>
<p>而解引用操作得到的结果是一个左值，因此decltype(*p)是一个引用类型。</p>
<p>decltype的一个注意的点是：如果decltype所用的表达式是一个变量名加上了一层或多层括号，编译器就会将变量认为是表达式。而变量是一种可以作为赋值语句左值的特殊表达式。所以decltype得到的结果会是引用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>((i)) d;		<span class="comment">//错误：d是int &amp;,必须初始化</span></span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/18/gun-compile/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HuaRongxie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HuaRongxie's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/18/gun-compile/" itemprop="url">GUN编译器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-18T23:11:44+08:00">
                2019-02-18
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/C-Primer笔记/" itemprop="url" rel="index">
                    <span itemprop="name">C++Primer笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="GUN编译器"><a href="#GUN编译器" class="headerlink" title="GUN编译器"></a>GUN编译器</h2><p>编译器的一部分工作是检查文本错误：</p>
<ol>
<li>语法错误(syntax)：引号 分号等</li>
<li>类型错误(type error): 向一个int类型的变量传递了字符串字面值常量</li>
<li>声明错误(declaration error): c++的每个名字都要先声明才能使用。两种常见的声明错误是:对来自标准库的名字忘记使用std:: 、标识符名字拼写错误。(v1 写成v)</li>
</ol>
<h3 id="安装GUN编译器出现的错误："><a href="#安装GUN编译器出现的错误：" class="headerlink" title="安装GUN编译器出现的错误："></a>安装GUN编译器出现的错误：</h3><p><strong>“没有文件扩展‘.js’的脚本引擎。”</strong></p>
<p><img src="/2019/02/18/gun-compile/no-js.png" alt="no-js"></p>
<p>该错误是默认js打开方式被修改了。（我是安装了webstorm。-  -）</p>
<ol>
<li>打开注册表编辑器中的“HEKY_CLASSES_ROOT.js” </li>
<li>修改默认的文件为 <strong>JSFile</strong></li>
</ol>
<p><img src="/2019/02/18/gun-compile/register.png" alt="注册表编辑器"></p>
<h3 id="安装完成后的步骤："><a href="#安装完成后的步骤：" class="headerlink" title="安装完成后的步骤："></a>安装完成后的步骤：</h3><ol>
<li>打开MinGW Installation Manager</li>
<li>选择MinGW Compiler Suite之后，添加The GUN C++ Compiler的相关项</li>
<li>然后点击installation -&gt; apply changes 等待完成</li>
</ol>
<h3 id="环境变量配置："><a href="#环境变量配置：" class="headerlink" title="环境变量配置："></a>环境变量配置：</h3><ul>
<li>在PATH里面添加bin目录路径，我的是C:\MinGW\bin</li>
<li>重启cmd 然后输入g++ -v 如果出现gcc版本就说明配置成功</li>
</ul>
<p><img src="/2019/02/18/gun-compile/cmd-gcc.png" alt="cmd-gcc-version"></p>
<h3 id="GUN编译"><a href="#GUN编译" class="headerlink" title="GUN编译"></a>GUN编译</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -o _test test.cpp</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/25/hello-world/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HuaRongxie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HuaRongxie's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/25/hello-world/" itemprop="url">Hello World</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-25T23:42:24+08:00">
                2018-11-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Testing/" itemprop="url" rel="index">
                    <span itemprop="name">Testing</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">HuaRongxie</p>
              <p class="site-description motion-element" itemprop="description">默而识之，学而不厌，诲人不倦，何有于我哉？</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa fa-fw fa-link"></i>
                友情链接
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://jiangwr.github.io" title="鸢之" target="_blank">鸢之</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">HuaRongxie</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>